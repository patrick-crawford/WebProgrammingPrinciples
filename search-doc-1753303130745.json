{"searchDocs":[{"title":"Practice Exercise","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Practice-Exercise","content":"","keywords":"","version":"Next"},{"title":"Morse Code translator​","type":1,"pageTitle":"Practice Exercise","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Practice-Exercise#morse-code-translator","content":" Morse code is a system of encoding developed in the 1800s that allowed transmission of textual messages over signal systems that only supported on/off (1 and 0) notations.  Complete the program below as specified. Your program should be able to translate messages like-- --- .-. ... ./-.-. --- -.. . into MORSE CODE and vice versa. Use what you learned above about Objects, and also some of the built-in Objects we've studied, in particularRegExp and String.  Use the following limited set of morse code to use in this exercise. You could expand your program to handle more complex messages later if you want:  Letter\tMorseA\t.- B\t-... C\t-.-. D\t-.. E\t. F\t..-. G\t--. H\t.... I\t.. J\t.--- K\t-.- L\t.-.. M\t-- N\t-. O\t--- P\t.--. Q\t--.- R\t.-. S\t... T\t- U\t..- V\t...- W\t.-- X\t-..- Y\t-.-- Z\t--.. space\t/  NOTE: letters are separated by a single space (' ') within a word, and words are separated with a /. For example, the words MORSE CODE would translate to -- --- .-. ... ./-.-. --- -.. .  // Object to provide lookup of morse code (value) for a given letter (key). let alpha = { // define the mapping here as a literal }; // Object to provide lookup of letter (value) for a given morse code (key). let morse = {}; // Hint: use the [] operator to specify these special key values rather than a literal. // Return `true` if all characters are morse code. Use a RegExp. function isMorse(characters) {} // Return `true` if all characters are part of the alphabet defined in `alpha`. Use a RegExp. // Bonus: can you rewrite it using `Object.keys()` and your `alpha` Object instead? // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys function isAlpha(characters) {} // Given an alphabet message, convert and return in morse code. Use your morse and/or alpha object. // Return undefined if text is not alpha. function textToMorse(text) {} // Given a morse code message, convert and return in text. Use your morse and/or alpha object. // Return undefined if morse is not proper code. function morseToText(morse) {} // Message class that takes a `message` (String), which can be either morse or alpha. // Use your functions above to decide how to store a value for `any` on `this` class Message { constructor(text) {} // Return the message as morse code, converting if necessary toMorse() {} // Return the message as alpha characters, converting if necessary toAlpha() {} } let msg1 = new Message( '--- -... .--- . -.-. - .../.. -./.--- .- ...- .- ... -.-. .-. .. .--. -/.- .-. ./...- . .-. -.--/.--. --- .-- . .-. ..-. ..- .-..' ); console.log(msg1.toAlpha()); console.log(msg1.toMorse()); let msg2 = new Message('I am learning how to use Objects in JavaScript'); console.log(msg2.toMorse()); console.log(msg2.toAlpha());   You can download the code above as well as a possible solution. ","version":"Next","tagName":"h2"},{"title":"Practice Exercise","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Box-Model-Layout/Practice-Exercise","content":"Practice Exercise In this in-class exercise we'll create a simple blog post style layout using HTML and CSS. Begin by downloading the layout.zip file. From there, you will notice that we have both: Initial HTML with no CSS: &quot;no-css.html&quot;Final version with CSS: &quot;with-css.html&quot;","keywords":"","version":"Next"},{"title":"Constructor Functions","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions","content":"","keywords":"","version":"Next"},{"title":"Object Prototypes​","type":1,"pageTitle":"Constructor Functions","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions#object-prototypes","content":" What we would really like is a way to separate the parts of a User that are different for each user (the data: id, name), but somehow share the parts that are the same (the methods: toString). JavaScript gives us a way to accomplish this via an Object's prototype.  JavaScript is unique among programming languages in the way it accomplishes sharing between Objects. All object-oriented languages provide some mechanism for us to share or inherit things like methods in a type hierarchy. For example, C++ and Java use classes, which can inherit from one another to define methods on parents vs. children. JavaScript uses prototypal inheritance and a special property called prototype.  In JavaScript, we always talk about Objects, because every object is an instance of Object. Notice the capital O in Object, which should give you an indication of what it is: a constructor function. In a previous week we said that an Array is an Object, and a RegExp is an Object. This is true because of JavaScript's type system, where almost everything is chained to Object.  JavaScript objects always have a prototype, which is an object to which their .prototype property refers. At runtime, when we refer to an object's property, JavaScript first looks for that property on the object itself. If it doesn't find it, the prototype object is visited, and the same search is done. The process continues until the end of the prototype chain is reached at Object.  Let's rewrite our User so that the toString method is moved from each user instance to the prototype of all user instances:  // Define a Constructor function, `User` function User(id, name) { this.id = id; this.name = name; } User.prototype.toString = function () { return `${this.name} (#${this.id})`; };   This code looks very similar to what we originally wrote. Notice that we've movedtoString out of the User function, and instead attached it to User.prototype. By doing so, we'll only ever need a single copy of this function: every new User() instance we create will also include a reference to a prototype object, which contains our function. When we use user1.toString(), JavaScript will do something like this:  does user1 have a property called toString? No, we didn't add one in the constructor.does user1.prototype have a property called toString? Yes, use that.  What if we'd written user1.something()?  does user1 have a property called something? No, we didn't add one in the constructor.does user1.prototype have a property called something? No.does user1.prototype.prototype (i.e., Object) have a property called something? No.there are no more objects in the prototype chain, throw an error  user1.something(); // TypeError: user1.something is not a function   Whenever a method is used on a prototype, we still pass the current instance so we can get access to its data. Notice in our User.prototype.toString method, we still referred to this, which will be the instance of our user, and give us access to the correct data (name, id).  There are times when defining a method inside a constructor makes sense vs. putting it on the prototype. The prototype will only have access to public properties of an object instance, meaning things you explicitly add to this and expose to the rest of your program. Sometimes we want to define some data, but hide it from the rest of a program, so it can't be changed after it gets created. Consider the following example, which uses a closure to retain access to a variable in the scope of the constructor without exposing it:  function User(id, name) { this.id = id; this.name = name; // private variable within User function, not attached to `this`. // Normally this variable would go out of scope after User() completed; // however, we will use a closure function below to capture this scope. let createdAt = Date.now(); // Return the number of ms this player has been playing this.playerAgeMS = function () { let currentTime = Date.now(); // Access `createdAt` in the parent scope, which we retain via this closure function. // Calculate how many ms between createdAt and the current time. return currentTime - createdAt + ' ms'; }; } let user = new User(1, 'Tom'); // We can access the total time this player has existed, but not modify it. console.log(user.playerAgeMS()); // displays &quot;4183 ms&quot; console.log(user.playerAgeMS()); // displays &quot;5287 ms&quot;   ","version":"Next","tagName":"h2"},{"title":"JavaScript's class and Object​","type":1,"pageTitle":"Constructor Functions","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions#javascripts-class-and-object","content":" For a long time, JavaScript didn't have any notion of a class. Most Object-Oriented languages are based on the idea of a class, but JavaScript only has runtime instances (i.e., Objects) and didn't need them.  In recent years, a new syntax has been added to JavaScript to allow those more familiar with traditional OOP style programming to define their Objects using a new class keyword.  Let's recreate our code above as a class in JavaScript:  class User { id; name; constructor(id, name) { this.id = id; this.name = name; } toString() { return `${this.name} (#${this.id})`; } }   This code still uses the same prototype technique we learned above above, but does so in a more familiar syntax.  We can even use other OOP features like inheritance:  class Student extends User { email; constructor(id, name, email) { // Call the User() constructor to set the inherited properties super(id, name); this.email = email; } // Override the toString() method for a Student toString() { return `&quot;${this.name}&quot; &lt;${this.email}&gt;`; } } let student = new Student('10234134', 'Jen Hogan', 'jhogan@myseneca.ca'); console.log(student.id, student.name, student.email); console.log(student.toString());  ","version":"Next","tagName":"h2"},{"title":"Using REST APIs to Integrate Data in Web Apps","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Case-Study/Using-REST-APIs-Integrate-Data-Web-Apps","content":"Using REST APIs to Integrate Data in Web Apps","keywords":"","version":"Next"},{"title":"Box Model","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model","content":"","keywords":"","version":"Next"},{"title":"display Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#display-property","content":" CSS lets us control how an element gets displayed in the DOM. This is a large topic, and we'll give an overview of some of the most common display types. Further study is required to fully appreciate the subtleties of each layout method.  Up to this point we've been talking a lot about the DOM, a tree of nodes for every element in our document. At this stage it's also useful to understand that in addition to the DOM tree, a browser also creates a render tree, which is a tree of nodes as they will should be rendered based on CSS. A node may exist in the DOM tree but not in the render tree, for example. The nodes in the DOM tree can also have very different rendering applied based on the type of display we specify.  Perhaps the easiest way to get started understanding display types is to look at what display: none; does:  &lt;style&gt; .hidden { display: none; } .error-msg { /* styles for error message UI */ } &lt;/style&gt; &lt;div class=&quot;hidden error-msg&quot;&gt; &lt;h1&gt;Error!&lt;/h1&gt; &lt;p&gt;There was an error completing your request.&lt;/p&gt; &lt;/div&gt;   When an element uses a display type of none, nothing will be painted to the screen. This includes the element itself, but also any of its children. This allows us to create UI or aspects of a page but not display them...yet. For example, we might want to reveal a dialog box, information message, image, or the like only in response to the user performing some action (e.g., clicking a button). Or, we might want to remove something like a loading screen when the web page is fully loaded:  &lt;style&gt; /* Place a semi-transparent box over the entire screen at startup */ #loading { position: fixed; /* position this element by specifying top, left, etc */ padding: 0; margin: 0; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.5); /* make it a bit see through */ z-index: 500; /* put this on top of other content */ } &lt;/style&gt; &lt;div id=&quot;loading&quot;&gt; &lt;p&gt;Loading...&lt;/p&gt; &lt;/div&gt; &lt;main&gt; &lt;!-- rest of page content here --&gt; &lt;/main&gt; &lt;script&gt; window.onload = function () { // Remove the spinner now that the page is loaded var loadingDiv = document.querySelector('#loading'); loadingDiv.style.display = 'none'; }; &lt;/script&gt;   If elements don't have a display type of none, they get included in the render tree and eventually painted to the screen. If we don't specify a display type, the default is inline for inline elements (like &lt;a&gt; and &lt;span&gt;) and block for block-level elements (like &lt;p&gt; and &lt;div&gt;).  With inline, boxes are laid out horizontally (typically left to right, unless we are doing rtl), starting at the top corner of the parent.  We can also specify that an element should be display: block;, which will layout blocks in a vertical way, using margin to determine the space between them. To understand the difference, try this using this snippet of code an HTML page, and change the display from block to inline:  &lt;style&gt; h1 { display: block; /* try changing to `inline` */ } &lt;/style&gt; &lt;h1&gt;One&lt;/h1&gt; &lt;h1&gt;Two&lt;/h1&gt; &lt;h1&gt;Three3&lt;/h1&gt;   We can also control the way that elements are laid out within an element (i.e., its children). Some of the display types for inside layout options include:  table - make elements behave as though they were part of a &lt;table&gt;flex - lays out the contents according to the flexbox modelgrid - lays out the contents according to the grid model  A great way to learn a bit about the latter two is to work through the following online CSS learning games:  Flexbox FroggyFlexbox DefenseGrid Garden  ","version":"Next","tagName":"h2"},{"title":"Common Layout Tasks​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#common-layout-tasks","content":" How do I centre inline text horizontally? p { text-align: center; } How do I centre a block element's contents? .center { width: 400px; /* set a fixed width */ margin: 0 auto; /* allow the browser to split the margin evenly */ } How do I centre something vertically? .vertical-center { display: table-cell; /* make the element work like a cell in a table */ vertical-align: middle; /* align to the centre vertically */ text-align: center; /* align to centre horizontally */ }   ","version":"Next","tagName":"h3"},{"title":"position Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#position-property","content":" Many web interface designs require more sophisticated element positioning than simply allowing everything to flow. Sometimes we need very precise control over where things end up, and how the page reacts to scrolling or movement.  To accomplish this kind of positioning we can use the CSS position propertyto override the defaults provided by the browser.  static - the default, where elements are positioned according to the normal flow of the documentrelative - elements are positioned according to the normal flow, but with extra offsets (top, bottom, left, right), allowing content to overlapabsolute - elements are positioned separate from normal flow, in their own &quot;layer&quot; relative to their ancestor element, and don't affect other elements. Useful for things like popups, dialog boxes, etc.fixed - elements are positioned separate from normal flow, and get positioned relative to the viewport.sticky - a hybrid of relative and fixed, allowing an element to be positioned relatively, but then &quot;stick&quot; when scrolling or resizing the viewport. This is often used for headings, which can be scrolled up, but then stay in place as you continue down into the document.  ","version":"Next","tagName":"h2"},{"title":"z-index Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#z-index-property","content":" In addition to controlling how elements are positioned in the X and Y planes, we can also stack elements on top of each other in different layers. We achieve this through the use of the z-index property.  The z-index is a value positive or negative integer, indicting which stack level the element should be placed within. The default stack level is 0, so using a z-index higher than 0 will place the content on top of anything below it.  The z-index is often used with position to place content in arbitrary positions overtop of other content. For example, a lightbox that appears over a site's content to show an image.  ","version":"Next","tagName":"h2"},{"title":"overflow Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#overflow-property","content":" When the contents on an element are too large to be displayed, we have options as to how the browser will display the overflowing content. To do this, we work with the overflow, overflow-x, overflow-y properties  visible - default. No scroll bars provided, content is not clipped.scroll - always include scroll bars, content is clipped and and scroll if requiredauto - only include scroll bars when necessary, content is clipped and and scroll if requiredhidden - content is clipped, no scroll bars provided.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingPrinciples/Box-Model-Layout/Box-Model#suggested-readings","content":" CSS Box ModelCSS LayoutLearn CSS Layout ","version":"Next","tagName":"h2"},{"title":"Objects in JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript","content":"","keywords":"","version":"Next"},{"title":"Accessing Elements in an Object​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#accessing-elements-in-an-object","content":" Object property names are Strings, and we can refer to them either via the dot operator .name, or using the bracket operator ['name'] (similar to indexing in an Array):  let person = { name: 'Tim Wu' }; // get the value of the `name` property using the . operator console.log(person.name); // get the value of the `name` property using the [] operator console.log(person['name']);   Why would you choose the dot operator over the bracket operator, or vice versa? The dot operator is probably more commonly used; however, the bracket operator is useful in a number of scenarios. First, if you need to use a reserved JavaScript keyword for your property key, you'll need to refer to it as a string (e.g., obj['for']). Second, it's sometimes useful to be able to pass a variable in order to lookup a property value for a name that will be different at runtime. For example, if you are using usernames as keys, you might do users[currentUsername], where currentUsername is a variable holding a String for the logged in user.  ","version":"Next","tagName":"h2"},{"title":"Destructuring Objects​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#destructuring-objects","content":" In the same way that we destructured Array values into new variables, we can also use the same technique with an Object. Recall that JavaScript allows us to Destructuring Assignment to unpack values in an Array or Object into distinct variables. Consider each of the following methods, both of which accomplish the same goal:  With an Array, we learned that you can destructure various elements into new variables:  // Co-ordinates for Seneca's Newnham Campus let position = [43.796, -79.3486]; let [lat, lng] = position;   The same can be done with an Object. Imagine a complex Object, with lots of properties, but we're only interested in a few of them:  let senecaNewnham = { address: '1750 Finch Ave. East', city: 'Toronto', province: 'Ontario', postalCode: 'M2J 2X5', phoneNumber: '416.491.5050', lat: 43.796, lng: -79.3486, }; // Destructure only the `lat` and `lng` properties let { lat, lng } = senecaNewnham;   This is a powerful technique for extracting data from an Object.  ","version":"Next","tagName":"h3"},{"title":"Modifying Object Properties​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#modifying-object-properties","content":" Object literals allow us to define an initial set of properties on an Object, but we aren't limited to that set. We can easily add new ones:  let data = {}; data.score = 17; data.level = 3; data.health = '***';   Here we define an empty Object, but then add new properties. Because we can add properties after an Object is created, we always have to deal with a property not existing. If we try to access a property that does not exist on an Object, there won't be an error. Instead, we will get backundefined for its value:  let currentScore = data.score; // `score` exists on `data`, and we get back the value `17` let inventory = data.inventory; // `inventory` does not exist on `data`, so we get back `undefined`   Because properties may or may not exist at runtime, it's important to always check for a value before trying to use it. We could rewrite the above to first check if data has an inventoryproperty:  if (data.inventory) { // `data` has a value for `inventory`, use data.inventory here... } else { // there is no `inventory` on `data`, do something else... }   Another common situation where you have to deal with this is working with deep structures. Consider an Object that defines the structure of a level in a video game. The level includes various rooms, some of which contain a monster:  let gameLevel = { name: 'Level 1', rooms: { // Each room has a unique ID R31343: { name: 'Front Hallway', }, R31344: { name: 'Kitchen', monster: { name: 'Bear', strength: 15, }, }, R31345: { name: 'Back Hallway', }, R31346: { name: 'Sitting Room', monster: { name: 'Dog', strength: 8, }, }, }, };   When working this code, we can access a particular room by its ID:  // Get a reference to the Kitchen let room = gameLevel.rooms.R31344;   However, we used an ID that doesn't exist, we'd get back undefined:  // Get a reference to the TV Room (no such room!) let room = gameLevel.rooms.R31347; // &lt;-- room is `undefined`   If we then try to access the monster in that room, our program will crash:  let room = gameLevel.rooms.R31347; // &lt;-- room is `undefined` console.log(room.monster); // &lt;-- crash! room is `undefined` so we can't access `monster within it   JavaScript provides a few ways to deal with this problem. Consider:  let room = gameLevel.rooms.R31347; // Version 1 if (room) { // only access room if it is truthy } // Version 2 if (room &amp;&amp; room.monster) { // only try to get .monster if room is truthy } // Version 3 if (room?.monster) { // same as 2, but using ?. syntax }   In the third version above we've used optional chaining via the ?. operator. This stops us from going any further in an object chain, when something is undefined.  ","version":"Next","tagName":"h2"},{"title":"Using Objects: dealing with optional parameters​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#using-objects-dealing-with-optional-parameters","content":" A very common pattern in JavaScript programs that uses this concept is optional argument passing to functions. Instead of using an unknown number of arguments for a function, we often use an options Object, which may contain values to be used in the function. Consider the case of starting a game and sometimes passing existing user data:  // Make sure `options` exists, and use an empty `Object` instead if it's missing. // If we don't do this, we'll get an error if we try to do `options.score`, since // we can't lookup the `score` property on `undefined`. function initGame(options = {}) { // If the user already has a score, use that, otherwise default to 0 let score = options.score || 0; // If the user is already on a level, use that, otherwise default to 1 let level = options.level || 1; // If the user has collected an items in her inventory, use that, otherwise an empty Array let inventory = options.inventory || []; // Begin the game, passing the values we have determined above playGame(score, level, inventory); } // Define our options: we have a score and level, but no inventory let options = { score: 25, level: 2, }; initGame(options);   In the code above, we have an options Object that defines some, but not all of the properties our initGame function might use. We wrote initGame using a single argument so that it was easier to call: we didn't need to worry about the order or number of arguments, and could instead just define an Object with all of the properties we had. The initGamefunction examined the options at runtime to see which properties existed, and which wereundefined and needed a default value instead. Recall that we can use the logical OR (||) operator to choose between two values at runtime.  It's also common to see people use destructuring here:  function processStudent(student) { let { name, studentId, username, email } = student; // Use values destructured from student object } processStudent({ name: 'Tim Wu', studentId: '10341346', username: 'timw', email: 'timw@myseneca.ca', });   The value of what we've done above is that passing many arguments to a function is easier when we can name them as properties on an Object instead of having to pass them positionally as arguments.  ","version":"Next","tagName":"h2"},{"title":"Updating, Clearing, and Removing properties​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#updating-clearing-and-removing-properties","content":" We've seen that properties can be defined when declared as part of a literal and added later via the . or [] operators. We can also update or remove values after they are created:  let o = {}; // Add a name property o.name = 'Tim Wu'; // Update the name property to a new value, removing the old one. o.name = 'Mr. Timothy Wu';   An Object's property keys are unique, and setting a value for o.name more than once doesn't add more properties--it overwrites the value already stored in the existing property. We can also clear (remove the value but not the key) or delete (remove the entire property from the object, key and value) things from an Object.  let o = {}; // Add a `height` property o.height = '35 inches'; // Add an owner ID property o.owner = '012341341'; // Clear the value of `height`. We leave the `height` key, but get rid of the '35 inches' value o.height = null; // Completely remove the owner property from the object (both the key and its value) delete o.owner;   Why would you choose to assign null vs. use delete? Often we want to get rid of a key's value, but will use the key again in the future (e.g., add a new value). In such cases we just null the value by assigning the key a value of null. If we know that we'll never use this key again, and we don't want to retain it on the Object, we can instead completely remove the property (key and value) with delete. You'll see both used. For the most part, setting a key's value to null is probably what you want.  ","version":"Next","tagName":"h2"},{"title":"Using Objects: creating sets to track arbitrary lists​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#using-objects-creating-sets-to-track-arbitrary-lists","content":" Another common use of Objects, and their unique property keys, is to keep track of a sets, for example to count or keep track of an unknown number of items. Consider the following program, which tracks how many times each character appears within a String. The code uses the [] operator to allow for the keys to be created and accessed via a variable (char). Without an Object we would have to hard-code variables for each separate letter.  // An empty `Object`, which we'll populate with keys (letters) and values (counts) let characterCounts = {}; let sentence = 'The quick brown fox jumped over the lazy dog.'; let char; let count; // Loop through all characters in sentence for (let char of sentence) { // Get the current count for this character, or use 0 if we haven't seen it before count = characterCounts[char] || 0; // Increase the count by 1, and store it in our object characterCounts[char] = count + 1; } console.log(characterCounts); /* Our characterCounts Object now looks like this, and there were 8 spaces, 2 'h's, etc: { T: 1, h: 2, e: 4, ' ': 8, q: 1, u: 2, i: 1, c: 1, k: 1, b: 1, r: 2, o: 4, w: 1, n: 1, f: 1, x: 1, j: 1, m: 1, p: 1, d: 2, v: 1, t: 1, l: 1, a: 1, z: 1, y: 1, g: 1, '.': 1 } */   ","version":"Next","tagName":"h2"},{"title":"Complex Property Types: Object, Function​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#complex-property-types-object-function","content":" We said earlier that Object properties can be any valid JavaScript type. That includesNumber, String, Boolean, etc., also Object and Function. A property may define a complex Object of its own:  let part = { id: 5, info: { name: 'inner gasket', shelf: 56713, ref: [5618, 5693], }, };   Here we define a part, which has an id (part.id) as well as a complex property named info, which is itself an Object. We access properties deep in an Object the same way as a simple property, for example: part.info.ref.length means: get the length of the ref array on theinfo property of the part Object. An Object's properties can be Objects many levels deep, and we use the . or [] operators to access these child properties.  An Object property can also be a function. We call these functions methods. A method has access to other properties on the Object via the this keyword, which refers to the currentObject instance itself. Let's add a toString() method to our part Object above:  let part = { id: 5, info: { name: 'inner gasket', shelf: 56713, ref: [5618, 5693], }, toString: function () { return `${this.info.name} (#${this.id})`; }, }; console.log(part.toString()); // prints &quot;inner gasket (#5)&quot; to the console.   The toString property is just like any other key we've added previously, except its value is an anonymous function. Just as we previously bound function expressions to variables, here a function expression is bound to an Object's property. When we write part.toString we are accessing the function stored at this key, and by adding the () operator, we can invoke it:part.toString() says get the function stored at part.toString and call it. Our function accesses other properties on the part Object by using this.* instead of part.*. When the function is run, this will be the same as part (i.e., a reference to this Object instance).  The this keyword in JavaScript is used in different contexts, and has a different meaning depending on where and how it is used. We will return to this and its various meanings throughout the course.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#suggested-readings","content":" Object-oriented JavaScript for beginnersExploringJS, Chapter 17. Objects and InheritanceExploringJS, Chapter 20. DatesExploringJS, Chapter 21. Math ","version":"Next","tagName":"h2"},{"title":"HTML5 Form Validation","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation","content":"","keywords":"","version":"Next"},{"title":"Client Side Form Validation​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#client-side-form-validation","content":" When a user submits a form, we generally want to send the form's data to a server. We use the form's action to specify a server URL, and a method to indicate the HTTP request type to use when sending the data.  Before we can use this data in a meaningful way, we need to validate it. It's easy for users to make typos, enter the right information but in the wrong field, or use a format we aren't expecting. We need to be able to parse and understand the data using code. This means having data that follows some rules.  In order to be able to work with user data, we have to provide some mechanisms for enforcing these rules, and give users hints, guides, and safety checks as they are entering data and submitting forms.  We have two opportunities to validate form data:  Client-Side: before we submit the form to the server, we validate it in the browser using HTML5 and JavaScript.Server-Side: after the data is submitted, the server must re-validate it.  We will be focusing on client-side validation in this course.  You might be wondering why we bother validating form data twice, if we're just going to re-validate it no matter what on the server. There are a number of reasons:  Save bandwidth: don't send data over the network if it's incomplete or not in the correct formImmediate feedback: users don't have to wait for their data to travel all the way to the server, and the page to reload, before getting feedback that they need to correct something simple.Contextual feedback: prompt users to correct mistakes as they are entering the data vs. at the end, after they've moved on from entering some piece of information (e.g. a credit card).  ","version":"Next","tagName":"h2"},{"title":"HTML5 Validation Features​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#html5-validation-features","content":" We've already discussed a number of important &lt;input&gt; types that allow us to tell the browser about the type of data we expect, for example &lt;input type=&quot;tel&quot;&gt; for telephone numbers or &lt;input type=&quot;email&quot;&gt;for email addresses.  Each of these special purpose &lt;input&gt; types comes with its own set of built-in data validation:  ","version":"Next","tagName":"h2"},{"title":"Email Address​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#email-address","content":" &lt;input type=&quot;email&quot;&gt;  An email address must not be an empty string, and must be a valid (i.e., text is in valid email format vs. email address actually exists). If you include the multiple attribute, the control will allow a list of addresses, and validate each one.  ","version":"Next","tagName":"h3"},{"title":"Telephone Number​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#telephone-number","content":" &lt;input type=&quot;tel&quot;&gt;  Phone numbers are very difficult to validate, because they differ so much around the world. You might think you could just check for something like 555-555-5555, but this would miss things like country codes, number patterns that use a different number of digits, short-codes for texting, 1-800 style numbers, etc.  As a result, there is no default validation applied to a tel type input.  ","version":"Next","tagName":"h3"},{"title":"URL​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#url","content":" &lt;input type=&quot;url&quot;&gt;  Unlike telephone numbers, URLs can be validated. If you use a url type input, the browser will make sure it is not empty, and that the value is a valid URL.  ","version":"Next","tagName":"h3"},{"title":"Dates and Times​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#dates-and-times","content":" &lt;input type=&quot;date&quot;&gt;, &lt;input type=&quot;time&quot;&gt;, &lt;input type=&quot;week&quot;&gt;, &lt;input type=&quot;month&quot;&gt;, &lt;input type=&quot;date-local&quot;&gt;  Dates and times are not validated by the browser. However, the user will usually be prompted to &quot;pick&quot; a date/time value visually instead of entering one as text. You can also further restrict the date/time by adding a min=&quot;...&quot; or max=&quot;...&quot; to the input, which specifies a date/time to use as a lower or upper range when validating.  ","version":"Next","tagName":"h3"},{"title":"Colour​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#colour","content":" &lt;input type=&quot;color&quot;&gt;  A color's value is considered to be invalid if it can't be converted (by the browser) into a seven-character lower-case hexadecimal value (e.g., #000000).  ","version":"Next","tagName":"h3"},{"title":"Number​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#number","content":" &lt;input type=&quot;number&quot;&gt;, &lt;input type=&quot;range&quot;&gt;  A number must be a valid number, or the browser won't allow it. You can also further restrict the number's value by adding a min=&quot;...&quot; or max=&quot;...&quot; to the input, which specifies a lower or upper range when validating.  ","version":"Next","tagName":"h3"},{"title":"Using Attributes to Prevent Invalid Data​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#using-attributes-to-prevent-invalid-data","content":" Beyond choosing trying to choose the most appropriate &lt;input&gt; type for your data, another layer of client-side validation comes from using attributes to indicate to both the user and browser what we expect to be entered.  ","version":"Next","tagName":"h2"},{"title":"placeholder and title​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#placeholder-and-title","content":" We've discussed placeholder previously as part of our forms and CSS discussion. It's important to highlight it once again since it also plays an important role in helping the user understand how to enter data properly.  Together with &lt;label&gt;s and the title attribute (shown when you hover over an element in a tooltip), these extra bits of text provide important clues and instructions about how to use a given input control.  For example, if we are expecting the user to enter a list of email addresses, we could do the following:  &lt;label for=&quot;address-list&quot;&gt;Email Address List&lt;/label&gt; &lt;input id=&quot;address-list&quot; type=&quot;email&quot; multiple placeholder=&quot;name1@example.com, name2@example.com, ...&quot; title=&quot;List of email addresses, separated by commas&quot; /&gt;   ","version":"Next","tagName":"h3"},{"title":"disabled​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#disabled","content":" The disabled attributeis a boolean (i.e., it is present or not present) that indicates that a field cannot be interacted with by the user. In the browser it will show up with a dimmer colour, and clicking it will have no effect.  We can use disabled to turn off certain controls in a form that don't currently apply. Sometimes a form will have options with dependencies on other controls. For example, booking a flight that is one-way vs. two-way and whether or not you need a second date entered for the return trip.  &lt;form action=&quot;/s&quot; name=&quot;login&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;flight&quot; /&gt; &lt;input type=&quot;date&quot; name=&quot;date1&quot; /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;return-flight&quot; /&gt; &lt;input type=&quot;date&quot; value=&quot;date2&quot; disabled /&gt; &lt;/form&gt;   Using disabled allows us to include and display optional input options in a form without polluting the data by accidentally allowing the user to enter information that isn't appropriate.  ","version":"Next","tagName":"h3"},{"title":"required​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#required","content":" The required attribute is a boolean (i.e., it is present or not present) that indicates that a field must have a value before the user can submit the form. The browser will block attempts to submit until a value has been entered.  &lt;form action=&quot;/s&quot; name=&quot;login&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; required /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; required /&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot; /&gt; &lt;/form&gt;   In the form above, both the username and password fields are required, and must have a value before the form can be submitted (i..e, by clicking the Login button). Notice that the submit control does not have required attribute.  When a field has the required attribute, the browser automatically applies the :requiredpseudo-class. On the other hand, any field without the required attribute automatically gets the :optional pseudo-class applied. This can be useful in CSS styling.  input:required { /* styles for required input controls */ } input:optional { /* styles for optional input controls */ }   ","version":"Next","tagName":"h3"},{"title":"pattern​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#pattern","content":" The pattern attributeallows us to include a regular expression for the browser to use when validating the value entered by a user for a given input control.  For example, imagine if we need the user to enter a file extension and want to support data of the following form .exe, .EXE, or exe.:  &lt;input name=&quot;file-extension&quot; type=&quot;text&quot; placeholder=&quot;.exe&quot; pattern=&quot;\\.?[a-zA-Z]{3}&quot; /&gt;   Consider how you might write a regular expression for each of the following:  social security number (###-##-####)phone number (555-555-5555 or 555-5555 or (555) 555-555)ip address (127.0.0.1 or 255.255.255.255)username (alpha, numbers underscore, dash, 8-16 long)password (alpha, number, symbols, underscore, dash, up to 256 long)postal code (m5w 1e6 or M5W 1E6 or M5W1E6)price ($1.50 or 1.50 or 1)seneca course code (ABC123SSA)  ","version":"Next","tagName":"h3"},{"title":"Suggested Readings​","type":1,"pageTitle":"HTML5 Form Validation","url":"/WebProgrammingPrinciples/Client-side-Validation/HTML5-Form-Validation#suggested-readings","content":" HTML Form ValidationStatic Site Hosting ","version":"Next","tagName":"h2"},{"title":"Using JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Client-side-Validation/Using-JavaScript","content":"","keywords":"","version":"Next"},{"title":"JavaScript and Client-Side Validation​","type":1,"pageTitle":"Using JavaScript","url":"/WebProgrammingPrinciples/Client-side-Validation/Using-JavaScript#javascript-and-client-side-validation","content":" All of the methods above are examples of static checks (i.e., they don't change) that we're adding to our form controls. They do a lot to help guard against invalid data; however, there are times that we need more flexible control over what happens.  In order to add dynamic checks (i.e., can be changed at runtime) we need to layer in use of JavaScript. By using JavaScript we have more freedom to create custom and complex validation rules beyond the set of static options provided by HTML and the browser. We can also use JavaScript in combination with CSS to provide a better user experience:  display more meaningful, context-aware error messagesshow/hide error messages depending on the location of the cursor and where the user is focusedplace errors (or other information) anywhere in the DOM vs. being limited to labels, placeholder or tooltip text  ","version":"Next","tagName":"h2"},{"title":"Accessing Form Fields​","type":1,"pageTitle":"Using JavaScript","url":"/WebProgrammingPrinciples/Client-side-Validation/Using-JavaScript#accessing-form-fields","content":" When writing JavaScript to validate form fields, there are a number of ways to access the input controls and get their values. Consider the following form:  &lt;form id=&quot;info-form&quot; name=&quot;info&quot; action=&quot;/i&quot;&gt; &lt;input id=&quot;first-name&quot; name=&quot;fname&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;number-list&quot; name=&quot;number-list&quot; type=&quot;text&quot; /&gt; &lt;/form&gt;   Here are some of different ways we could access this form:  // 1. Using its id and getElementById() var form = document.getElementById('info-form'); // 2. Using its id and querySelector() var form = document.querySelector('#info-form'); // 3. Using document.forms and the id or name of the form var form = document.forms['info-form'];   Once we have a reference to the &lt;form&gt; element in JavaScript, we can use thename of the form controls to get access to the individual fields and there .value:  // Notice that we must wrap values with '-' in their names in [&quot;...&quot;] to access them. var form = document.forms['info-form']; var fname = form.fname.value; var numberList = form['number-list'].value;   ","version":"Next","tagName":"h3"},{"title":"Special Cases for Obtaining Form Values​","type":1,"pageTitle":"Using JavaScript","url":"/WebProgrammingPrinciples/Client-side-Validation/Using-JavaScript#special-cases-for-obtaining-form-values","content":" Some form controls need different approaches when you want to access their value in JavaScript:  &lt;textarea&gt;: use the .value property to access the text.&lt;input type=&quot;radio&quot;&gt;: use the name property (i.e., all radio buttons will use the same name in a group) to iterate over all possible radio controls, and then look at the .checked property, which will be true for the one checked.&lt;input type=&quot;checkbox&quot;&gt;: use the name property to iterate over all possible radio controls, and then look at the .checked property, which will be true for the one checked.&lt;select&gt;: use the selectedIndex to determine which &lt;option&gt; index was selected (if any). A value of -1 means none are currently selected; a value greater than -1 indicates the index to use when accessing the options[n] array for the chosen option. If the &lt;select&gt; is defined to allow for multiple options, you can loop through the options and inspect the .selected property to determine if it's true.  Consider the following form:  &lt;form id=&quot;info-form&quot; name=&quot;info&quot; action=&quot;/i&quot;&gt; &lt;label for=&quot;text&quot;&gt;Enter some text&lt;/label&gt; &lt;textarea id=&quot;text&quot; name=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;fieldset&gt; &lt;legend&gt;Pick a Colour&lt;/legend&gt; &lt;label for=&quot;colour-red&quot;&gt;Red&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;colour&quot; id=&quot;colour-red&quot; value=&quot;red&quot; checked /&gt; &lt;label for=&quot;colour-green&quot;&gt;Green&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;colour&quot; id=&quot;colour-green&quot; value=&quot;green&quot; /&gt; &lt;label for=&quot;colour-blue&quot;&gt;Red&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;colour&quot; id=&quot;colour-blue&quot; value=&quot;blue&quot; /&gt; &lt;/fieldset&gt; &lt;label for=&quot;agree-disagree&quot;&gt;I agree with the terms and conditions.&lt;/label&gt; &lt;input type=&quot;checkbox&quot; name=&quot;agree&quot; id=&quot;agree-disagree&quot; /&gt; &lt;label for=&quot;food&quot;&gt;Favourite Food&lt;/label&gt; &lt;select id=&quot;food&quot; name=&quot;food&quot;&gt; &lt;option value=&quot;pizza&quot;&gt;Pizza&lt;/option&gt; &lt;option value=&quot;tacos&quot;&gt;Tacos&lt;/option&gt; &lt;option value=&quot;salad&quot;&gt;Salad&lt;/option&gt; &lt;option value=&quot;other&quot;&gt;Other&lt;/option&gt; &lt;/select&gt; &lt;/form&gt;   In order to access the form's values in code, we could do the following:  var form = document.querySelector('#info-form'); // Get the value form the &lt;textarea&gt; var text = form.text.value.trim(); // Get the chosen colour value from the radio button group var colour; var colourChoices = Array.from(form.colour); // convert to array colourChoices.forEach(function (option) { if (option.checked) { colour = option.value; } }); // Get the chosen food value form the &lt;select&gt; var food = 'None'; // there may be nothing selected var foodChoices = Array.from(form.food); // convert to array foodChoices.forEach(function (option) { if (option.selected) { food = option.value; } });   ","version":"Next","tagName":"h3"},{"title":"Using the submit Event to Validate Forms with JavaScript​","type":1,"pageTitle":"Using JavaScript","url":"/WebProgrammingPrinciples/Client-side-Validation/Using-JavaScript#using-the-submit-event-to-validate-forms-with-javascript","content":" There are a wide variety of custom validation tests we can write via JavaScript:  Check for the presence or absence of a fieldCheck the value of a field, and determine if it's within an expected range, of a specific type, etc.Confirm that some value is &quot;real&quot; vs. matching an expected format. (e.g., does a user id exist?)Evaluate a group of input values together as a group. Do they make sense together?  An HTML &lt;form&gt; element exposes the submit event (and onsubmit event property), which we can use to add custom JavaScript code to handle the case that the user is trying to submit a form:  &lt;form id=&quot;info-form&quot; name=&quot;info&quot; action=&quot;/i&quot;&gt;...&lt;/form&gt; &lt;script&gt; var infoForm = document.getElementById('info-form'); // submit event fired when the user clicks &quot;submit&quot; button infoForm.onsubmit = function () { // Perform extra validation here. When finished validating, return // either `true` (form is valid) or `false` (form is invalid) to tell // the browser how to proceed. }; // reset event fired when the user clicks a &quot;reset&quot; button infoForm.onreset = function () { // If you ever need to do extra work to clear a form, do it here. }; &lt;/script&gt;   Consider the example of a form that asks the user to enter a list of 2-4 numbers. We'd like to allow the user as much freedom to enter this list as possible, and support any style of entry:  &lt;div id=&quot;error-msg&quot; class=&quot;error hidden&quot;&gt;&lt;/div&gt; &lt;form id=&quot;info-form&quot; name=&quot;info&quot; action=&quot;/i&quot;&gt; &lt;label for=&quot;number-list&quot;&gt;Number list&lt;/label&gt; &lt;input id=&quot;number-list&quot; name=&quot;list&quot; type=&quot;text&quot; /&gt; &lt;/form&gt; &lt;script&gt; var infoForm = document.getElementById('info-form'); infoForm.onsubmit = function () { // Check if number list is valid, and return true if it is if (validateNumberList()) { // Hide the error message if it was displayed previously hideErrorMessage(); return true; } // Number list is invalid, so display error message and return false showErrorMessage('Number list is invalid: expected 2 to 4 numbers in a list.'); return false; }; function showErrorMessage(msg) { var errMessage = document.querySelector('#error-msg'); // Remove the hidden class so the error message shows. errMessage.classList.remove('hidden'); // Set the error message text errMessage.innerHTML = msg; } function hideErrorMessage(msg) { var errMessage = document.querySelector('#error-msg'); // Add the hidden class so the error message goes away. errMessage.classList.add('hidden'); } function getNumberList() { // Get the number-list &lt;input&gt; value var list = document.querySelector('#number-list').value; // Get rid of leading/trailing spaces list = list.trim(); // Split the string into an array, separated by spaces, commas, or a combo of each return list.split(/[ ,]+/); } function validateNumberList() { var list = getNumberList(); // Make sure we have between 2 and 4 elements. If not, return `false` // to indicate this form is invalid (don't submit) if (!(list.length &gt;= 2 &amp;&amp; list.length &lt;= 4)) { return false; } // Make sure each element in the list is a number function isNumber(n) { return !isNaN(n); } // Loop across every value in the array, and call isNumber() on the value. // Return true if EVERY element passes isNumber, and false otherwise. return list.every(isNumber); } &lt;/script&gt;  ","version":"Next","tagName":"h3"},{"title":"Introduction to CSS & Syntax","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax","content":"","keywords":"","version":"Next"},{"title":"CSS Syntax​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#css-syntax","content":" CSS syntax is made up of rules, which are broken into two parts:  a selector, specifying the element(s) that should have the rules appliedone or more declarations, which are key/value pairs surrounded by {...} braces  h1 { color: blue; font-size: 12px; }   In this example, the selector is h1, which indicates that we want the following rules to be applied to level-1 heading elements (i.e., all &lt;h1&gt;&lt;/h1&gt; elements in the document). Next comes a list of two definitions, each ending with a ;. These declarations follow the usual key/value syntax, with a property name coming before the :, and a valuecoming after:  color: blue; says we want to use the colour (note the spelling) bluefont-size: 12px; says we want the font to be 12px.  Here's another example:  p { color: red; text-align: center; text-decoration: underline; }   This indicates we want all &lt;p&gt;&lt;/p&gt; elements in the document to have red, centered, underlined text.  ","version":"Next","tagName":"h2"},{"title":"Where to Put CSS​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#where-to-put-css","content":" CSS can come from a number of sources in an HTML page:  InlineInternal EmbeddedExternal File(s)The browser itself (e.g., default styles, or extra styles injected by a browser extension)  Browsers apply styles to elements using a priority order that matches the list above. If more than one style rule is specified for an element, the browser will prefer whatever is defined in Inline styles over Internal Embedded, Internal Embedded over External files, etc.  ","version":"Next","tagName":"h2"},{"title":"Inline Example​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#inline-example","content":" CSS rules can be placed directly on an element via the style attribute:  &lt;div style=&quot;background-color: green&quot;&gt;...&lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Internal Embedded​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#internal-embedded","content":" If we want to apply the same CSS rules to more than one element, it makes more sense tonot duplicate them on every element's style attribute. One solution is to use an internal embedded&lt;style&gt; element in the &lt;head&gt; or &lt;body&gt;, similar to how embedded &lt;script&gt; elements work:  &lt;style&gt; p { color: red; } div { background-color: blue; text-align: center; } &lt;/style&gt;   ","version":"Next","tagName":"h3"},{"title":"External File(s)​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#external-files","content":" Putting large amounts of CSS in &lt;style&gt; elements makes our HTML harder to read and maintain (CSS is about separating style from structure), and also causes our page to perform worse in terms of load times (i.e., the styles can't be cached by the browser). To overcome this, we often include external .css files via the &lt;link&gt;element within the document's &lt;head&gt;:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;/html&gt;   We can include many stylesheets in this way (i.e., everything doesn't have to go in one file), and we can include .css files on the same origin, or a remote origin:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;/html&gt;   In the example above, the page uses the popular Bootstrap CSS styles along with some locally (i.e., local to the web server) styles in styles.css.  A .css file included in this way can also @importto have even more .css files get loaded at runtime:  /* Import Font Awesome */ @import url(https://use.fontawesome.com/releases/v5.4.2/css/all.css);   In this example, the popular Font Awesome CSS library for font icons has been imported via a .css file.  ","version":"Next","tagName":"h3"},{"title":"CSS Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#css-selectors","content":" We've already learned a few CSS Selectors when we discussed querySelector() andquerySelectorAll(). The word Selector refers to the fact that these methods take a CSS Selector and return DOM elements that match. For example:  document.querySelector('#output') would return the element with attribute id=&quot;output&quot;document.querySelectorAll('.logo') would return all elements with a class of logodocument.querySelectorAll('img') would return all &lt;img&gt; elements  These same selectors, and many more, can also be used in our CSS rulesets.  ","version":"Next","tagName":"h2"},{"title":"Tag/Type Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#tagtype-selectors","content":" The name of an HTML element can be used to specify the styles associated with all elements of the given type. For example, to indent all &lt;p&gt; text in our document, we could do this:  p { text-indent: 20px; }   ","version":"Next","tagName":"h3"},{"title":"Class Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#class-selectors","content":" Often we want to apply styles to some but not all elements of a certain kind. Perhaps we only want some of our page's &lt;p&gt; elements to have a particular look. To achieve this, we define a class, and then put that class on the elements that require it:  &lt;style&gt; .demo { text-decoration: underline red; } &lt;/style&gt; &lt;p&gt;This is a paragraph that won't get the styles below applied to it (doesn't include the class)&lt;/p&gt; &lt;p class=&quot;demo&quot;&gt;This paragraph will get the styling applied.&lt;/p&gt; &lt;p class=&quot;demo&quot;&gt;And so will this one.&lt;/p&gt;   A class can be applied to elements that aren't of the same type:  &lt;style&gt; .invisible { display: none; } &lt;/style&gt; &lt;h1 class=&quot;invisible&quot;&gt;Title&lt;/p&gt; &lt;p class=&quot;invisible&quot;&gt;This is a paragraph.&lt;/p&gt;   I this example, both the &lt;h1&gt; element, and the &lt;p&gt; element will have the display: none style applied, hiding them so they don't appear in the page.  If we want to be more specific, and only apply styles to elements of a given type which also have a given class, we can do this:  &lt;style&gt; p.note { font-weight: bold; } &lt;/style&gt; &lt;p class=&quot;note&quot;&gt;This is a paragraph that also uses the note class.&lt;/p&gt; &lt;div class=&quot;note&quot;&gt; This div uses the note class too, but because we said p.note, no styles are used. &lt;/div&gt;   An element can also have multiple classes applied, each one adding different styling:  &lt;style&gt; .invisible { display: none; } .example { color: green; background-color: red; } &lt;/style&gt; &lt;p class=&quot;invisible example&quot;&gt;This is a paragraph that uses two classes at once.&lt;/p&gt;   ","version":"Next","tagName":"h3"},{"title":"ID Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#id-selectors","content":" In many cases, we have only a single element that should use styles. Using a type or class selector would be overly broad, and so we tend to use an id instead. Recall that only one HTML element in a document can have a given id attribute: it must be unique.  &lt;style&gt; #summary { background-color: skyblue; } &lt;/style&gt; &lt;div id=&quot;summary&quot;&gt;&lt;/div&gt;   When we use the id as a selector, we prefix it with the # symbol. Notice that the HTML does not use the # symbol though.  ","version":"Next","tagName":"h3"},{"title":"Contextual Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#contextual-selectors","content":" Another common way to write selectors is to use the position of elements in the DOM. The context selector indicates the context, or placement/nesting (i.e., determined by the parent node) of the element.  For example, if we want to apply styles to &lt;p&gt; elements that are children of &lt;div&gt;elements, we could do this:  &lt;style&gt; div p { font-size: 16px; } &lt;/style&gt; &lt;p&gt;This paragraph will not receive the styling&lt;/p&gt; &lt;div&gt; &lt;p&gt;This paragraph will receive the styling.&lt;/p&gt; &lt;p&gt;This paragraph will receive the styling also.&lt;/p&gt; &lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Grouping Selectors​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#grouping-selectors","content":" As our CSS grows, it's common that we'll notice that we're repeating the same things multiple times. Instead of doing this, we can group a number of selectors together into a comma-separated list:  html, body { height: 100%; } h1, h2, h3, h4, h5, h6 { font-family: Serif; color: blue; }   Here we've used grouping twice to cut-down on the number of times we have to repeat things. In the first case, we defined a height of 100% (full height of the window) for the &lt;html&gt;and &lt;body&gt; elements (they don't have a height by default, and will only be as tall as the content within them). We've also declared some font and color information for all the headings we want to use.  ","version":"Next","tagName":"h3"},{"title":"Suggested Readings​","type":1,"pageTitle":"Introduction to CSS & Syntax","url":"/WebProgrammingPrinciples/CSS-Styling/Introduction-CSS-Syntax#suggested-readings","content":" Introduction to CSSLearning to Style HTML using CSSCSS: Cascading Style Sheets on MDN ","version":"Next","tagName":"h2"},{"title":"Applied CSS","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS","content":"","keywords":"","version":"Next"},{"title":"Containers for Styling​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#containers-for-styling","content":" We've discussed &lt;div&gt; and &lt;span&gt; in the past, but their purpose may not have been clear. Why bother wrapping other elements in &lt;div&gt;...&lt;/div&gt; or &lt;span&gt;...&lt;/span&gt; when they don't display any different?  With CSS we can now start to take advantage of what they provide. If we think of them as containers which can be used to group styling, their purpose will become more clear.  A &lt;div&gt; is a block level element, and &lt;span&gt; an inline element. Depending on how we want to group and apply styling, we can use one or both. Consider the following:  &lt;style&gt; .info-box { border: solid green; } .info-box p { font-family: Serif; } .info-box span { font-weight: bold; } .info-box img { width: 75px; height: 75px; } &lt;/style&gt; &lt;p&gt;This paragraph won't have any special style applied. Neither will this &lt;span&gt;span&lt;/span&gt;.&lt;/p&gt; &lt;div class=&quot;info-box&quot;&gt; &lt;p&gt;&lt;span&gt;Name:&lt;/span&gt; Thomas Lee&lt;/p&gt; &lt;p&gt;&lt;span&gt;Age:&lt;/span&gt; 23&lt;/p&gt; &lt;img src=&quot;tlee.jpg&quot; /&gt; &lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"CSS Units​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#css-units","content":" Many CSS values require units to be specified, for example, font sizes, widths, heights, etc. At first you might think that we should specify things in pixels; however, browsers need to work on such a wide variety of hardware and render to so many different displays (watches to billboards), we need more options. It's also important to be able to specify sizes using relative units vs. fixed, for layouts that need to adapt to changing conditions and still retain the correct proportions.  There is one exception, and that is for 0 (i.e., zero), which never needs a unit (i.e., 0px is the same as 0%, etc).  The most common units we use in CSS are:  1em = 12pt = 16px = 100%   Let's look at each of these in turn:  em (the width of the capital letter M) - a scalable unit that is used in web media, and is equal to the current font-size. If the font-size is 12pt, 1em is the same as 12pt. If the font-size is changed, 1em changes to match. We can also use multiples: 2em is twice the font-size, and .5em is half. Using em for sizes is popular on the web, since things have to scale on mobile vs. desktop (i.e., fixed unit sizes don't work as the screen shrinks/expands).pt - a fixed-size Point unit that comes from print media, where 1pt equals 1/72 of an inch.px - pixels are fixed size units for web media (screens), and 1px is equal to one dot on a computer display. We use px on the web when we need &quot;pixel perfect&quot; sizing (e.g., image sizes).% - the percent unit is similar to em in that it scales with the size of the display. 100% is the same as the current font-size.vw, vh - the viewport width and height units are percentages of the visible space in the viewport (the part of the page you can see, the window's width and height). 1vw is the same as 1% of the width of the viewport, and 80vh is the same as 80% of the visible height.  You will also sometimes encounter other ways of measurement that use full words: xx-small, x-small, small, medium, large, x-large, xx-large, smaller, larger, thin, medium, thick  Here's an example that uses a number of the units mentioned above:  &lt;style&gt; html, body { height: 100vh; } .box { margin: 10px; font-size: 2em; height: 150px; border: medium solid black; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"CSS Colours (color)​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#css-colours-color","content":" CSS allows us to define colour values for many declarations. We do so by specifying a colour using one of the following notations:  Hexadecimal Red, Green, Blue: written using 3 double-digit hex numbers, and starting with a # sign. Each of the 3 pairs represents a value between 0 and 255 for Red, Green, and Blue: #000000 is pure Black and #ffffff is pure White, and #ffd700 is Gold.RGB or RGBA notation: here the red, green, blue, and sometimes alpha (i.e., opacity) are defined in decimal notation: #ffffff is the same as rgb(255, 255, 255) and #ffd700 is the same as rgb(255, 215, 0). If we want to define how see-through the colour is (by default you can't see through a colour), we add an alpha value: rgba(0, 191, 0, 0.5) means that the colour will be 50% see through.Named colours: some colours are so common that they have their own name defined in the CSS standard. For example: white, black, green, red, but also chocolate, darkorange, peru, etc.  The easiest way to understand this is using a Colour Picker tool, which lets you visually see the difference in changing values.  ","version":"Next","tagName":"h2"},{"title":"CSS Properties and Values​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#css-properties-and-values","content":" A property is assigned to a selector in order to manipulate its style. The CSS properties are defined as part of the CSS standard. When you want to know how one of them works, or which values you can assign, you can look at the documentation on MDN. For example:  text-indentcolorbackground-colorborder  There are hundreds of properties we can tweak as web developers, and it's a good idea to explore what's available, and to look at how other web sites use them via the developer tools.  A property can have one or more values. A the possible values a property can have also comes from the standard. For example:  p { text-decoration: underline; } .spelling-error { text-decoration: red wavy underline; }   The text-decoration property is defined to take one of a number of values, each of which is also defined in the standard.  ","version":"Next","tagName":"h2"},{"title":"Exploring CSS Properties and Values in the Dev Tools​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#exploring-css-properties-and-values-in-the-dev-tools","content":" By far the best way to learn about CSS is to look at how other sites use it. When you find something on the web that you think looks interesting, open your browser's dev tools and inspect the CSS Styles:    You can look at the specific properties specified for an element, or see all the computed styles (i.e., everything, including all default values). You can also try toggling these on and off, or double-click the values to enter your own.  ","version":"Next","tagName":"h2"},{"title":"CSS text Properties​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#css-text-properties","content":" There are dozens of properties that affect how text is rendered. These include things like the color, spacing, margins, font characteristics, etc.  h2 { color: red; text-align: center; text-decoration: underline; text-transform: uppercase; } p { color: #0000ff; text-indent: 100px; }   ","version":"Next","tagName":"h2"},{"title":"font Properties​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#font-properties","content":" We can use the font-family property to specify a font, or list of fonts, for the browser to apply to an element. The font must be available on the user's computer, otherwise the next font in the list will be tried until one is found that is installed, or a default font will be used.  In general it is safe to assume that the following fonts are available:  Helvetica, Arial, Verdana, sans-serif - sans-serif fonts&quot;Courier New&quot;, Courier, monospace - monospace fontsGeorgia, &quot;Times New Roman&quot;, Times, serif - serif fonts  You can see a list of the fonts, and OS support here.  h3 { font-family: Arial; } h4 { font-family: 'Times New Roman', Times, serif; } h5 { font-size: 18pt; font-style: italic; font-weight: 500; }   ","version":"Next","tagName":"h3"},{"title":"Web Fonts - @font-face​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#web-fonts---font-face","content":" Modern browsers also allow custom fonts to be included as external files, and downloaded as needed by the web site. This is often the preferred method for designers, who don't want to be limited to the set of fonts available on all operating systems.  A font is a file that describes the curves and lines needed to generate characters at different scales. There are various formats, from OTF (OpenType Format) toTTF (TrueType Format) to WOFF (Web Open Font Format), etc. In order for the browser to use a new font, it has to be downloadable via one or more URLs. We then tell the browser which font files to download in our CSS via the@font-face property:  @font-face { font-family: &quot;FontName&quot; src: url(font.woff2) format('woff2'), url(font.ttf) format('truetype'); } body { font-family: &quot;FontName&quot;; }   Many fonts have to be purchased, but there are some good sources of high quality, freely available fonts for your sites:  Font Squirreldafont.comGoogle Fonts  For example, we can use the popular &quot;Lobster&quot; font from Google by doing the following in our CSS:  @import url(https://fonts.googleapis.com/css?family=Lobster) p { font-family: 'Lobster'; }   ","version":"Next","tagName":"h3"},{"title":"font-size property​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#font-size-property","content":" Using the font-size property, font sizes can be given in fixed or relative units, depending on how we want our text to scale on different devices:  h1 { font-size: 250%; /* scaled to 250% of regular font size */ } p { font-size: 20pt; /* size in points -- 20/72 of an inch */ } .quote { font-size: smaller; /* smaller than normal size */ } .bigger { font-size: 1.5em; /* 1.5 times larger than the 'M' in normal font size */ }   ","version":"Next","tagName":"h3"},{"title":"Text Effects​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#text-effects","content":" There are numerous effects that can be added to text (or any element), many beyond the scope of this initial exploration of CSS. Here are a few simple examples to give you an idea  text-shadow allows a shadow to be added to text, giving it a 3-D style appearance. The value includes a colour,x and y offsets that determine the distance of the shadow from the text. Finally, we can also add a blur-radius, indicating how much to blur the shadow.  .shadow-text { text-shadow: 1px 1px 2px pink; }   text-overflow can be used to determine what the browser should do when the amount of text exceeds the available space in a container (e.g. in a &lt;div&gt; or &lt;p&gt; that isn't wide enough). For example, we can specify that we want to clip the contents and not show any more, or we can automatically display ..., the ellipsis.  &lt;style&gt; .movie-title { text-overflow: ellipsis; } &lt;/style&gt; &lt;span class=&quot;movie-title&quot;&gt;Pirates of the Caribbean: The Curse of the Black Perl&lt;/span&gt;   ","version":"Next","tagName":"h3"},{"title":"background Properties​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#background-properties","content":" Every element has a background that we can modify. We might, for example, want to specify that the background be a certain colour; or we might want to use an image, or even tile an image multiple times (like wallpaper to create a pattern); or we might want to create a gradient, from one colour to another. All of these options and more are possible using the backgroundproperty.  div.error { background: red; } div.wallpaper { background: url('pattern.jpg') repeat; }   ","version":"Next","tagName":"h2"},{"title":"Styling Links​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#styling-links","content":" We can control the way that links (i.e., &lt;a&gt;) appear in our document. By default they will have a solid blue underline, and when visited, a purple solid underline. If you want to remove the underline, or change it's colour to match the theme of a page, we can do that using CSS pseudo-classes.  With pseudo-classes we can specify certain states for the elements in our selector, for example:  a:link - a normal, unvisited link (normally blue underline)a:visited - a link the user has visited previously (normally purple underline)a:hover - a link when hovered with the mousea:active - a link when it is clicked (i.e., while the mouse button is pressed)  NOTE: pseudo-classes can be used with any element, but we mention them here in relation to styling links, since we often need them to deal with different states for a link.  Let's alter our links so that they use blue text, with no underline. However, when hovered, add back the underline:  a:link, a:visited { text-decoration: none; } a:hover, a:active { text-decoration: underline; }   ","version":"Next","tagName":"h2"},{"title":"CSS and the DOM via JavaScript​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#css-and-the-dom-via-javascript","content":" We've been discussing CSS in the context of HTML, but we also need to explore how to work with it via JavaScript. The DOM provides us a number of methodsfor examining and changing the CSS styles associated with elements.  First, we can use a DOM element's style property. Doing so gives us access to the inline style attribute of the element. We can get or set particular CSS property values via the style element using camelCase versions of the CSS property names. For example, background-color becomes backgroundColor, while width remains width.  // Change the background colour of all paragraphs to red var elems = document.querySelectorAll('p'); for (var i = 0, len = elems.length; i &lt; len; i++) { elems[i].style.backgroundColor = 'red'; }   Usually we don't need (or want) to alter properties one by one via the DOM. Instead, it's more common to add or remove classes to elements, which pre-define a set of properties.  Similar to an element's style property, we can also use its classList property. It has a number of useful methods:  add() - adds one (or more) class names to the element. If any of them are already present, they are ignored.remove() - removes one (or more) class names from the element.toggle() - toggles a class name on (adds it) or off (removes it), depending on the current state.contains() - checks if the specified class name is already defined for this element.replace() - replaces an old class name with the new one.  Using classes and classList, it's possible for us to define various states for our UI by creating multiple classes, and then add/remove them at runtime as the program runs and data changes.  Imagine you were creating a media player, and needed to show lists of songs and videos. Some of the media has been played by the user, and some is new. We can define classes for both, and then use JavaScript to apply the correct class to each:  &lt;style&gt; .media-played { background: gray; } .media-new { border: dashed red; } &lt;/style&gt; ... &lt;script&gt; // Loop through an array of media objects, and set the class for each one mediaItems.forEach(function (media) { var mediaElem = document.getElementById(media.id); if (media.played) { mediaElem.add('media-played'); } else { mediaElem.add('media-new'); } }); // When the user plays one of the media items, change it's display function mediaPlayed(media) { var mediaElem = document.getElementById(media.id); mediaElem.replace('media-new', 'media-played'); } &lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"Exercise: Using Third-Party CSS Libraries​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#exercise-using-third-party-css-libraries","content":" We've been focused on the mechanics of writing CSS ourselves, and this is an important skill. In addition, it's a good idea to know how to use third-party CSS libraries created by other developers. There are many pre-existing CSS libraries and frameworks we can use to help us create the web pages and apps we desire.  ","version":"Next","tagName":"h2"},{"title":"How to use Third-Party CSS​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#how-to-use-third-party-css","content":" There is a general pattern to using any CSS library in your web page.  Find a library you want to use. We've listed a number of interesting ones below.Read the documentation. Every library is different, and the &quot;installation&quot; and &quot;usage&quot; instructions will usually guide you on next steps. Get used to reading technical documentation, so that you can learn to solve your own problems.Figure out which file or files you need to include in your HTML. This will typically include one or more .css files, and maybe .js ,fonts, etc. You will likely need to use &lt;link&gt; and &lt;script&gt; elementsSee if the CSS library you want to use is available via a Content Delivery Network (CDN). Try searching for your chosen library on cdnjs or another CDN.Read the docs for your library to see if you need to include any special markup, classes, or other info in your HTML file in order for things to work. CSS libraries operate on HTML, and sometimes they will expect it to be in a particular format.  ","version":"Next","tagName":"h3"},{"title":"Popular CSS Libraries​","type":1,"pageTitle":"Applied CSS","url":"/WebProgrammingPrinciples/CSS-Styling/Applied-CSS#popular-css-libraries","content":" Here's a list of some popular CSS libraries and frameworks to get you started.  First, a few examples of simple &quot;drop in&quot; style libraries, where you simply include the CSS file, and everything &quot;Just Works&quot;:  Normalize.css - normalizes CSS so it is the same in all browsers (CDN link)Milligram - tiny set of default styles to make your site look great (CDN link)Tacit - CSS framework with no classes.  Next, there are lots of stylesheets you can use to improve the readability of your text:  TufteCSS - a stylesheet based on the ideas of Edward Tufte about typography and text (CDN link)Gutenberg - a drop-in stylesheet for Printing to a printerFont Awesome - beautiful fonts and icons  In addition to changing how our text looks, a lot of CSS libraries add interesting and playful animations and effects to spice up our HTML:  Hover - hover effects for links, buttons, and logsBalloon.css - tooltips and popupsAnimate.css - animations for HTML elementsCSShake - more animations for HTML elements (CDN link)CSSgram - Instagram style filters for HTML images  Another common problem CSS can solve is what to do while we wait for things to finish loading:  SpinKit - loading animations (CDN link)CSS Loader - more loading animations (CDN link)  Many CSS libraries have grown into more complex suites of layout, component, typography, navigation, and other solutions. We often refer to these as &quot;frameworks&quot; to indicate the expanded scope. There are many to choose from, including:  Pure.css - tiny CSS framework for responsive layouts, buttons, forms, menus, etc.PaperCSS - playful, hand-drawn style UI kitBootstrap - one of the most popular UI grid and component system for mobile and desktop web. Lots of themed versions of this too, for example Material UIUIKit - lightweight toolkit for building web app front-endsSemantic UI - UI framework, lots of responsive components (CDN link)Tailwind CSS - is a utility-first CSS framework for rapidly building modern websites without ever leaving your HTML. ","version":"Next","tagName":"h3"},{"title":"Practice Exercise","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/DOM-Events/Practice-Exercise","content":"Practice Exercise In this exercise, we will practice working with HTML, images, URLs, the DOM, events, and JavaScript to create an interactive web page. Create a folder called cats on your computer Create a file inside the cats folder named index.html Open a terminal to your cats folder (i.e., cd cats) In your terminal, start a web server by running the following command: npx http-server (alternatively, you can use the command: npx lite-server, refer week 5 notes) Open the cats folder in Visual Studio Code Edit the index.html file so it contains a basic HTML5 web page, including a &lt;head&gt;, &lt;body&gt;, etc. Try to do it from memory first, then look up what you've missed. Save index.html and try loading it in your browser by visiting your local web server at http://localhost:8080/index.html In your editor, modify the body of your index.html file to contain the text of the poem in cats.txt. Use HTML tags to markup the poem for the web. Your page should have a proper heading for the title, each line should break at the correct position, and the poet's name should be bold. Add an image of a cat to the page below the text. You can use https://upload.wikimedia.org/wikipedia/commons/c/c1/Sixweeks_old_cat%28aka%29.jpg. Adjust the width of your image so it fits nicely on your page. What happens if you adjust the width and height? Create a new file in your cats folder called script.js. Add the following line of JavaScript: console.log('cats!'); Add a script element to the bottom of your body (i.e., right before the closing &lt;/body&gt; tag). Set its src to a file called script.js: &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; Refresh your web page in the browser, and open your browser's Dev Tools, and Web Console. Make sure you can see the cats! message printed in the log. Try changing cats! in script.js to some other message, save your script.js file, and refresh your browser. Make sure your console updates with the new message. Modify index.html and update your &lt;img&gt; tag: add an attribute id=&quot;cat-picture&quot; and remove the src=&quot;...&quot;: &lt;!-- NOTE: there is no longer a src attribute in our HTML, we'll do it JavaScript below --&gt; &lt;img id=&quot;cat-picture&quot; /&gt; Modify your script.js file to add the following code: window.onload = function () { let img = document.getElementById('cat-picture'); img.src = 'https://upload.wikimedia.org/wikipedia/commons/c/c1/Six_weeks_old_cat_%28aka%29.jpg'; }; Save your script.js file and reload your browser. Do you still see a cat? If not, check your web console for any errors. Modify your script.js and change your cat URL used by img.src to use https://cataas.com/cat. The cataas.com site provides cat pictures as a service via URL parameters. Save script.js and reload your page a few times. Do you see a different cat each time? Modify your script.js file to move your image code to a separate function. Make sure it still works the same way when you're done (save and test in your browser): function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } window.onload = loadCatPicture; Rewrite script.js to update the picture after 5 seconds: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } window.onload = function () { loadCatPicture(); // Call the loadCatPicture function again in 5s setTimeout(loadCatPicture, 5 * 1_000 /* 5s = 5000ms */); }; Rewrite script.js to update the picture every 15 seconds, forever: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } window.onload = function () { loadCatPicture(); // Call the loadCatPicture function every 15000ms setInterval(loadCatPicture, 15 * 1_000 /* 15s = 15000ms */); }; Rewrite script.js to update the picture only when the user clicks somewhere in the window: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } window.onload = function () { loadCatPicture(); // Call the loadCatPicture function when the user clicks in the window window.onclick = loadCatPicture; }; Modify index.html and put a &lt;div&gt;...&lt;/div&gt; around all the text of the poem. Give your div an id=&quot;poem-text&quot; attribute: &lt;div id=&quot;poem-text&quot;&gt; &lt;p&gt;Cats sleep anywhere, any table, any chair....&lt;/p&gt; ... &lt;/div&gt; Rewrite script.js to load the picture only when the user clicks on the text of the poem: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } let poemText = document.getElementById('poem-text'); poemText.onclick = loadCatPicture; Rewrite script.js to also load the picture only when the user presses a key on the keyboard: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } let poemText = document.getElementById('poem-text'); poemText.onclick = loadCatPicture; window.onkeypress = function (event) { let keyName = event.key; console.log('Key Press event', keyName); loadCatPicture(); }; Rewrite script.js to also load the picture only when the user presses a key on the keyboard, but only one of b, m, s, n, p, x: function loadCatPicture() { let img = document.getElementById('cat-picture'); img.src = 'https://cataas.com/cat'; } let poemText = document.getElementById('poem-text'); poemText.onclick = loadCatPicture; window.onkeypress = function (event) { let keyName = event.key; console.log('Key Press event', keyName); switch (keyName) { case 'b': case 'm': case 's': case 'n': case 'p': case 'x': loadCatPicture(); break; default: console.log('Ignoring key press event'); } }; Rewrite script.js to also load the picture only when the user presses a key on the keyboard, but only one of b, m, s, n, p, x, and load the picture with one of the supported cataas filters: function loadCatPicture(filter) { let url = 'https://cataas.com/cat'; let img = document.getElementById('cat-picture'); // If the function is called with a filter argument, add that to URL if (filter) { console.log('Using cat picture filter', filter); url += `?filter=${filter}`; } img.src = url; } let poemText = document.getElementById('poem-text'); poemText.onclick = function () { loadCatPicture(); }; window.onkeypress = function (event) { let keyName = event.key; console.log('Key Press event', keyName); switch (keyName) { case 'b': return loadCatPicture('blur'); case 'm': return loadCatPicture('mono'); case 's': return loadCatPicture('sepia'); case 'n': return loadCatPicture('negative'); case 'p': return loadCatPicture('paint'); case 'x': return loadCatPicture('pixel'); default: console.log('Ignoring key press event'); } }; Rewrite script.js so that we only load a new cat picture when the old picture is finished loading (don't send too many requests to the server). Also, add some cache busting: // Demonstrate using a closure, and use an immediately executing function to hide // an `isLoading` variable (i.e., not global), which will keep track of whether // or not an image is being loaded, so we can ignore repeated requests. let loadCatPicture = (function () { let isLoading = false; // This is the function that will be bound to loadCatPicture in the end. return function (filter) { if (isLoading) { console.log('Skipping load, already in progress'); return; } let img = document.getElementById('cat-picture'); function finishedLoading() { isLoading = false; // Remove unneeded event handlers so `img` can be garbage collected. img.onload = null; img.onerror = null; img = null; } img.onload = finishedLoading; img.onerror = finishedLoading; // If the function is called with a filter argument, add that to URL let url = 'https://cataas.com/cat'; // Add something unique (and meaningless) to the query string, so the browser // won't cache this URL, but always load it again url += '?nocache=' + Date.now(); if (filter) { console.log('Using cat picture filter', filter); url += '&amp;filter=' + filter; } // Finally, set isLoading to true, and begin loading image isLoading = true; img.src = url; }; })(); let poemText = document.getElementById('poem-text'); poemText.onclick = function () { loadCatPicture(); }; window.onkeypress = function (event) { switch (event.key) { case 'b': return loadCatPicture('blur'); case 'm': return loadCatPicture('mono'); case 's': return loadCatPicture('sepia'); case 'n': return loadCatPicture('negative'); case 'p': return loadCatPicture('paint'); case 'x': return loadCatPicture('pixel'); default: console.log('Ignoring key press event'); break; } }; ","keywords":"","version":"Next"},{"title":"Events & Timers","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/DOM-Events/Events-Timers","content":"","keywords":"","version":"Next"},{"title":"Events​","type":1,"pageTitle":"Events & Timers","url":"/WebProgrammingPrinciples/DOM-Events/Events-Timers#events","content":" The DOM relies heavily on a concept known as event-driven programming. In event-driven programs, a main loop (aka the event loop), processes events as they occur.  Examples of events include things like user actions (clicking a button, moving the mouse, pressing a key, changing tabs in the browser), or browser/code initiated actions (timers, messages from background processes, reports from sensors).  Instead of writing a program in a strict order, we write functions that should be called in response to various events occurring. Such functions are often referred to asevent handlers, because they handle the case of some event happening. If there is no event handler for a given event, when it occurs the browser will simply ignore it. However, if one or more event handlers are registered to listen for this event, the browser will call each event handler's function in turn.  You can think of events like light switches, and event handlers like light fixtures: flipping a light switch on or off triggers an action in the light fixture, or possibly in multiple light fixtures at once. The lights handle the event of the light switch being flipped.  DOM programming is typically done by writing many functions that execute in response to events in the browser. We register our event handlers to indicate that we want a particular action to occur. DOM events have a name we use to refer to them in code.  We can register a DOM event handler for a given event in one of two ways:  element.onevent = function(e) {...};element.addEventListener('event', function(e) {...}) and element.removeEventListener('event', function(e) {...})  In both cases above, we first need an HTML element. Events are emitted to a target element. Elements in the DOM can trigger one or more events, and we must know the name of the event we want to handle.  In the first method above, element.onevent = function(e) {...};, a single event handler is registered for the event event connected with the target element element. For example, document.body.onclick = function(e) {...};, indicates we want to register an event handler for the click event on the document.body element (i.e., &lt;body&gt;...&lt;/body&gt;).  In the second method above, use addEventListener() to add as many individual, separate event handlers as we need. Whereas element.onclick = function(e) {...}; binds a single event handler (function) to the click event for element, using element.addEventListener('click', function(e) {...}); adds a new event handler (function) to any that might already exist.  Consider the following code:  let body = document.body; function handleClick(e) { // Process the click event } function handleClick2(e) { // Another click handler } body.onclick = handleClick; body.onclick = handleClick2; // There is only 1 click event handler on body: handleClick2 has replaced handleClick. body.addEventListener('click', handleClick); body.addEventListener('click', handleClick2); // There are now multiple, unique click handlers bound to the body's click event.   Because addEventListener() is more versatile than the older onevent properties, you are encouraged to use it in most cases.  Here's an example of the first method, where we only need a single event handler. In the following case, a web page has a Save button, and we want to save the user's work when she clicks it.  &lt;button id=&quot;btn-save&quot;&gt;Save&lt;/button&gt; &lt;script&gt; // Get a reference to our Save &lt;button&gt; let saveBtn = document.querySelector('#btn-save'); function save() { // Save the user's work } // Register a single event handler on the save button's click event saveBtn.onclick = function (e) { // Save the user's work, calling a save() function we wrote elsewhere save(); }; &lt;/script&gt;   Now consider the same code, but with multiple event handlers. In this case we not only want to save the user's work, but also log the information in our web analytics so we can keep track of how popular this feature is (how many times it gets clicked):  &lt;span id=&quot;needs-saving&quot;&gt;Document has changes, Remember to Save!&lt;/span&gt; ... &lt;button id=&quot;btn-save&quot;&gt;Save&lt;/button&gt; &lt;script&gt; // Get a reference to our Save &lt;button&gt; let saveBtn = document.querySelector('#btn-save'); // Register first event handler on the save button's click event saveBtn.addEventListener('click', function (e) { // Save the user's work, calling a save() function we wrote elsewhere save(); // Remove the &quot;needs to be saved&quot; info showing in our UI, since we've saved document.querySelector('#btn-save').setAttribute('hidden', true); }); // Register second event handler on the save button's click event saveBtn.addEventListener('click', function (e) { // Log some info to the console for debugging. console.log('[DEBUG] Save clicked'); // Use an analytics Object (defined elsewhere) to update our count for this event analytics.increment('save'); }); &lt;/script&gt;   In this second example, it's possible for the browser to call more than one function (event handler) in response to a single event (click). What's nice about this is that different parts of our code don't have to be combined into a single function. Instead, we can keep things separate (saving logic vs. analytics logic).  A complete example of a page that listens for changes to the network online/offline status, and updates the page accordingly, is available at online.html.  ","version":"Next","tagName":"h2"},{"title":"Common Events​","type":1,"pageTitle":"Events & Timers","url":"/WebProgrammingPrinciples/DOM-Events/Events-Timers#common-events","content":" There are many types of events we can listen for in the DOM, some of which are very specialized to certain elements or Objects. However, there some common ones we'll use quite often:  load - fired when a resource has finished loading (e.g., a window, img)beforeunload - fired just before the window is about to be unloaded (closed)focus - when the element receives focus (cursor input)blur - when the element loses focusclick - when the user single clicks on an elementdblclick - when the user double clicks on an elementcontextmenu - when the right mouse button is clickedkeypress - when a key is pressed on the keyboardchange - when the content of an element changes (e.g., an input element in a form)mouseout - when the user moves the mouse outside the elementmouseover - when the user moves the mouse over top of the elementresize - when the element is resized  All of the events described above can be used in either of the two ways we discussed above. For example, if we wanted to use the mouseout event on an element:  &lt;div id=&quot;map&quot;&gt;...&lt;/div&gt; &lt;script&gt; let map = document.querySelector('map'); // Method 1: register a single event handler via the on* property map.onmouseout = function (e) { // do something here in response to the mouseout event on this div. }; // Method 2: register one of perhaps many event handlers via addEventListener map.addEventListener('mouseout', function (e) { // do something here in response to the mouseout event on this div. }); &lt;/script&gt;   ","version":"Next","tagName":"h2"},{"title":"The Event Object​","type":1,"pageTitle":"Events & Timers","url":"/WebProgrammingPrinciples/DOM-Events/Events-Timers#the-event-object","content":" In the example code above, you may have noticed that our event handler functions often looked like this:  element.onclick = function (e) { // e is an instance of the Event object };   The single e argument is an instance of the Event Object. The e or event is provided to our event handler function in order to pass information about the event, and to give us a chance to alter what happens next.  For example, we can get a reference to the element to which the event was dispatched usinge.target. We can also instruct the browser to prevent the &quot;default&quot; action from happening as a result of this event usinge.preventDefault(), or stop the event from continuing to bubble up the DOM (i.e., rise up the DOM tree nodes, triggering other event handlers along the way) using `e.stopPropagation().  Here's an example showing how to use these:  &lt;button id=&quot;btn&quot;&gt;Click Me&lt;/button&gt; &lt;script&gt; document.querySelector('#btn').addEventListener('click', function (e) { // Prevent this event from doing anything more, we'll handle it all here. e.preventDefault(); e.stopPropagation(); // Get a reference to the &lt;button&gt; element let btn = e.target; // Change the text of the button btn.innerHTML = 'You clicked Me!'; }); &lt;/script&gt;   Some events also provide specialized (i.e., derived from Event) event Objects with extra data on them related to the context of the event. For example, a MouseEventgives extra detail whenever a click, mouse move, etc. event occurs:  &lt;div id=&quot;position&quot;&gt;&lt;/div&gt; &lt;script&gt; document.body.addEventListener('click', function (e) { // Get extra info about this mouse event so we know where the pointer was let x = e.screenX; let y = e.screenY; // Display co-ordinates where the mouse was clicked: &quot;Position (300, 342)&quot; document.querySelector('#position').innerHTML = `Position (${x}, ${y})`; }); &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"Timers​","type":1,"pageTitle":"Events & Timers","url":"/WebProgrammingPrinciples/DOM-Events/Events-Timers#timers","content":" It's also possible for us to write an event handler that happens in response to a timing event (delay) vs. a user or browser event. Using these timing event handlers, we scheduling a task (function) to run after a certain period of time has elapsed:  setTimeout(function, delayMS) - schedule a task (function) to be run in the future (delayMS milliseconds from now). Can be cancelled with clearTimeout(timerID)setInterval(function, delayMS) - schedule a task (function) to be run in the future every delayMS milliseconds from now. Function will be called repeatedly. Can be cancelled with clearInterval(timerID)  Here's an example of using an interval to update a web page with the current date and time every 1 second.  &lt;p hidden&gt;The current date and time is &lt;time id=&quot;current-date&quot;&gt;&lt;/time&gt;&lt;/p&gt; &lt;button id=&quot;btn-start&quot;&gt;Start Timer&lt;/button&gt; &lt;button id=&quot;btn-end&quot;&gt;End Timer&lt;/button&gt; &lt;script&gt; let startButton = document.querySelector('#btn-start'); let endButton = document.querySelector('#btn-end'); let timerId; // When the user clicks Start, start our timer startButton.onclick = function (e) { // If the user clicks it more than once, ignore it once it's running if (timerId) { return; } let currentDate = document.querySelector('#current-date'); currentDate.removeAttribute('hidden'); // Start our timer to update every 1000ms (1s), showing the current date/time. timerId = setInterval(function () { let now = new Date(); currentDate.innerHTML = now.toLocaleString(); }, 1000); }; endButton.onclick = function (e) { // If the user clicks End when the timer isn't running, ignore it. if (!timerId) { return; } // Stop the timer clearInterval(timerId); timerId = null; }; &lt;/script&gt;  ","version":"Next","tagName":"h2"},{"title":"HTML Elements","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements","content":"","keywords":"","version":"Next"},{"title":"HTML Element Types: Block vs. Inline​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements#html-element-types-block-vs-inline","content":" Visual HTML elements are categorized into one of two groups:  Block-level elements: create a &quot;block&quot; of content in a page, with an empty line before and after them. Block elements fill the width of their parent element. Block elements can contain other block elements, inline elements, or text.Inline elements: creates &quot;inline&quot; content, which is part of the containing block. Inline elements can contain other inline elements or text.  Consider the following HTML content:  &lt;body&gt; &lt;p&gt;The &lt;em&gt;cow&lt;/em&gt; jumped over the &lt;b&gt;moon&lt;/b&gt;.&lt;/p&gt; &lt;/body&gt;   Here we have a &lt;p&gt; paragraph element. Because it is a block-level element, this paragraph will fill its container (in this case the &lt;body&gt; element). It will also have empty space added above and below it.  Within this block, we also encounter a number of other inline elements. First, we have simple text. However, we also see the &lt;em&gt; and &lt;b&gt; elements being used. These will affect their content, but not create a new block; rather, they will continue to flow inline in their container (the &lt;p&gt; element).  ","version":"Next","tagName":"h2"},{"title":"Empty Elements​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements#empty-elements","content":" Many of the elements we've seen so far begin with an opening tag, and end with a closing tag: &lt;body&gt;&lt;/body&gt;. However, not all elements need to be closed. Some elements have no content, and therefore don't need to have a closing tag. We call these empty elements.  An example is the &lt;br&gt; line break element. We use a &lt;br&gt; when we want to tell the browser to insert a newline (similar to using \\n in C):  &lt;p&gt;Knock, Knock&lt;br /&gt;Who's there?&lt;/p&gt;   Other examples of empty elements include &lt;hr&gt; (for a horizontal line), &lt;meta&gt; for including metadata in the &lt;head&gt;, and a dozen others.  ","version":"Next","tagName":"h2"},{"title":"Grouping Elements​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements#grouping-elements","content":" Often we need to group elements in our page together. We have a number of pre-defined element container options for how to achieve this, depending on what kind of content we are creating, and where it is in the document.  Using this so-called semantic markup helps the browser and other tools (e.g., accessibility) determine important structural information about the document (see this post for a great discussion):  &lt;header&gt; - introductory material at the top of a&lt;nav&gt; - content related to navigation (a menu, index, links, etc)&lt;main&gt; - the main content of the document.&lt;article&gt; - a self-contained composition, such as a blog post, article, etc.&lt;section&gt; - a group of related elements in a document representing one section of a whole&lt;footer&gt; - end material (author, copyright, links)  Sometimes there is no appropriate semantic container element for our content, and we need something more generic. In such cases we have two options:  &lt;div&gt; - a generic block-level container&lt;span&gt; - a generic inline container  &lt;div&gt; &lt;p&gt; This is an example of a using a div element. It also includes this &lt;span&gt;&lt;em&gt;span&lt;/em&gt; element&lt;/span&gt;. &lt;/p&gt; &lt;p&gt; Later we'll use a div or span like this to target content in our page with JavaScript or CSS styles. &lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"Tables​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements#tables","content":" Sometimes our data is tabular in nature, and we need to present it in a grid. A number of elements are used to create them:  &lt;table&gt; - the root of a table in HTML&lt;caption&gt; - the optional title (or caption) of the table&lt;thead&gt; - row(s) at the top of the table (header row or rows)&lt;tbody&gt; - rows that form the main body of the table (the table's content rows)&lt;tfoot&gt; - row(s) at the bottom of the table (footer row or rows)  We define rows and columns of data within the above using the following:  &lt;tr&gt; - a single row in a table&lt;td&gt; - a single cell (row/column intersection) that contains table data&lt;th&gt; - a header (e.g., a title for a column)  We can use the rowspan and colspan attributes to extend table elements beyond their usual bounds, for example: have an element span two columns (colspan=&quot;2&quot;) or have a heading span 3 rows (rowspan=&quot;3&quot;).  &lt;table&gt; &lt;caption&gt; Order Information &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Quantity&lt;/th&gt; &lt;th&gt;Colour&lt;/th&gt; &lt;th&gt;Price (CAD)&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Red&lt;/td&gt; &lt;td&gt;$5.60&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;td&gt;$3.00&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;td&gt;$1.50&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th colspan=&quot;2&quot;&gt;Total&lt;/th&gt; &lt;th&gt;$26.60&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;   ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingPrinciples/Elements-Media/HTML-Elements#suggested-readings","content":" HTML Tables (MDN)Images in HTML (MDN)Video and Audio Content (MDN)HTML Reference ","version":"Next","tagName":"h2"},{"title":"DOM Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction","content":"","keywords":"","version":"Next"},{"title":"From HTML to the DOM​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#from-html-to-the-dom","content":" Web pages rely on HTML for their initial structure and content. We write web pages using HTML, and then use web browsers to parse and render that HTML into a living (i.e., modifiable at runtime) tree structure. Consider the following HTML web page:  The DOM Tree is a living version of our HTML.  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;This is a Document!&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome!&lt;/h1&gt; &lt;p&gt;This is a paragraph with a &lt;a href=&quot;index.html&quot;&gt;link&lt;/a&gt; in it.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;first item&lt;/li&gt; &lt;li&gt;second item&lt;/li&gt; &lt;li&gt;third item&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;   The browser will parse and render this into a tree of nodes, the DOM Tree:    The DOM Tree is made up of DOM Nodes, which represent all aspects of our document, from elements to attributes and comments. We'll refer to nodes and elements interchangeably, because all elements are nodes in the tree. However, there are also other types of nodes, for example: text nodes (the text in a block element) and attribute nodes (key/value pairs). We don't always show every node in our diagrams. Consider the &lt;p&gt; element from the example above:  &lt;p&gt;This is a paragraph with a &lt;a href=&quot;index.html&quot;&gt;link&lt;/a&gt; in it.&lt;/p&gt;   Here are the nodes that would be created:    In this diagram, the gray, square boxes represent element nodes, while the white, rounded boxes are text nodes.  When we load a web page in a web browser, we see its fully parsed and rendered form. The web browser begins with the initial content we provide in our HTML. We can see the initial source HTML for any page we visit, whether we authored it or not:    Our DOM Tree gets its name because of its shape: a root element connected to child nodes that extend like the branches of a tree. This tree structure is how the browser views our web page, and is why it is so important for us to open and close our HTML tags in order (i.e., our tags define the structure of the tree that the browser will create at runtime).  As web developers we can see and interact with the DOM tree for a page using the browser's built-in developer tools:    The dev tools allow us to view and work withthe parsed DOM elements in a page. We can also use the dev tools to visually select an element in the page, and find its associated DOM element:    NOTE: it's a good idea to get experience using, and learn about your browser's dev tools so that you can debug and understand when things go wrong while you are doing web development. There are a number of guides to help you learn, like this one from Google.  ","version":"Next","tagName":"h2"},{"title":"Programming the DOM​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#programming-the-dom","content":" Web pages are dynamic: they can change in response to user actions, different data, JavaScript code, etc. Where HTML defines the initial structure and content of a page, the DOM is the current or actual content of the page as it exists right now in your browser. And this can mean something quite different from the initial HTML used to load the page.  Consider a web page like GMail (or another email web client). When you visit your Inbox, the messages you see are not the same as when your friend visits hers. The HTML for GMail is the same no matter who loads the page. But it quickly changes in response to the needs of the current user.  So how does one modify a web page after it's been rendered in the browser? The answer is DOM programming. We've been using this &quot;DOM&quot; acronym without defining it, and its high time we did.  The Document Object Model (DOM) is a programming interface (i.e., set of Objects, functions, properties) allowing scripts to interact with, and modify documents (HTML, XML). The DOM is an object-oriented representation of a web page. Client-side web programming is essentially using the DOM via JavaScript to make web pages do things or respond to actions (e.g., user actions).  You may have noticed in our work with JavaScript that there was nothing particularly &quot;webby&quot; about it as a language: we wrote functions, worked with arrays, created objects. Lots of programming languages let you do this. JavaScript can't do anything with the web on its own. Instead, we need to access and use the Objects, functions, and properties made available to us by the DOM using JavaScript.  As web programmers we use the DOM via JavaScript to accomplish a number of important tasks:  Finding and getting references to elements in the pageCreating, adding, and removing elements from the DOM treeInspecting and modifying elements and their contentRun code in response to events triggered by the user, browser, or other parts of our code  Let's look at each one in turn.  ","version":"Next","tagName":"h2"},{"title":"Finding elements in the DOM with JavaScript​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#finding-elements-in-the-dom-with-javascript","content":" Our entry point to the DOM from JavaScript is via the global variable window. Every web page runs in an environment created by the browser, and that environment includes a global variable named window, which is provided by the browser (i.e., we don't create it).  There are hundreds of Objects, methods, and properties available to our JavaScript code via window. One example is window.document, which is how we access the DOM in our code:  // Access the document object for our web page, which is in the current window let document = window.document;   NOTE: since properties like document are available on the global window object, it is common to simply write document instead of window.document, since the global object is implied if no other scope is given.  Our document's tree of elements are now accessible to us, and we can access a number of well-known elements by name, for example:  // Get the value of the document's &lt;title&gt; let title = document.title; // Return a reference to the document's &lt;body&gt; element let body = document.body; // Return a list of all &lt;a&gt; elements in the document let hyperlinks = document.links; // Return a list of all the &lt;img&gt; elements in the document let images = document.images;   There are lots more. We can easily experiment with these in the dev tools web console, where we can access our window object. For example, here is the web pagehttps://unsplash.com/search/photos/toronto with the web console open, and the result of window.document.images is shown, 41 &lt;img&gt; elements are returned in a collection:    We can also use a number of methods to search for and get a reference to one or more elements in our document:  document.getElementById(id) - returns an element whose id attribute/property has the given id String &lt;div id=&quot;menu&quot;&gt;...&lt;/div&gt; &lt;script&gt; let menuDiv = document.getElementById('menu'); &lt;/script&gt; document.querySelector(selectors) - similar to document.getElementById(id), but also allows querying the DOM using CSS selectors for an element that doesn't have a unique id: &lt;div id=&quot;menu&quot;&gt; &lt;p class=&quot;formatted&quot;&gt;...&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // We can specify we want to query by ID using a leading # let menuDiv = document.querySelector('#menu'); // We can specify we want to query by CLASS name using a leading . let para = document.querySelector('.formatted'); &lt;/script&gt; document.querySelectorAll(selectors) - similar to document.querySelector(selector), but returns all elements that match the selectors as a NodeList: &lt;div id=&quot;menu&quot;&gt; &lt;p class=&quot;formatted&quot;&gt;Paragraph 1...&lt;/p&gt; &lt;p class=&quot;formatted&quot;&gt;Paragraph 2...&lt;/p&gt; &lt;p class=&quot;formatted&quot;&gt;Paragraph 3...&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // Get all &lt;p&gt; elements in the document as a list let pElements = document.querySelectorAll('p'); // Loop through all returned &lt;p&gt; elements in our list pElements.forEach(function (p) { // p is one of the returned &lt;p&gt; elements }); &lt;/script&gt;   These four methods will work in any situation where you need to get a reference to something in document. In fact, you could rely solely on document.querySelector() anddocument.querySelectorAll(), which cover the same functionality as a number of other DOM methods:  // The following two lines of code do exactly the same thing. // NOTE the use of # to indicate `demo` is an id in the second example. let elem = document.getElementById('demo'); let elem = document.querySelector('#demo');   ","version":"Next","tagName":"h3"},{"title":"Creating elements and Modifying the DOM with JavaScript​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#creating-elements-and-modifying-the-dom-with-javascript","content":" In addition to searching through the DOM using JavaScript, we can also make changes to it. The DOM provides a number of methods that allow use to create new content:  document.createElement(name) - creates and returns a new element of the type specified by name. let paragraphElement = document.createElement('p'); let imageElement = document.createElement('img'); document.createTextNode(text) - creates a text node (the text within an element vs. the element itself). let textNode = document.createTextNode('This is some text to show in an element');   These methods create the new nodes, but do not place them into the page. To do that, we first need to find the correct position within the existing DOM tree, and then add our new node. We have to be clear where we want the new element to get placed in the DOM.  For example, if we want to place a node at the end of the &lt;body&gt;, we could use .appendChild():  let paragraphElement = document.createElement('p'); document.body.appendChild(paragraphElement);   If we instead wanted to place it within an existing &lt;div id=&quot;content&quot;&gt;, we'd do this:  let paragraphElement = document.createElement('p'); let contentDiv = document.querySelector('#content'); contentDiv.appendChild(paragraphElement);   Both examples work the same way: given a parent node (document or &lt;div id=&quot;content&quot;&gt;), add (append to the end of the list of children) our new element.  We can also use .insertBefore(new, old) to accomplish something similar: add our new node before the old (existing) node in the DOM:  let paragraphElement = document.createElement('p'); let contentDiv = document.querySelector('#content'); let firstDivParagraph = contentDiv.querySelector('p'); contentDiv.insertBefore(paragraphElement, firstDivParagraph);   Removing a node is similar, and uses removeChild():  // Remove a loading spinner let loadingSpinner = document.querySelector('#loading-spinner'); // Get a reference to the loading spinner's parent element let parent = loadingSpinner.parentNode; parent.removeChild(loadingSpinner);   ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#examples","content":" Add a new heading to a document // Create a new &lt;h2&gt; element let newHeading = document.createElement('h2'); // Add some text to the &lt;h2&gt; element we just created. // Similar to doing &lt;h2&gt;This is a heading&lt;/h2&gt;. let textNode = document.createTextNode('This is a heading'); // Add the textNode to the heading's child list newHeading.appendChild(textNode); // Insert our heading into the document, at the end of &lt;body&gt; document.body.appendChild(newHeading); Create a new paragraph and insert into the document &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt; &lt;script&gt; // Create a &lt;p&gt; element let pElem = document.createElement('p'); // Use .innerHTML to create text nodes inside our &lt;p&gt;...&lt;/p&gt; pElem.innerHTML = 'This is a paragraph.'; // Get a reference to our &lt;div&gt; with id = demo let demoDiv = document.querySelector('#demo'); // Append our &lt;p&gt; element to the &lt;div&gt; demoDiv.appendChild(pElem); &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"Inspecting, Modifying a DOM element with JavaScript​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#inspecting-modifying-a-dom-element-with-javascript","content":" Once we have a reference to an element in JavaScript, we use a number of properties and methods to work with it.  ","version":"Next","tagName":"h3"},{"title":"Element Properties​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#element-properties","content":" element.id - the id of the element. For example: &lt;p id=&quot;intro&quot;&gt;&lt;/p&gt; has an id of &quot;intro&quot;.element.innerHTML - gets or sets the markup contained within the element, which could be text, but could also include other HTML tags.element.parentNode - gets a reference to the parent node of this element in the DOM.element.nextSibling - gets a reference to the sibling element of this element, if any.element.className - gets or sets the value of the class attribute for the element.  ","version":"Next","tagName":"h3"},{"title":"Element Methods​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#element-methods","content":" element.querySelector() - same as document.querySelector(), but begins searching from element vs. document element.querySelectorAll() - same as document.querySelectorAll(), but begins searching from element vs. document element.scrollIntoView() - scrolls the page until the element is in view. element.hasAttribute(name) - checks if the attribute name exists on this element element.getAttribute(name) - gets the value of the attribute name on this element element.setAttribute(name, value) - sets the value of the attribute name on this element element.removeAttribute(name) - removes the attribute name from this element  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"DOM Introduction","url":"/WebProgrammingPrinciples/DOM-Events/DOM-Introduction#examples-1","content":" Reveal an error message in the page, by removing an element's hidden attribute &lt;!-- The `hidden` attribute means this &lt;div&gt; won't be displayed until it's removed --&gt; &lt;div id=&quot;error-message&quot; hidden&gt; &lt;p&gt;There was an error saving the document. Please try again!&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // Try to save the file, and let error = saveFile(); if (error) { let elem = document.querySelector('#error-message'); elem.removeAttribute('hidden'); } &lt;/script&gt; Insert a user's profile picture into the page // Insert the user's picture (e.g., in response to hovering over a username) let profilePic = document.createElement('img'); // Set attributes via getters/setters on the element vs. attributes profilePic.id = 'user-' + username; profilePic.height = 50; profilePic.src = './images/' + username + '-user-profile.jpg'; // Insert the profile pic &lt;img&gt; into the document document.body.appendChild(profilePic); // Make sure the new image is visible, or scroll until it is profilePic.scrollIntoView(); Add new paragraph elements to a div // Use .innerHTML as a getter and setter to update some text let elem = document.querySelector('#text'); elem.innerHTML = '&lt;p&gt;This is a paragraph&lt;/p&gt;'; elem.innerHTML = elem.innerHTML + '&lt;p&gt;This is another paragraph&lt;/p&gt;';  ","version":"Next","tagName":"h3"},{"title":"Multimedia","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia","content":"","keywords":"","version":"Next"},{"title":"Images, Audio & Video​","type":1,"pageTitle":"Multimedia","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia#images-audio--video","content":" HTML5 has built in support for including images, videos, and audio along with text. We specify the media source we want to use, and also how to present it to the user via different elements and attributes  &lt;!-- External image URL, use full width of browser window --&gt; &lt;img src=&quot;https://images.unsplash.com/photo-1502720433255-614171a1835e?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=344dfca9dc8cb137a4b1c2c711752bc5&quot; /&gt; &lt;!-- Local file cat.jpg, limit to 400 pixels wide --&gt; &lt;img src=&quot;cat.jpg&quot; alt=&quot;Picture of a cat&quot; width=&quot;400&quot; /&gt;   HTML5 has also recently added the &lt;picture&gt; element, to allow for an optimal image type to be chosen from amongst a list of several options.  We can also include sounds, music, or other audio:  &lt;!-- No controls, music will just auto-play in the background. Only MP3 source provided --&gt; &lt;audio src=&quot;https://ia800607.us.archive.org/15/items/music_for_programming/music_for_programming_1-datassette.mp3&quot; autoplay &gt;&lt;/audio&gt; &lt;!-- Audio with controls showing, multiple formats available --&gt; &lt;audio controls&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt; &lt;p&gt; Sorry, your browser doesn't support HTML5 audio. Here is a &lt;a href=&quot;song.mp3&quot;&gt;link to the audio&lt;/a&gt; instead &lt;/p&gt; . &lt;/audio&gt;   Including video is very similar to audio:  &lt;!-- External Video File, MP4 file format, show controls --&gt; &lt;video src=&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot; controls &gt;&lt;/video&gt; &lt;!-- Local video file in various formats, show with controls --&gt; &lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;source src=&quot;video.ogg&quot; type=&quot;video/ogg&quot; /&gt; &lt;source src=&quot;video.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt;Sorry, your browser doesn't support HTML5 video&lt;/p&gt; &lt;/video&gt;   NOTE: the &lt;audio&gt; and &lt;video&gt; elements must use source URLs that point to actual audio or video files and not to a YouTube URL or some other source that is actually an HTML page.  ","version":"Next","tagName":"h2"},{"title":"Including Scripts​","type":1,"pageTitle":"Multimedia","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia#including-scripts","content":" We've spent a good portion of the course learning about JavaScript. So far, all of our code has been written in a stand-alone form, executed in the Firefox Scratchpad, or by using node.js.  Our ultimate goal is to be able to run our JavaScript programs within web pages and applications. To do that, we need a way to include JavaScript code in an HTML file. Obviously HTML isn't anything like JavaScript, so we can't simply type our code in the middle of an HTML file and expect the browser to understand it.  Instead, we need an HTML element that can be used to contain (or link to) our JavaScript code. HTML provides such an element in the form of the &lt;script&gt; element.  We can use &lt;script&gt; in one of two ways.  ","version":"Next","tagName":"h2"},{"title":"Inline Scripts​","type":1,"pageTitle":"Multimedia","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia#inline-scripts","content":" First, we can embed our JavaScript program directly within the content area of a &lt;script&gt; element:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Web Page with Script&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; console.log('Hello World!'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   Such &lt;script&gt; elements can occur anywhere in your HTML, though it is common to put them at the end of the &lt;body&gt;. We can also include more than one, and each shares a common global environment, which is useful for combining scripts:  &lt;script&gt; // Define a global variable `msg` with a String var msg = 'Hello World!'; &lt;/script&gt; &lt;script&gt; // Access the global variable `msg`, defined in another &lt;script&gt;, but within the same JS environment console.log(msg); &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"External Scripts Linked via URL​","type":1,"pageTitle":"Multimedia","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia#external-scripts-linked-via-url","content":" As our JavaScript programs get larger, embedding them directly within the HTML file via an inline &lt;script&gt;starts to become unwieldy. For very small scripts, and debugging or experimentation, inline scripts are fine. However, HTML and JavaScript aren't the same thing, and it's useful to separate them into their own files for a number of reasons.  First, browsers can cache files to improve load times on a web site. If you embed a large JavaScript file in the HTML, it can't be cached.  Second, your HTML becomes harder to read. Instead of looking at semantic content about the structure of your page, now you have script mixed in too. This can make it harder to understand what you're looking at while debugging.  Third, there are lots of tools for HTML, and even more for JavaScript, that only work when fed the proper file type. For example, we often use linters or bundling tools in JavaScript. We can't do that if our JavaScript is combined with HTML markup.  For these and other reasons, it's common to move your JavaScript programs to separate files with a .js file extension. We then tell the browser to load and run these files as needed via our &lt;script&gt; tag like so:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Web Page with Script&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   In this case, we have no content within our &lt;script&gt; element, and instead include a src=&quot;script.js&quot;attribute. Much like the &lt;img&gt; element, a &lt;script&gt; can include a src URL to load at runtime. The browser will begin by loading your .html file, and when it encounters the &lt;script src=&quot;script.js&quot;&gt; element, it will begin to download script.js from the web server, and then run the program it contains.  We can combine both of these methods, and include as many scripts as we need. The scripts we include can be:  embedded inline in the HTMLa relative URL to the same web server that served the HTML filean absolute URL to another web server somewhere else on the web  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Web Page with Scripts&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;https://scripts.com/some/other/external/script/file.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;local-script.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // Use functions and Objects defined in the previous two files doSomethingAmazing(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h3"},{"title":"Validating HTML​","type":1,"pageTitle":"Multimedia","url":"/WebProgrammingPrinciples/Elements-Media/Multimedia#validating-html","content":" It's clear that learning to write proper and correct HTML is going to take practice. There are lots of elements to get used to, and learn to use in conjunction. Also each has various attributes that have to be taken into account.  Browsers are fairly liberal in what they will accept in the way of HTML. Even if an HTML file isn't 100% perfect, a browser can often still render something. That said, it's best if we do our best to provide valid HTML.  In order to make sure that your HTML is valid, you can use an HTML Validator. There are a few available online:  https://html5.validator.nu/https://validator.w3.org/  Both allow you to enter a URL to an existing web page, or enter HTML directly in a text field. They will then attempt to parse your HTML and report back on any errors or warnings, for example: an element missing a closing tag. ","version":"Next","tagName":"h2"},{"title":"Practical Examples","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Elements-Media/Practical-Examples","content":"Practical Examples Image: img with fixed widthTable: table with multiple rows, columnsAudio: single audio sourceVideo: single video source","keywords":"","version":"Next"},{"title":"Forms & CSS","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Forms-Inputs/Forms-CSS","content":"","keywords":"","version":"Next"},{"title":"CSS Selectors and Forms​","type":1,"pageTitle":"Forms & CSS","url":"/WebProgrammingPrinciples/Forms-Inputs/Forms-CSS#css-selectors-and-forms","content":" There are a number of CSS selectors that are useful when working with forms.  An attribute selector allows us to match on the basis of either:  the presence of an attributethe exact or partial match of an attribute's value  For example, consider the following:  /* Style submit input controls */ input[type='submit'] { border: 2px solid #ccc; }   Another useful selector type are the various sibling selectors:  /* Style all &lt;input&gt; elements that are direct siblings of a &lt;label&gt; */ label+input { ... } /* Style all &lt;input&gt; elements that are siblings (direct or indirect) of a &lt;label&gt; */ label~input { ... }   Finally, a range of pseudo-selectors can be added to other elements/selectors to specify the state of a form control:  :valid - style to be used when the value meets all of the validation requirements.:invalid - style to be used when the value does not meet all of the validation requirements.:required - style for an input element that has the required attribute set.:optional - style for an input element that does not have the required attribute set.:in-range - style for a number input element where the value is in range.:out-of-range - style for a number input element where the value is out of range.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Forms & CSS","url":"/WebProgrammingPrinciples/Forms-Inputs/Forms-CSS#suggested-readings","content":" HTML FormsDesigning Efficient Web Forms: On Structure, Inputs, Labels and ActionsCreate Amazing FormsBootstrap Forms ","version":"Next","tagName":"h2"},{"title":"Practice Exercise","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Forms-Inputs/Practice-Exercise","content":"Practice Exercise In this in-class exercise we'll create a simple HTML form and then style it using CSS. Begin by downloading the layout.zip file. From there, you will notice that we have both: Initial HTML with no CSS: &quot;form-no-css.html&quot;Final version with CSS: &quot;form-styled.html&quot;","keywords":"","version":"Next"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Practice-Exercises","content":"Practice Exercises For each of the following, write a function that takes the given arguments, and returns or produces (e.g., console.log) the given result. Given r (radius) of a circle, calculate the area of a circle (A = π _ r _ r). Simulate rolling a dice using random(). The function should allow the caller to specify any number of sides, but default to 6 if no side count is given: roll() (assume 6 sided, return random number between 1 and 6) vs. roll(50) (50 sided, return number between 1 and 50). Write a function that converts values in Celcius to Farenheit: convert(0) should return &quot;32 F&quot;. Modify your solution to the previous function to allow a second argument: &quot;F&quot; or &quot;C&quot;, and use that to determine what the scale of the value is, converting to the opposite: convert(122, &quot;F&quot;) should return &quot;50 C&quot;. Function taking any number of arguments (Numbers), returning true if they are all less than 50: isUnder50(1, 2, 3, 5, 4, 65) should return false. Function allowing any number of arguments (Numbers), returning their sum: sum(1, 2, 3) should return 6. Function allowing any number of arguments of any type, returns true only if none of the arguments is falsy. allExist(true, true, 1) should return true, but allExist(1, &quot;1&quot;, 0) should return false. Function to create a JavaScript library name generator: generateName(&quot;dog&quot;) should return &quot;dog.js&quot; Function to check if a number is a multiple of 3 (returns true or false) Check if a number is between two other numbers, being inclusive if the final argument is true: checkBetween(66, 1, 50, true) should return false. Function to calculate the HST (13%) on a purchase amount Function to subtract a discount % from a total. If no % is given, return the original value. Function that takes a number of seconds as a Number, returning a String formatted like &quot;X Days, Y Hours, Z Minutes&quot; rounded to the nearest minute. Modify your solution above to only include units that make sense: &quot;1 Minute&quot; vs. &quot;3 Hours, 5 Minutes&quot; vs. &quot;1 Day, 1 Hour, 56 Minutes&quot; etc Function that takes any number of arguments (Numbers), and returns them in reverse order, concatenated together as a String: flip(1, 2, 3) should return &quot;321&quot; Function that takes two Numbers and returns their sum as an Integer value (i.e., no decimal portion): intSum(1.6, 3.333333) should return 4 Function that returns the number of matches found for the first argument in the remaining arguments: findMatches(66, 1, 345, 2334, 66, 67, 66) should return 2 Function to log all arguments larger than 255: showOutsideByteRange(1, 5, 233, 255, 256, 0) should log 256 to the console Function that takes a String and returns its value properly encoded for use in a URL. prepareString(&quot;hello world&quot;) should return &quot;hello%20world&quot; Using the previous function, write an enclosing function that takes any number of String arguments and returns them in encoded form, concatenated together like so: &quot;?...&amp;...&amp;...&quot; where &quot;...&quot; are the encoded strings. buildQueryString(&quot;hello world&quot;, &quot;goodnight moon&quot;) should return &quot;?hello%20world&amp;goodnight%20moon&quot; Function that takes a Function followed by any number of Numbers, and applies the function to all the numbers, returning the total: applyFn(function(x) { return x * x;}, 1, 2, 3) should return 14. After you try writing these yourself, take a look at a possible solution","keywords":"","version":"Next"},{"title":"Running a Development Web Environment","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment","content":"","keywords":"","version":"Next"},{"title":"Code Editor​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#code-editor","content":" For our code editor, we will be using Visual Studio Code, which is a free (open source) code editor created and maintained by Microsoft. It also works on Windows, macOS, and Linux. Make sure you have downloaded and installed it on all the computers you will use for web development.  ","version":"Next","tagName":"h2"},{"title":"Web Client​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#web-client","content":" For our web client we will use the many web browsers we introduced in Week 1, namely:  Google Chrome for desktop and AndroidMicrosoft Edge and Internet Explorer (IE)Apple Safari and Safari for iOSMozilla FirefoxOpera  There are many more, and you are highly encouraged to install as many as possible.  ","version":"Next","tagName":"h2"},{"title":"Web Server​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#web-server","content":" We will also need a web server to host our web pages and applications. Installing and running a web server can be complicated. Industry-grade web servers likeApache and nginx are free and can be installed and run on your local computer; however, they are much more complicated and powerful than anything we will need for hosting our initial web pages.  For our purposes, we will use one of the many simple node.js based HTTP servers. In order to use them, do the following:  Make sure you have installed node.js on your computer.In a terminal window, navigate to the directory that you want your web server to host. For example cd my-websiteNow download and run a web server using the npx command.  For example, you can use the serve web server like this:  cd my-website npx serve Need to install the following packages: serve@14.2.1 Ok to proceed? (y) ┌──────────────────────────────────────────┐ │ │ │ Serving! │ │ │ │ - Local: http://localhost:3000 │ │ - Network: http://10.7.133.229:3000 │ │ │ │ Copied local address to clipboard! │ │ │ └──────────────────────────────────────────┘   You can now open your web browser to http://localhost:3000 and browser your files. This uses the http protocol, and connects you to the special IP address127.0.0.1, also known as localhost(i.e., you can also use http://localhost:3000). The localhost IP address always refers to this computer, and allows you to connect network clients to your own machine. The final :3000 portion of the URL is a port number. Together,http://127.0.0.1:3000 means connect using HTTP to my local computer on port 3000.  NOTE: the second External IP address will be different than the above, but 127.0.0.1 will always be correct.  When you are done testing your web site, stop the web server by pressing CTRL-Cin your terminal window. To run the server again, use npx serve.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#suggested-readings","content":" HTML: HyperText Markup Language on MDNHTML BasicsLearning HTML: Guides and TutorialsHTML Reference ","version":"Next","tagName":"h2"},{"title":"HTML","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML","content":"","keywords":"","version":"Next"},{"title":"HTML Document​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#html-document","content":" The first HTML page ever created was built by Tim Berners-Lee on August 6, 1991.  Since then, the web has gone through many versions:  HTML - created in 1990 and standardized in 1997 as HTML 4xHTML - a rewrite of HTML using XML in 2000HTML5 - the current standard.  ","version":"Next","tagName":"h2"},{"title":"Basic HTML5 Document​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#basic-html5-document","content":" Here's a basic HTML5 web page:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;My Web Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- This is a comment --&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   Let's break this down and look at what's happening.  &lt;!doctype html&gt; tells the browser what kind of document this is (HTML5), and how to interpret/render it&lt;html&gt; the root element of our document: all other elements will be included within &lt;html&gt;...&lt;/html&gt;.&lt;head&gt; provides various information about the document as opposed to providing its content. This is metadata that describes the document to search engines, web browsers, and other tools.&lt;meta&gt; an example of metadata, in this case defining the character set used in the document: utf-8&lt;title&gt; an example of a specific (named) metadata element: the document's title, shown in the browser's title bar. There are a number of specific named metadata elements like this.&lt;body&gt; the content of the document is contained within &lt;body&gt;...&lt;/body&gt;.&lt;!-- ... --&gt; a comment, similar to using /* ... */ in C or JavaScript&lt;h1&gt; a heading element (there are headings 1 through 6), which is a title or sub-title in a document.  Now let's try creating and loading this file in our browser:  Make a directory on your computer called my-websiteCreate a new file in my-website named index.html (the index.html name is important, as it represents the main entry point to a directory of HTML files and other web resources)Use Visual Studio Code to open your my-website/index.html fileCopy the HTML we just discussed above, and paste it into your editorSave your index.html fileIn a terminal, navigate to your my-website directoryStart a web server by typing npx serve (you must do this from within the my-website directory)Open your web browser (Chrome, Firefox, etc) and enter http://localhost:3000 in the URL barMake sure you can see a new page with Hello World! in black text.  Now let's make a change to our document:  Go back to your editor and change the index.html file so that instead of Hello World! you have This is my web page.Save your index.html file.Go back to your browser and hit the Refresh button.Make sure your web page now says This is my web page.  Every time we update anything in our web page, we have to refresh the web page in our browser. The web server will serve the most recent version of the file on disk when it is requested. Web browsers and servers disconnect from one another after processing a request/response.  ","version":"Next","tagName":"h2"},{"title":"Common HTML Elements​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#common-html-elements","content":" There are many HTML elements you'll learn and use, but the following is a good initial set to get you started.  You can see an example page that uses every HTML element here.  ","version":"Next","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#metadata","content":" Information about the document vs. the document's content goes in various metadata elements:  &lt;link&gt; - links from this document to external resources, such as CSS stylesheets&lt;meta&gt; - metadata that can't be included via other elements&lt;title&gt; - the document's title  ","version":"Next","tagName":"h3"},{"title":"Major Document Sections​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#major-document-sections","content":" &lt;html&gt; - the document's root element, containing all other elements&lt;head&gt; - machine-readable metadata about the document&lt;body&gt; - the document's content  ","version":"Next","tagName":"h3"},{"title":"Content Sections​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#content-sections","content":" These are organizational blocks within the document, helping give structure to the content and provide clues to browsers, screen readers, and other software about how to present the content:  &lt;header&gt; - introductory material at the top of a document&lt;nav&gt; - content related to navigation (a menu, index, links, etc)&lt;main&gt; - the main content of the document. For example, a news article's paragraphs vs. ads, links, navigation buttons, etc.&lt;h1&gt;, &lt;h2&gt;, ..., &lt;h6&gt; - (sub) headers for different sections of content&lt;footer&gt; - end material (author, copyright, links)  ","version":"Next","tagName":"h3"},{"title":"Text Content​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#text-content","content":" We organize content into &quot;boxes,&quot; some of which have unique layout characteristics.  &lt;div&gt; - a generic container we use to attach CSS styles to a particular area of content&lt;ol&gt; - an ordered list (1, 2, 3) of list items&lt;ul&gt; - an unordered list (bullets) of list items&lt;li&gt; - a list item in an &lt;ul&gt; or &lt;ol&gt;&lt;p&gt; - a paragraph&lt;blockquote&gt; - an extended quotation  ","version":"Next","tagName":"h3"},{"title":"Inline Text​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#inline-text","content":" We also use elements within larger text content to indicate that certain words or phrases are to be shown differently:  &lt;a&gt; - an &quot;anchor&quot; element, which will produce a hyperlink, allowing users to click and navigate to some other document.&lt;code&gt; - formats the text as computer code vs. regular text.&lt;em&gt; - adds emphasis to the text (often in italics)&lt;span&gt; - another generic container, used to define CSS styles  ","version":"Next","tagName":"h3"},{"title":"Multimedia​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#multimedia","content":" In addition to text, HTML5 also defines a number of rich media elements:  &lt;img&gt; - an element used to embed images in a document.&lt;audio&gt; - an element used to embed sound in a document.&lt;video&gt; - an element used to embed video in a document&lt;canvas&gt; - a graphical area (rectangle) used to draw with either 2D or 3D using JavaScript.  ","version":"Next","tagName":"h3"},{"title":"Scripting​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#scripting","content":" We create dynamic web content and applications through the use of scripting:  &lt;script&gt; - used to embed executable code in a document, typically JavaScript. ","version":"Next","tagName":"h3"},{"title":"Scope","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures","content":"","keywords":"","version":"Next"},{"title":"Overwriting Variables in Child Scopes​","type":1,"pageTitle":"Scope","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures#overwriting-variables-in-child-scopes","content":" Since variables defined with var have function scope, and because functions can be nested, we have to be careful when naming our variables and arguments so as to not overwrite a variable in a parent scope. Or, we can use this to temporarily do exactly that. In both cases, we need to understand how nested scopes work.  Consider the the following code, where a variable named x is used in three different scopes. What will be printed to the console when child is called?  var x = 1; function parent() { var x = 2; function child(x) { console.log(x); } child(3); }   The first declaration of x creates a global variable (i.e., available in every scope). Then, in parent we re-declare x, creating a new local variable, which overwrites (or hides) the global variable x in this scope (i.e., within the body of parent). Next, we define yet another scope for child, which also uses x as the name of its only argument (essentially another local variable). When we do child(3), we are binding the value 3 to the xargument defined for the scope of child, and in so doing yet again overwriting the parent x. In the end, the console will show 3.  We can do this in error as well, and cause unexpected behaviour:  var total = 5; function increase(n) { var total = n + n; } increase(50); console.log(total);   Here we expect to see 100 but instead will get 5 on the console. The problem is that we have redefined, and thus overwritten total inside the increase function. During the call to increase, the new local variable total will be used, and then go out of scope. After the function completes, the original global variable total will again be used.  ","version":"Next","tagName":"h2"},{"title":"Closures​","type":1,"pageTitle":"Scope","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures#closures","content":" A closure is a function that has closed over a scope, retaining this scope even after it would otherwise disappear through the normal rules of execution. In the following function, the variable x goes out of scope as soon as the function finishes executing:  function f() { var x = 7; return x * 2; // After this return, and f completes, `x` will no longer be available. }   In JavaScript, functions have access not only to their own local variables, but also to any variables in their parents' scope. That is, if a variable is used (referenced) but not declared in a function, JavaScript will visit the parent scope to find the variable. This can happen for any number of child/parent levels up to the global level.  The following is an example of this, and probably one you've seen before:  var x = 7; function f() { return x * 2; // `x` not declared here, JS will look in the parent scope (global) }   Consider this example:  function parent() { var x = 7; function child() { return x * 2; } return child(); }   Here x is used in child, but declared in parent. The child function has access to all variables in its own scope, plus those in the parent scope. This nesting of scopes relies on JavaScript's function scope rules, and allows us to share data.  Sometimes we need to capture data in a parent scope, and retain it for a longer period of time than would otherwise be granted for a given invocation. Consider this example:  function createAccumulator(value) { return function (n) { value += n; return value; }; } var add = createAccumulator(10); add(1); // returns 11 add(2); // returns 13   Here the createAccumulator function takes an argument value, the initial value to use for an accumulator function. It returns an anonymous function which takes a value n (a Number) and adds it to the value before returning it. The add function is created by invoking createAccumulator with the initial value of 10. The function that is returned by createAccumulator has access to value in its parent's scope. Normally, value would be destroyed as soon as createAccumulator finished executing. However, we have created a closure to capture the variable value in a scope that is now attached to the function we're creating and returning. As long as the returned function exists (i.e., as long as add holds on to it), the variable value will continue to exist in our child function's scope: the variables that existed when this function was created continue to live on like a memory, attached to the lifetime of the returned function.  Closures make it possible to associate some data (i.e., the environment) with a function that can then operate on that data. We see similar strategies in pure object-oriented languages, where data (properties) can be associated with an object, and functions (methods) can then operate on that data. Closures play a somewhat similar role, however, they are more lightweight and allow for dynamic (i.e., runtime) associations.  By connecting data and functionality, closures help to reduce global variables, provide ways to &quot;hide&quot; data, allow a mechanism for creating private &quot;methods&quot;, avoid overwriting other variables in unexpected ways.  As we go further with JavaScript and web programming, we will encounter many instances where closures can be used to manage variable lifetimes, and associated functions with specific objects. For now, be aware of their existence, and know that it is an advanced concept that will take some time to fully master. This is only our first exposure to it.  Another way we'll see closures used, is in conjunction with Immediately-Invoked Function Expressions (IIFE). Consider the following rewrite of the code above:  let add = (function (value) { return function (n) { value += n; return value; }; })(10); add(1); // returns 11 add(2); // returns 13   Here we've declared add to be the value of invoking the anonymous function expression written between the first (...) parentheses. In essence, we have created a function that gets executed immediately, and which returns another function that we will use going forward in our program.  This is an advanced technique to be aware of at this point, but not one you need to master right away. We'll see it used, and use it ourselves, in later weeks to to avoid global variables, simulate block scope in JavaScript, and to choose or generate function implementations at runtime (e.g., polyfill). ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Functions","content":"","keywords":"","version":"Next"},{"title":"User-defined Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#user-defined-functions","content":" JavaScript has many built-in functions, which we'll get to below; however, it also allows you to write your own and/or use functions written by other developers (libraries, frameworks).  These user-defined functions can take a number of forms.  ","version":"Next","tagName":"h2"},{"title":"Function Declarations​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-declarations","content":" The first is the function declaration, which looks like this:  // The most basic function, a so-called NO OPERATION function function noop() {} // square function accepts one parameter `n`, returns its value squared. function square(n) { return n * n; } // add function accepts two parameters, `a` and `b`, returns their sum. function add(a, b) { return a + b; }   Here the function keyword initiates a function declaration, followed by aname, a parameter list in round parenthesis, and the function's body surrounded by curly braces. There is no semi-colon after the function body.  ","version":"Next","tagName":"h3"},{"title":"Function Expressions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-expressions","content":" The second way to create a function is using a function expression. Recall that expressions evaluate to a value: a function expression evaluates to a function Object. The resulting value is often bound (i.e., assigned) to a variable, or used as a parameter.  let noop = function () {}; let square = function (n) { return n * n; }; let add = function add(a, b) { return a + b; };   A few things to note:  The function's name is often omitted. Instead we return an anonymous function and bind it to a variable. We'll access it again via the variable name. In the case of recursive functions, we sometimes include it to make it easier for functions to call themselves. You'll see it done both ways.We did use a semi-colon at the end of our function expression. We do this to signify the end of our assignment statement let add = ... ;.In general, function declarations are likely a better choice (when you can choose) due to subtle errors introduced with declaration order and hosting (see below); however, both are used widely and are useful.  ","version":"Next","tagName":"h3"},{"title":"Arrow Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#arrow-functions","content":" Modern JavaScript also introduces a new function syntax called an Arrow Function or &quot;Fat Arrow&quot;. These functions are more terse, using the =&gt; notation (not to be confused with the &lt;= and &gt;= comparison operators):  let noop = () =&gt; {}; let square = (n) =&gt; n * n; let add = (a, b) =&gt; a + b;   When you see let add = (a, b) =&gt; a + b; it is short-hand for let add = function(a, b) { return a + b; }, where =&gt; replaces the function keyword and comes after the parameter list, and the return keyword is optional, when functions return a single value.  Arrow functions also introduce some new semantics for the this keyword, which we'll address later.  You should be aware of Arrow functions, since many web developers use them heavily. However, don't feel pressure to use them yet if you find their syntax confusing.  ","version":"Next","tagName":"h3"},{"title":"Parameters and arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#parameters-and-arguments","content":" Function definitions in both cases take parameter lists, which can be empty, single, or multiple in length. Just as with variable declaration, no type information is given:  function emptyParamList() {} function singleParam(oneParameter) {} function multipleParams(one, two, three, four) {}   A function can accept any number of arguments when it is called, including none. This would break in many other languages, but not JavaScript:  function log(a) { console.log(a); } log('correct'); // logs &quot;correct&quot; log('also', 'correct'); // logs &quot;also&quot; log(); // logs undefined   Because we can invoke a function with any number of arguments, we have to write our functions carefully, and test things before we make assumptions. How can we deal with a caller sending 2 vs. 10 values to our function?  One way we do this is using the built-in arguments Object.  Every function has an implicit arguments variable available to it, which is an array-like object containing all the arguments passed to the function. We can use arguments.length to obtain the actual number of arguments passed to the function at runtime, and use array index notation (e.g., arguments[0]) to access an argument:  function log(a) { console.log(arguments.length, a, arguments[0]); } log('correct'); // 1, &quot;correct&quot;, &quot;correct&quot; log('also', 'correct'); // 2, &quot;also&quot;, &quot;also&quot; log(); // 0, undefined, undefined   We can use a loop to access all arguments, no matter the number passed:  function sum() { const count = arguments.length; let total = 0; for (let i = 0; i &lt; count; i++) { total += arguments[i]; } return total; } sum(1); // 1 sum(1, 2); // 3 sum(1, 2, 3, 4); // 10   You may have wondered previously how console.log() can work with one, two, three, or more arguments. The answer is that all JavaScript functions work this way, and you can use it to &quot;overload&quot; your functions with different argument patterns, making them useful in more than one scenario.  ","version":"Next","tagName":"h3"},{"title":"Parameters and ...​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#parameters-and-","content":" Modern JavaScript also supports naming the &quot;rest&quot; of the parameters passed to a function. These Rest Parameters allow us to specify that all final arguments to a function, no matter how many, should be available to the function as a named Array.  There are some advantages to not using the implicit arguments keyword, which rest parameters provide.  We can convert the example above to this, naming our arbitrary list of &quot;numbers&quot;:  function sum(...numbers) { let total = 0; for (let i = 0; i &lt; numbers.length; i++) { total += numbers[i]; } return total; }   ","version":"Next","tagName":"h3"},{"title":"Dealing with Optional and Missing Arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#dealing-with-optional-and-missing-arguments","content":" Because we can change the number of arguments we pass to a function at runtime, we also have to deal with missing data, or optional parameters. Consider the case of a function to calculate a player's score in a video game. In some cases we may want to double a value, for example, as a bonus for doing some action a third time in a row:  function updateScore(currentScore, value, bonus) { return bonus ? currentScore + value * bonus : currentScore + value; } updateScore(10, 3); updateScore(10, 3); updateScore(10, 3, 2);   Here we call updateScore three different times, sometimes with 2 arguments, and once with 3. Our updateScore function has been written so it will work in both cases. We've used a conditional ternary operator to decide whether or not to add an extra bonus score. When we say bonus ? ... : ... we are checking to see if the bonus argument is truthy or falsy--that is, did the caller provide a value for it? If they did, we do one thing, if not, we do another.  Here's another common way you'll see code like this written, using a default value:  function updateScore(currentScore, value, bonus) { // See if `bonus` is truthy (has a value or is undefined) and use it, or default to 1 bonus = bonus || 1; return currentScore + value * bonus; }   In this case, before we use the value of bonus, we do an extra check to see if it actually has a value or not. If it does, we use that value as is; but if it doesn't, we instead assign it a value of 1. Then, our calculation will always work, since multiplying the value by 1 will be the same as not using a bonus.  The idiom bonus = bonus || 1 is very common in JavaScript. It uses theLogical Or Operator || to test whether bonus evaluates to a value or not, and prefers that value if possible to the fallback default of 1. We could also have written it out using an if statements like these:  function updateScore(currentScore, value, bonus) { if (bonus) { return currentScore + value * bonus; } return currentScore + value; } function updateScore(currentScore, value, bonus) { if (!bonus) { bonus = 1; } return currentScore + value * bonus; }   JavaScript programmers tend to use the bonus = bonus || 1 pattern because it is less repetitive, using less code, and therefore less likely to introduce bugs. We could shorten it even further to this:  function updateScore(currentScore, value, bonus) { return currentScore + value * (bonus || 1); }   Because this pattern is so common, modern JavaScript has added a built-in way to handle Default Parameters. Instead of using || notation in the body of the function, we can specify a default value for any named parameter when it is declared. This frees us from having to check for, and set default values in the function body. Using default parameters, we could convert our code above to this:  function updateScore(currentScore, value, bonus = 1) { return currentScore + value * bonus; }   Now, if bonus has a value (i.e., is passed as a parameter), we use it; otherwise, we use 1 as a default.  ","version":"Next","tagName":"h3"},{"title":"Return Value​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#return-value","content":" Functions always return a value, whether implicitly or explicitly. If the returnkeyword is used, the expression following it is returned from the function. If it is omitted, the function will return undefined:  function implicitReturnUndefined() { // no return keyword, the function will return `undefined` anyway } function explicitReturnUndefined() { return; // return keyword, but no expression given, which is also `undefined` } function explicitReturn() { return 1; // return keyword, followed by `Number` expression evalutes to `Number` } function explicitReturn2() { return 'Hello' + ' World!'; // return keyword, followed by expression evaluating to a `String` }   ","version":"Next","tagName":"h3"},{"title":"Function Naming​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-naming","content":" Functions are typically named using the same rules we learned for naming any variable: camelCase and using the set of valid letters, numbers, etc. and avoiding language keywords.  Function declarations always give a name to the function, while function expressions often omit it, using a variable name instead:  // Name goes after the `function` keyword in a declaration function validateUser() { ... } // Name is used only at the level of the bound variable, function is anonymous let validateUser = function() { ... }; // Name is repeated, which is correct but not common. Used with recursive functions let validateUser = function validateUser() { ... }; // Names are different, which is also correct, but not common as it can lead to confusion let validateUser = function validate() { // the validate name is only accessible here, within the function body ... };   Because JavaScript allows us to bind function objects (i.e., result of function expressions) to variables, it is common to create functions without names, but immediately pass them to functions as arguments. The only way to use this function is via the argument name:  // The parameter `fn` will be a function, and `n` a number function execute(fn, n) { // Call the function referred to by the argument (i.e, variable) `fn`, passing `n` as its argument return fn(n); } // 1. Call the `execute` function, passing an anonymous function, which squares its argument, and the value 3 execute(function (n) { return n * n; }, 3); // 2. Same thing as above, but with different formatting execute(function (n) { return n * n; }, 3); // 3. Same thing as above, using an Arrow Function execute((n) =&gt; n * n, 3); let doubleIt = function (num) { return num * 2; }; // 4. Again call `execute`, but this time pass `doubleIt` as the function argument execute(doubleIt, 3);   We can also use functions declared via function declarations used this way, and bind them to variables:  function greeting(greeting, name) { return greeting + ' ' + name; } var sayHi = greeting; // also bind a reference to greeting to sayHi // We can now call `greeting` either with `greeting()` or `sayHi()` console.log(greeting('Hello', 'Steven')); console.log(sayHi('Hi', 'Kim'));   JavaScript treats functions like other languages treat numbers or booleans, and lets you use them as values. This is a very powerful feature, but can cause some confusion as you get started with JavaScript.  You might ask why we would ever choose to define functions using variables. One common reason is to swap function implementations at runtime, depending on the state of the program. Consider the following code for displaying the user interface depending on whether the user is logged in or not:  // Display partial UI for guests and non-authenticated users, hiding some features function showUnauthenticatedUI() { ... } // Display full UI for authenticated users function showAuthenticatedUI() { ... } // We will never call showUnauthenticatedUI or showAuthenticatedUI directly. // Instead, we will use showUI to hold a reference to one or the other, // and default to the unauthenticated version at first (i.e., until the user logs in). let showUI = showUnauthenticatedUI; ... // Later in the program, when a user logs in, we can swap the implementation // without touching any of our UI code. function authenticate(user) { ... showUI = showAuthenticatedUI; } ... // Whenever we need to refresh/display the UI, we can always safely call // whichever function is currently bound to `showUI`. showUI();   ","version":"Next","tagName":"h3"},{"title":"Invoking Functions, the Execution Operator​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#invoking-functions-the-execution-operator","content":" In many of the examples above, we've been invoking (i.e., calling, running, executing) functions but haven't said much about it. We invoke a function by using the () operator:  let f = function () { console.log('f was invoked'); }; f();   In the code above, f is a variable that is assigned the value returned by a function expression. This means f is a regular variable, and we can use it like any other variable. For example, we could create another variable and share its value:  let f = function () { console.log('f was invoked'); }; let f2 = f; f(); // invokes the function f2(); // also invokes the function   Both f and f2 refer to the the same function object. What is the difference between saying f vs. f() in the line let f2 = f;? When we write f()we are really saying, &quot;Get the value of f (the function referred to) and invoke it.&quot; However, when we write f (without ()), we are saying, &quot;Get the value of f (the function referred to)&quot; so that we can do something with it (assign it to another variable, pass it to a function, etc).  The same thing is true of function declarations, which also produce function Objects:  function f() { console.log('f was invoked'); } let f2 = f; f2(); // also invokes the function   The distinction between referring to a function object via its bound variable name (f) vs invoking that same function (f()) is important, because JavaScript programs treat functions as data, just as you would a Number. Consider the following:  function checkUserName(userName, customValidationFn) { // If `customValidationFn` exists, and is a function, use that to validate `userName` if (customValidationFn &amp;&amp; typeof customValidationFn === 'function') { return customValidationFn(userName); } // Otherwise, use a default validation function return defaultValidationFn(userName); }   Here the checkUserName function takes two arguments: the first a String for a username; the second an optional (i.e., may not exist) function to use when validating this username. Depending on whether or not we are passed a function for customValidationFn, we will either use it, or use a default validation function (defined somewhere else).  Notice the line if(customValidationFn &amp;&amp; typeof customValidationFn === 'function') { wherecustomValidationFn is used like any other variable (accessing the value it refers to vs. doing an invocation), to check if it has a value, and if its value is actually a function. Only then is it save to invoke it.  It's important to remember that JavaScript functions aren't executed until they are called via the invocation operator, and may also be used as values without being called.  ","version":"Next","tagName":"h3"},{"title":"Built-in/Global Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#built-inglobal-functions","content":" JavaScript provides a small number of built-in global functions for working with its data types, for example:  parseInt()parseFloat()isNaN()isFinite()decodeURI()decodeURIComponent()encodeURI()encodeURIComponent()  There are also global functions that exist for historical reasons, but should be avoided for performance, usability, and/or security reasons:  eval() dangerous to parse and run user-defined stringsprompt() and alert() synchronous calls that block the UI thread.  Most of JavaScripts &quot;standard library&quot; comes in the form of methods on global objects vs. global functions. A method is a function that is bound to a variable belonging to an object, also known as a property. We'll be covering these in more depth later, but here are some examples  console.*. There are quite a few worth learning, but here are some to get you started: _ console.log(), console.warn(), and console.error()_ console.assert()_ console.count()_ console.dir()Math.* Math.abs()Math.max()Math.min()Math.random()Math.round() Date.* Date.now()Date.getTime()Date.getMonth()Date.getDay() JSON.* JSON.parse()JSON.stringify()  Much of web programming is done using Objects and calling their methods. JavaScript is a small language, but the ecosystem of Objects, APIs, libraries, and frameworks allows it to do anything.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#suggested-readings","content":" ExploringJS, Chapter 15. Functions and Chapter 16. Variables: Scopes, Environments, and ClosuresEloquent JavaScript, Chapter 3. FunctionsFunctions Guide and Reference on MDN. ","version":"Next","tagName":"h2"},{"title":"Practical Examples","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Practical-Examples","content":"Practical Examples Lists: ordered and unorderedAnchors: creating hyperlinksImages: using imgText: text sections","keywords":"","version":"Next"},{"title":"Internet Architecture","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#overview","content":" How does the Internet work? How the Internet works in 5 minutes (video) How the Web works  ","version":"Next","tagName":"h2"},{"title":"Application Protocols​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#application-protocols","content":" The web runs on-top of TCP/IP networks using a number of communication protocols, including:  IP these 32-bit numbers (IPv4) are assigned to every device on the Internet (IPv6 uses 128-bit numbers).Domain Names human-readable addresses for servers on the InternetDomain Name System (DNS), the &quot;Phone Book&quot; of the Internet. There are many popular DNS servers you can use: OpenDNS: 208.67.222.222, 208.67.220.220Cloudeflare: 1.1.1.1, 1.0.0.1Google: 8.8.8.8, 8.8.4.4There are lots more, but each has trade offs (privacy, speed) Hypertext Transfer Protocol (HTTP) How to get things on the webHTTP Responses Hypertext Transfer Protocol Secure (HTTPS)  There are many more as well (SMTP, FTP, POP, IMAP, SSH, etc).  We often use the terms &quot;Web&quot; and &quot;Internet&quot; interchangeably, however, they aren't the same. Pictured below, Tim Berners-Lee (left), who invented the World Wide Web, and Vint Cert (right), who was one of the main inventors of the Internet:    The World Wide Web (WWW) runs on top of the Internet using HTTP, and allows us to access web services, request resources (i.e., pages, images), and transmit data between clients and servers. The web is a subset of the Internet.  The web isn't owned or controlled by any single company, organization, or government.Instead, it is defined as a set of open standards, which everyone building and using the web relies upon. Some examples of these standards include HTML, HTTP, SVG, and many more.  ","version":"Next","tagName":"h2"},{"title":"HTTP Requests and Responses​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#http-requests-and-responses","content":" The Hypertext Transfer Protocol is a stateless, client-server model for formatting requests and responses between computers on the Internet. This means one computer makes a request (the client) to another (the server), and after the response is returned, the connection is closed.  The server listens for requests, and fulfills (or rejects) those requests by returning (or generating) the requested resources, such as images, web pages, videos, or other data.  ","version":"Next","tagName":"h2"},{"title":"URLs​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#urls","content":" Web resources are reachable via unique identifiers called a Uniform Resource Locator orURL. Consider the URL for this course's outline:  https://www.senecacollege.ca/cgi-bin/subject?s1=WEB222  A URL contains all the information necessary for a web client (e.g., a browser) to request the resource. In the URL given above we have:  protocol: https: - the resource is available using the HTTPS (i.e., secure HTTP) protocoldomain: www.senecacollege.ca - the domain (domain name) of the server. We could also have substituted the IP address (23.208.15.99), but it's easier to remember domain names.port: Not Given - if not specified, the port is the default for HTTP 80 or 443 for HTTPS. It could have been specified by appending :443 like so: https://www.senecacollege.ca:443origin: combining the protocol, domain, and port gives us a unique origin, https://www.senecacollege.ca. Origins play a central role in the web's security model.path: /cgi-bin/subject - a filesystem-like path to the resource on the server. It may or may not end with a file extension (e.g., you might also have seen another server use /cgi-bin/subject.html)query string: ?s1=WEB222 - additional parameters sent to the server as part of the URL, of the form name=value  URLs can only contain a limited set of characters, and anything outside that set has to be encoded. This includes things like spaces, non-ASCII characters, Unicode, etc.  ","version":"Next","tagName":"h3"},{"title":"Requests​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#requests","content":" A URL describes the location (i.e., server, pathname) and how to interpret (i.e., which protocol) a resource on the Internet. To get the resource, we need to request it by sending a properly formatted HTTP Request to the appropriate server (host):  GET /cgi-bin/subject HTTP/1.1 Host: www.senecacollege.ca   Here we do a GET request using HTTP version 1.1 for the resource at the path /cgi-bin/subjecton the server named www.senecacollege.ca.  There are various HTTP Verbs we can use other than GET, which allow us to request that resources be returned, created, deleted, updated, etc. The most common include:  GET - retrieve the data at the given URLPOST - create a new resource at the given URL based on the data sent along with the request in its bodyPUT - update an existing resource at the given URL with the data sent along with the request in its bodyDELETE - delete the resource at the given URL  We can use a URL in many ways, for example, via the command line using a tool like curl (NOTE: on Windows, use curl.exe):  $ curl https://www.senecacollege.ca/cgi-bin/subject?s1=WEB222 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML+RDFa 1.0//EN&quot; &quot;http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd&quot;&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot; xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot; xmlns:dc=&quot;http://purl.org/dc/terms/&quot; xmlns:foaf=&quot;http://xmlns.com/foaf/0.1/&quot; xmlns:og=&quot;http://ogp.me/ns#&quot; xmlns:rdfs=&quot;http://www.w3.org/2000/01/rdf-schema#&quot; xmlns:sioc=&quot;http://rdfs.org/sioc/ns#&quot; xmlns:sioct=&quot;http://rdfs.org/sioc/types#&quot; ... &lt;/section&gt; &lt;!-- /.block --&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h3"},{"title":"Responses​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#responses","content":" Upon receiving a request for a URL, the server will respond with an HTTP Response, which includes information about the response, and possibly the resource being requested. Let's use curl again, but this time ask that it --include the response headers:  $ curl --include https://www.senecacollege.ca/cgi-bin/subject\\?s1\\=WEB222 HTTP/1.1 200 OK Content-Type: text/html;charset=ISO-8859-1 Strict-Transport-Security: max-age=16070400; includeSubDomains Date: Wed, 06 Sep 2023 14:31:11 GMT Content-Length: 17241 Connection: keep-alive &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;!-- InstanceBegin template=&quot;/Templates/mainTemplate.dwt&quot; codeOutsideHTMLIsLocked=&quot;false&quot; --&gt; ...   In this case, we see a two-part structure: first a set of Response Headers; then the actual HTML Response Body. The two are separated by a blank line. The headers provide extra metadata about the response, the resource being returned, the server, etc.  HTTP Headers are well defined, and easy to lookup via Google, MDN, or StackOverflow. They follow the key: value format, and can be upper- or lower-case:  name: value  For example, in the response above, we see a number of interesting things:  200 OK - tells us that the requested resource was successful located and returned.Info about the DateThe Content-Type is text, and more specifically, html (a web page) using ISO-8859-1 text encoding.  After these headers we have a blank line (i.e., \\n\\n), followed by the body of our response: the actual HTML document.  What if we requested a URL that we know doesn't exist?  $ curl --include https://ict.senecacollege.ca/course/web000 HTTP/1.1 302 Found Date: Thu, 30 Aug 2018 20:25:28 GMT Server: Apache/2.4.29 (Unix) OpenSSL/1.0.2l PHP/5.6.30 X-Powered-By: PHP/5.6.30 Expires: Sun, 19 Nov 1978 05:00:00 GMT Cache-Control: no-cache, must-revalidate, post-check=0, pre-check=0 Location: https://ict.senecacollege.ca/Course/CourseNotFound?=web000 Content-Length: 0 Content-Type: text/html; charset=UTF-8   This time, instead of a 200 status code, we get 302. This indicates that the resource has moved, and later in the headers we are given a new Location to try. Notice there is no body (not every response will include one).  Let's try following the suggested redirect URL:  curl -I https://www.senecacollege.ca/cgi-bin/subjec HTTP/1.1 404 Not Found Pragma: no-cache Content-Type: text/html;charset=UTF-8 Strict-Transport-Security: max-age=16070400; includeSubDomains Cache-Control: no-cache, no-store, must-revalidate Date: Wed, 06 Sep 2023 14:35:04 GMT Connection: keep-alive Set-Cookie: JSESSIONID=25B152E3F14082DDB666AEE9BE3B4CA7; Path=/; Secure Set-Cookie: TS0148d87b=01576d3f8972e643bf2b887be1dd52aa5ea6da872a01d2283959af6601471be59f46727200dd63159112ada83202dee0854fecd43d332679805a76b9d6d9e9bacdf505fd97; Path=/ ...   Now a third response code has been returned, 404 Not Found as well as another HTML page telling us our course couldn't be located.  There are dozens of response codes, but they fall into a few categories you should learn:  1xx - information responses2xx – successful responses3xx - redirection messages4xx – client error responses5xx – server error responses  ","version":"Next","tagName":"h3"},{"title":"Web Browsers​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#web-browsers","content":" So far we've been communicating with web servers using curl, but a more common tool is a Web Browser.  A good way to think about a browser is as an operating system vs. an application. A web browser provides implementations of the web's open standards. This means it knows how to communicate HTTP, DNS and other protocols over the network in order to request resources via URLs. It also contains parsers for the web's programming languages, and knows how to render, execute, and lay-out web content for use by a user. Browsers also contain lots of security features, and allow users to download and run untrusted code (i.e., code from a random server on the Internet), without fear of infecting their computers.  Some of the the largest software companies and vendors in the world all have their own browsers:  Google Chrome for desktop and AndroidMicrosoft Edge and Internet Explorer (IE)Apple Safari and Safari for iOSMozilla FirefoxSamsung Internet for AndroidOpera  There are hundreds more, and thousands of different OS and version combinations. There are good stats on usage info for desktopand mobile, but no one company or browser controls the entire web.  As a web developer, you can't ever know for sure which browser your users will have. This means you have to test your web applications in different browsers and on different platforms in order to make sure the experience is good for as many people as possible.  The web is also constantly evolving, as new standards are written, APIs and features added to the web platform, and older technologies retired. A good way to stay on top of what does and doesn't work in a particular browser is to use https://caniuse.com/. This is a service that keeps track of web platform features, and which browsers do and don't implement it.  For example, you can look at the URL() API, used to work with URLs in JavaScript: https://caniuse.com/#feat=url. Notice that it's widely supported (green) in most browsers (89.69% at the time of writing), but not supported (red) in some older browsers like Internet Explorer.  Because the web is so big, so complicated, so old, and used by so many people for so many different and competing things, it's common for things to break, for there to be bugs, and for you to have to adapt your code to work in interesting ways. The good news is, it means there are lots of jobs for web developers to make sure it all keeps working.  ","version":"Next","tagName":"h2"},{"title":"Uniqueness of the Web as a Platform​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#uniqueness-of-the-web-as-a-platform","content":" We've been discussing HTTP as a way to request URLs be transferred between clients and servers. The web is globally distributed set of  services - requesting data (Text, JSON, XML, binary, etc) to be used in code (vs. looked at by a user)resources, pages, documents, images, media - both static and dynamic user viewable resources (web pages), which link to other similar resources.applications - a combination of the above, providing rich user interfaces for working with real-time data or other complex information, alone or in networked (i.e., collaborative) ways.  The web can be read-only. The web can also be interactive (video games), editable (wikis), personal (blog), and productive (e-commerce).  The web is linkable, which makes it something that can be indexed, searched, navigated, and connected. The web gets more valuable as its connections grow: just look at all the other pages and resources this page links to itself!  The web allows users to access and run remote applications without needing to install new software. The deployment model of the web is HTTP. Compare that to traditional software that has to be manually installed on every computer that needs to run it. The same is true with mobile phones and apps in the various app stores. On the web, updates get installed every time you open a URL.  Question: how many mobile or desktop apps did you install today vs. how many websites did you visit?  The web works on every computing platform. You can access and use the web on desktop and mobile computers, on TVs and smartwatches, on Windows and Mac, in e-Readers and video game consoles. The web works everywhere, and learning how to develop software for the web extends your reach into all those platforms.  ","version":"Next","tagName":"h2"},{"title":"Front-End Web Development: HTML5, CSS, JavaScript, and friends​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#front-end-web-development-html5-css-javascript-and-friends","content":" When we talk about programming for the web in a browser, we often refer to this asFront-End Web Development. This is in contrast to server-side, or Back-End Development. In this course we will be focused on the front-end, leaving back-end for subsequent courses.  The modern web, and modern web browsers, are incredibly powerful. What was once possible only on native operating systems can now be done within browsers using only web technologies (cf. running Windows 2000 or Doom 3 in a browser window!)  The set of front-end technologies that make this possible, and are commonly referred to as the Web Platform, include:  HTML5 - the Hypertext Markup Language, and its associated APIs, provide a way to define and structure contentCSS - Cascading Style Sheets allow developers and designers to create beautiful and functional UIs for the webJS - JavaScript allows complex user interaction with web content, and dynamic behaviours in documents and applications.DOM - the Document Object Model and its APIs allows scripts and web content to interact at runtime.Web APIs - hundreds of APIs provide access to hardware devices, networking, files, 2D and 3D graphics, databases, and so much more.WebAssembly or WASM - a low-level assembly language that can be run in web browsers, allowing code written in C/C++ and other non-web languages to target the web. For example, Google Earth uses WebAssembly.  In addition to these primary technologies, an increasingly important set of secondary, or third-party technologies are also in play:  Libraries, Modules - Bootstrap, Leaflet, Three.js, Lodash, ...Frameworks - React, Angular, Vue.js, ...Tooling - Babel, webpack, ESLint, PrettierLanguages that &quot;compile&quot; to JavaScript - because JavaScript runs everywhere, many languages target the web by &quot;compiling&quot; (also know as transpiling) to JavaScript. A good example is TypeScript.  The front-end web stack is also increasingly being used to build software outside the browser, both on desktop and mobile using things like Electron and Progressive Web Apps (PWA).Visual Studio Code, for example, is written using web technologies and runs on Electron, which is one of the reasons it works across so many platforms. You can also run it entirely in the browser: vscode.dev. ","version":"Next","tagName":"h2"},{"title":"Welcome to Web Programming Principles","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/welcome","content":"Welcome to Web Programming Principles The web is the most ubiquitous computing platform in the world. As a developer, learning the web takes time. There are hundreds of languages, libraries, frameworks, and tools to be learned, some old, some built yesterday, and all being mixed together at once. The fundamental unit of the web is the hyperlink--the web is interconnected. These weekly notes provide numerous links to external resources, books, blogs, and sample code. To get good at the web, you need to be curious and you need to go exploring, you need to try things. Make sure you follow the links below as you read, and begin to create your own web of knowledge and experience. No one resource can begin to cover the breadth and depth of web development. Question: do I need to read the weekly notes? How about all the many links to external resources? Yes, you do need to read the weekly notes. You will be tested on this material. We will discuss it in class, but not cover everything. The external links will help you understand and master the material. You are advised to read some external material, but you don't need to read all of it. However, make sure you do read Recommended Readings.","keywords":"","version":"Next"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Practice-Exercises","content":"Practice Exercises Try to solve each of the following using JavaScript. If you need to print something, use console.log(), which will print the argument(s) you give it. Create a variable label and assign it the value &quot;senecacollege&quot;. Create another variable tld and assign it &quot;ca&quot;. Create a third variable domainName that combines label and tld to produce the value &quot;senecacollege.ca&quot;. Create a variable isSeneca and assign it a boolean value (true or false) depending on whether or not domainName is equal to &quot;senecacollege.ca&quot;. HINT: use === and don't write true or false directly. Create a variable isNotSeneca and assign it the inverse boolean value of isSeneca. HINT: if isSeneca is true, isNotSeneca should be false. Create four variables byte1, byte2, byte3, byte4, and assign each of these a value in the range 0-255. Convert byte1 to a String using .toString(), and console.log() the result. What happens if you use toString(2) or toString(16) instead? Create a variable ipAddress and assign it the value of combining your four byteN variables together, separated by &quot;.&quot;. For example: &quot;192.168.2.1&quot;. Create a variable ipInt and assign it the integer value of bit-shifting (&lt;&lt;) and adding your byteN variables. HINT: your ipInt will contain 32 bits, the first byte needs to be shifted 24 bit positions (&lt;&lt; 24) so it occupies 32-25, the second shifted 16, the third 8. Create a variable ipBinary that contains the binary representation of the ipInt value. HINT: use .toString(2) to display the number with 1 and 0 only. Create a variable statusCode, and assign it the value for the &quot;I'm a teapot&quot; HTTP status code. HINT: see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status Write an If statement that checks to see if your statusCode is a 4xx client error. HINT: use the &lt;, &gt;, &gt;=, and/or &lt;= operators to test the value Write a switch statement that checks your statusCode for all possible 1xx information responses. In each case, you should console.log() the response text associated with the status code, or &quot;unknown information response&quot; if the status code is not known. Write a function is2xx(status) which takes a status code status (e.g., 200) and returns true if the status code is a valid 2xx code. Create a variable studentName and assign your name. Create another variable studentAge and assign it your age. Use console.log() to print out a sentence that includes both variables, like &quot;Alice is 20 years old.&quot;. Create a variable isEven and assign it a boolean value (true or false) depending on whether a given number num is even or not. HINT: use the modulus operator %. Create a variable isOdd and assign it the inverse boolean value of isEven. HINT: if isEven is true, isOdd should be false. Create a variable radius and assign it a value of 10. Calculate the area of a circle with this radius and assign the result to a variable area. HINT: use Math.PI and the formula area = πr^2. Create a variable temperatureInCelsius and assign it a value. Convert this temperature to Fahrenheit and assign the result to a variable temperatureInFahrenheit. HINT: use the formula F = C * 9/5 + 32. Create a variable heightInFeet and assign it a value. Convert this height to meters and assign the result to a variable heightInMeters. HINT: use the conversion factor 1 foot = 0.3048 meters. Create a variable seconds and assign it a value. Convert this time to minutes and seconds (e.g., 90 seconds becomes 1 minute and 30 seconds) and assign the result to two variables minutes and remainingSeconds. Create a variable score and assign it a value. Write an if statement that checks if the score is an A (90-100), B (80-89), C (70-79), D (60-69), or F (below 60) and assigns the result to a variable grade. Write a switch statement that checks the value of a variable day and console.log()s whether it is a weekday or weekend. HINT: day can be a value from 1 (Monday) to 7 (Sunday). Write a function isPositive(num) which takes a number num and returns true if the number is positive and false otherwise. Write a function isLeapYear(year) which takes a year year and returns true if the year is a leap year and false otherwise. HINT: a leap year is divisible by 4, but not by 100, unless it is also divisible by 400. Write a function getDayOfWeek(day) which takes a number day (from 1 to 7) and returns the day of the week as a string (e.g., &quot;Monday&quot;). Write a function getFullName(firstName, lastName) which takes two strings firstName and lastName and returns the full name as a single string. Write a function getCircleArea(radius) which takes a number radius and returns the area of a circle with that radius. Write a function getHypotenuse(a, b) which takes two numbers a and b (the lengths of the two sides of a right triangle) and returns the length of the hypotenuse. HINT: use the Pythagorean theorem and Math.sqrt() to calculate the square root. After you try writing these yourself, take a look at a possible solution.","keywords":"","version":"Next"},{"title":"Advanced Techniques","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques","content":"","keywords":"","version":"Next"},{"title":"XHR and Cross-Origin Requests​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#xhr-and-cross-origin-requests","content":" It should be noted that we've been making requests to third-party web servers in the example above. This is something that won't always work for all servers, or all data types.  In the examples above, the servers were configured to allow Cross-Origin Resource Sharing (CORS). By default, browsers maintain a sandbox around resources (scripts, images, data) from one origin, and don't let it mix in unsafe ways with resources from other origins.  In general, it's best to load data from the same origin as your page (i.e., the same web server). The so-called &quot;Same Origin&quot; policy states that you can't load data from other origins. However, using CORS headers, servers and browsers can allow this in some cases. In the examples above, the servers added a headerAccess-Control-Allow-Origin: * to indicate that cross-origin requests were OK.  If ever you are trying to use XHR to request data from a serer, and it won't work, the problem is almost certainly related to CORS.  ","version":"Next","tagName":"h2"},{"title":"Other Mechanisms for working with Data​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#other-mechanisms-for-working-with-data","content":" While XHR is a historically popular choice for accessing data from web services, in recent years a number of new APIs have also emerged that offer both similar and enhanced capabilities. Discussing these in any detail is beyond the scope of this course; however, it is important that you're aware of them, and look out for opportunities to learn and use them in future courses and projects.  ","version":"Next","tagName":"h2"},{"title":"fetch() API​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#fetch-api","content":" The fetch()API provides JavaScript developers a rich set of objects and functions for working with the entire HTTP network infrastructure, including things like requests, responses, the cache, etc. It uses the modern Promise API for handling callbacks.  Here's what it would look like to use fetch to request the current Bitcoin value from our first example above:  fetch('https://blockchain.info/q/24hrprice?cors=true') .then(function (response) { var currentValue = `${response.text()} (USD)`; updateBitcoinValue(currentValue); }) .catch(function (err) { updateBitcoinValue('unknown (error, unable to get current value)'); });   fetch offers much greater control over the network, and makes it easier to process data coming from the server.  ","version":"Next","tagName":"h3"},{"title":"Server Sent Events​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#server-sent-events","content":" With our Bitcoin example, we needed to constantly poll (i.e., re-request) the updated value from the server. Another approach would be to wait for the server to send us an update (push). One way to accomplish this is with Server Sent Events.  Server Sent Events allow web sites to open a long running connection with a server, and get updates from the server when there is new data. On the browser side, we use the EventSource Object to process these events, just as we would other types of events in a web page.  ","version":"Next","tagName":"h3"},{"title":"Web Sockets​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#web-sockets","content":" Server Sent Events are great for 1-way communciation from a server to a browser, but sometimes we need to also send data back to the server at regular intervals. Consider a chat application, where we need to both receive and send messages.  In such systems, we need a bi-directional, long-running connection to the server. The browser provides this in the form of a WebSocket. Web Sockets can be connected to different backends written in any language. Within the browser, we receive events when data arrives, and send data when we need to over the socket.  ","version":"Next","tagName":"h3"},{"title":"Modern Front End Development​","type":1,"pageTitle":"Advanced Techniques","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Advanced Techniques#modern-front-end-development","content":" The concepts we've been discussing above have come to define the modern approach to web development. Browsers have gotten faster and more powerful, and the APIs and tools for building web services more full-featured.  As a result, new approaches to front-end development have taken over. In your follow-up courses you'll learn more about popular front-end frameworks, which build on the low-level ideas we've been using here (HTML, CSS, JS, DOM, JSON), for example:  ReactAngularVueEmber  These frameworks take a data-driven approach to developing on the web, separating an applications data and state from its presentation. The ideas begun with AJAX are taken to another level, and single-page HTML applications are used to create rich interfaces.  Understanding the foundation for how all of this works, from HTML, CSS, and JS to JSON and XHR, will be an important part of taking the next step. ","version":"Next","tagName":"h2"},{"title":"HTML Forms Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction","content":"","keywords":"","version":"Next"},{"title":"<form>, <input>, and other Form markup​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-input-and-other-form-markup","content":" An HTML form is created using special markup and a number of special-purpose elements. The browser provides the user with custom components for entering, modifying, or even uploading data to be associated with our form. We'll begin by learning how to create, use, and style these form elements, and later look at how to work with the data programmatically in JavaScript.  The most important element for creating web forms &lt;form&gt;. A &lt;form&gt;element represents a section of a web page that contains interactive controls that a user can use to enter and submit data to the web page or server. The&lt;form&gt; element is a special type of container element, which we use to define information about how to send the user's data to a server:  &lt;form id=&quot;data&quot; action=&quot;/submit&quot; method=&quot;post&quot;&gt;&lt;/form&gt;   The &lt;form&gt;'s action attribute defines the URL where the data should be sent when submitted. In this case /submit really means &quot;send this data to the same web server as the page was served from, and to the /submit route&quot;. Sometimes you'll also use action=&quot;#&quot; to indicate that the form is to be processed in the browser, but not sent to any server URL. The method tells the browser which HTTP method to use when submitting the data to the URL defined in action. By default this will be GET, and all form options will be sent as query string values on the URL. When submitting a lot of form data, we can also use POST, which will include the information in the request's headers instead, allowing more content to be sent (i.e., URLs have a maximum length).  A &lt;form&gt; contains various elements that make up the set of inputs and widgets available to the user. The most common type of input control is the &lt;input&gt; element.  An &lt;input&gt; element represents an interactive form control used to accept data from the user. There are dozens of different types of input controls, with new ones still be added. Here's a basic &lt;input&gt; element for a user to enter their name in a textbox:  &lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;first-name&quot; /&gt;   The &lt;input&gt; element is used to tell the browser we want an input control to be created on the page. Notice that &lt;input&gt; elements are empty (i.e., no content) and don't have a closing tag. All of the information is stored in attributes on the element. As with all HTML elements, it's common (but not required) for an &lt;input&gt; control to have an id attribute, which uniquely identifies this control. In addition, we also specify a name=&quot;first-name&quot;attribute, which is used later to associate the value entered by the user with the particular control on the form--in this case, the value entered by the user will be called first-name when the form gets processed. Finally, we have a type=&quot;text&quot;attribute, indicating that this form control should be rendered in the page as a textbox.  There are many more form elements, attributes, and input types to learn. Let's continue by looking at some well-known, real-world examples of forms and how they are built.  ","version":"Next","tagName":"h2"},{"title":"Form Example 1: Google Search​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-example-1-google-search","content":" Our first example is perhaps the most popular form on the web:    Here's a simplified version of the HTML Google uses to create that form (if you want to see the original, open your browser's dev tools on the Google home page and inspect the elements yourself):  &lt;form id=&quot;tsf&quot; class=&quot;tsf nj&quot; action=&quot;/search&quot; method=&quot;GET&quot; name=&quot;f&quot;&gt; &lt;input name=&quot;source&quot; type=&quot;hidden&quot; value=&quot;hp&quot; /&gt; &lt;input value=&quot;qIXxW6O0FeTMjwT1zpioCA&quot; name=&quot;ei&quot; type=&quot;hidden&quot; /&gt; &lt;input class=&quot;gLFyf gsfi&quot; maxlength=&quot;2048&quot; name=&quot;q&quot; type=&quot;text&quot; title=&quot;Search&quot; /&gt; &lt;input value=&quot;Google Search&quot; name=&quot;btnK&quot; type=&quot;submit&quot; /&gt; &lt;input value=&quot;I'm Feeling Lucky&quot; name=&quot;btnI&quot; type=&quot;submit&quot; /&gt; &lt;/form&gt;   Let's examine this code for a moment and try to understand what's happening.  First, notice that all of the input controls (i.e., the search text box and both buttons), are grouped together inside a &lt;form&gt;&lt;/form&gt; element.  The &lt;form&gt; element has a number of attributes, some we've seen before (id, class), and others are new:  name=&quot;f&quot; - before browsers standardized on using id to identify elements, forms used to have a name attribute to identify a form in the page (i.e., if there was more than one).action=&quot;/search&quot; - tells the browser where the data in the form is meant to be submitted. In this case /search really means the URL https://google.com/search. Sometimes you'll also use action=&quot;#&quot; to indicate that the form is to be processed in the browser, but not sent to any server URL.method=&quot;GET&quot; - tells the browser to use the HTTP GET method when submitting this form. In this case, the amount of data being sent is small enough that it can fit everything on the URL.  The &lt;form&gt; element then contains a number of elements that represent form input controls. Google uses the most common form control, &lt;input&gt;, to build the form, creating three different kinds of form controls:  Hidden Input Controls: &lt;input name=&quot;source&quot; type=&quot;hidden&quot; value=&quot;hp&quot;&gt; and &lt;input value=&quot;qIXxW6O0FeTMjwT1zpioCA&quot; name=&quot;ei&quot; type=&quot;hidden&quot;&gt; - these are hidden form controls. They won't be visible to the user, but allow for extra information to be stored in a value that will get submitted with the form. Think of these hidden controls as variables. In this case, Google is storing information about the fact that we're doing our search from the Home Page (name=&quot;source&quot; value=&quot;hp&quot;) and also including a special timestamp (value=&quot;qIXxW6O0FeTMjwT1zpioCA&quot; name=&quot;ei&quot;) indicating when this query was made. In both cases the name and value attributes are used to indicate key/value pairs in the form data.Text Input Control: &lt;input class=&quot;gLFyf gsfi&quot; maxlength=&quot;2048&quot; name=&quot;q&quot; type=&quot;text&quot; title=&quot;Search&quot;&gt; - this is a text input form control. This control gets rendered as a textbox in the browser, which the user can focus and enter text with the keyboard. The default type of a form control is text. As we discussed above, all &lt;input&gt; elements need a name attribute to uniquely identify the value. In this case the name is q, short for query, and there is no defined value, since the user will provide it. Also note the use of the maxlength=&quot;2048&quot; attribute, which tells the browser not to let the user type more than 2,048 characters in this textbox.Submit Button Controls: &lt;input value=&quot;Google Search&quot; name=&quot;btnK&quot; type=&quot;submit&quot;&gt; and &lt;input value=&quot;I'm Feeling Lucky&quot; name=&quot;btnI&quot; type=&quot;submit&quot;&gt; - these are submit form controls, which literally submit (upload) the &lt;form&gt;'s data using the HTTP method to the action URL.  If I enter some some text in the textbox, cat pictures, and click the Google Searchsubmit button, my browser submits the form to /search as a GET request, encoding all the values in the form into query string values on the URL:  https://www.google.com/search?source=hp&amp;ei=qIXxW6O0FeTMjwT1zpioCA&amp;q=cat+pictures&amp;btnK=Google+Search  If we break that URL apart, we notice the following:  https://www.google.com the origin/search - the pathname?source=hp&amp;ei=qIXxW6O0FeTMjwT1zpioCA&amp;q=cat+pictures&amp;btnK=Google+Search the query string, with the submitted form values source=hp, i=qIXxW6O0FeTMjwT1zpioCA, q=cat+pictures, and btnK=Google+Search separated by &amp;  We could have manually entered that URL and gotten our search results. However, by using a &lt;form&gt; and submitting via a GET request, the browser has created it for us.  ","version":"Next","tagName":"h3"},{"title":"Form Example 2: My Seneca Login​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-example-2-my-seneca-login","content":" Our second example is well known to Seneca students: the login form on https://my.senecacollege.ca:    Here's a simplified version of the HTML used to create it:  &lt;form action=&quot;/webapps/login&quot; method=&quot;POST&quot; name=&quot;login&quot;&gt; &lt;label for=&quot;user_id&quot;&gt;Username&lt;/label&gt; &lt;input id=&quot;user_id&quot; type=&quot;text&quot; name=&quot;user_id&quot; size=&quot;25&quot; maxlength=&quot;50&quot; /&gt; &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt; &lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password&quot; autocomplete=&quot;off&quot; size=&quot;25&quot; /&gt; &lt;input id=&quot;entry-login&quot; type=&quot;submit&quot; class=&quot;button expand&quot; value=&quot;Login&quot; name=&quot;login&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;login&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;new_loc&quot; value=&quot;&quot; /&gt; &lt;/form&gt;   This does many similar things to Google's search form, so let's focus on the differences.  First, this form uses a new HTML element, &lt;label&gt;, to add a text label to the two textboxes. Each label is a caption of text that gets associated with an &lt;input&gt; control by specifying a for=&quot;...&quot; attribute that links it to the id of the correct control. We see two instances of this, one for Username, which connects with the user_id input control, and Passwordfor password.  Second, the user_id input control is of type text, but it specifies bothsize=&quot;25&quot; and maxlength=&quot;50&quot;. This tells the browser to render a textbox that can display 25 characters, and to not allow the user to enter any characters beyond 50.  Third, the password input control is not of type text, but rather password. This tells the browser to render a textbox, but hide the characters the user enters. In a desktop browser this might mean using * for every character; in a mobile browser this might mean that each character is shown for a second, and then replaced by a •. The password control also specifies size=&quot;25 to indicate that users shouldn't be able to type (or paste) more than 25 characters. The autocomplete=&quot;off&quot; attribute is used as a hint to the browser that it shouldn't try and automatically fill-in the password field. Most browsers ignore this request, since password managers have become so common.  Finally, notice that the &lt;form&gt; uses method=&quot;POST&quot; instead of GET, andaction=&quot;/webapps/login&quot;. This means that when we submit the &lt;form&gt;, the data will be POSTed to https://my.senecacollege.ca/webapps/login/. A POST differs from a GET in that the form data will be encoded and included in the body of the HTTP request instead of the URL. If I try to login with a username of johnand a password of 123, here's a simplified version of the HTTP request that gets sent to the web server:  Host: my.senecacollege.ca Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Content-Type: application/x-www-form-urlencoded Content-Length: 59 action=login&amp;login=Login&amp;new_loc=&amp;password=123&amp;user_id=john   Notice the Content-Type is set to be application/x-www-form-urlencoded, which means we're submitting form data. Also notice that the body of the request (everything after the blank line), is our form data in the form name=value with each one separated by a &amp; symbol.  Notice too how the password I entered is being sent in plain text! Even though the browser masked the password when I entered it in the password control, it ends up being sent to the server without being encrypted or altered in anyway. This is important to understand, both as a user and developer, since you only want to submit sensitive form data to secure origins (i.e., using https).  ","version":"Next","tagName":"h3"},{"title":"Form Example 3: Twitter Email Notification Settings​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-example-3-twitter-email-notification-settings","content":" Let's look at another, somewhat more complex form, this time from Twitter's settings:    Here's a simplified version of the HTML used to create it:  &lt;form id=&quot;notifications-form&quot; method=&quot;POST&quot; action=&quot;/settings/email_notifications/update&quot;&gt; &lt;fieldset class=&quot;control-group&quot;&gt; &lt;legend class=&quot;control-label&quot;&gt;Email me when&lt;/legend&gt; &lt;label class=&quot;t1-label checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; id=&quot;send_network_activity_email&quot; name=&quot;user[send_network_activity_email]&quot; disabled=&quot;&quot; /&gt; You have new notifications. &lt;a href=&quot;https://support.twitter.com/articles/127860#tweet-activity&quot; target=&quot;_blank&quot; class=&quot;learn-more&quot; rel=&quot;noopener&quot; &gt;Learn more.&lt;/a &gt; &lt;/label&gt; &lt;input type=&quot;hidden&quot; value=&quot;0&quot; name=&quot;user[send_network_activity_email]&quot; disabled=&quot;&quot; /&gt; &lt;label class=&quot;t1-label checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; id=&quot;send_new_direct_text_email&quot; name=&quot;user[send_new_direct_text_email]&quot; disabled=&quot;&quot; /&gt;You're sent a direct message &lt;/label&gt; &lt;input type=&quot;hidden&quot; value=&quot;0&quot; name=&quot;user[send_new_direct_text_email]&quot; disabled=&quot;&quot; /&gt; &lt;label class=&quot;t1-label checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; id=&quot;send_shared_tweet_email&quot; name=&quot;user[send_shared_tweet_email]&quot; checked=&quot;&quot; disabled=&quot;&quot; /&gt;Someone emails a Tweet to you &lt;/label&gt; &lt;input type=&quot;hidden&quot; value=&quot;0&quot; name=&quot;user[send_shared_tweet_email]&quot; disabled=&quot;&quot; /&gt; &lt;/fieldset&gt; &lt;hr /&gt; &lt;fieldset class=&quot;control-group&quot;&gt; &lt;legend class=&quot;control-label&quot;&gt;Email you with&lt;/legend&gt; &lt;label class=&quot;t1-label checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;4&quot; id=&quot;network_digest_schedule&quot; name=&quot;user[network_digest_schedule]&quot; disabled=&quot;&quot; /&gt;Top Tweets and Stories &lt;/label&gt; &lt;label class=&quot;t1-label&quot;&gt; &lt;span class=&quot;u-hiddenVisually&quot;&gt;Preference&lt;/span&gt; &lt;select class=&quot;t1-select preference-dropdown&quot; disabled=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;Sent daily&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Sent weekly&lt;/option&gt; &lt;option value=&quot;4&quot; selected=&quot;selected&quot;&gt;Sent periodically&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;hidden&quot; value=&quot;0&quot; name=&quot;user[network_digest_schedule]&quot; disabled=&quot;&quot; /&gt; &lt;label class=&quot;t1-label checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;3&quot; id=&quot;performance_digest_schedule&quot; name=&quot;user[performance_digest_schedule]&quot; checked=&quot;&quot; disabled=&quot;&quot; /&gt;Updates about the performance of your Tweets &lt;/label&gt; &lt;input type=&quot;hidden&quot; value=&quot;0&quot; name=&quot;user[performance_digest_schedule]&quot; disabled=&quot;&quot; /&gt; &lt;/fieldset&gt; &lt;/form&gt;   This form doesn't have any controls where the user types text. Instead, it uses interactive checkboxes and dropdown menus. It also introduces some more new form elements to create sub-groups of options in a larger form. Let's once again focus on what's new.  The first thing we see is that the form is grouped into two sets of controls. This is achieved through the use of the &lt;fieldset&gt; container element. The &lt;legend&gt; element provides a caption for the groupings, &quot;Email me When&quot; vs. &quot;Email you with&quot;.  Next we see a new type of &lt;input&gt; being used in order to create a checkbox:  &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; id=&quot;send_network_activity_email&quot; name=&quot;user[send_network_activity_email]&quot; disabled=&quot;&quot; /&gt;   In this case the checkbox is toggled on, and value=&quot;1&quot; represents this in HTML. It's not being done in this case, but often a checkbox will use the checked attribute to indicate that the checkbox is checked, and value to specify what data will be submitted with the form (it doesn't have to be 1 or 0, but could be any string). This checkbox also includes the disabledattribute, indicating that while it is visible, it can't currently be changed. In this case, the user would have to enable email settings for this control to become alterable.  In addition to using multiple checkbox controls, this form also uses a dropdown menu of options:  &lt;select class=&quot;t1-select preference-dropdown&quot; disabled=&quot;&quot;&gt; &lt;option value=&quot;1&quot;&gt;Sent daily&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Sent weekly&lt;/option&gt; &lt;option value=&quot;4&quot; selected=&quot;selected&quot;&gt;Sent periodically&lt;/option&gt; &lt;/select&gt;   The dropdown is created using a mix of &lt;select&gt; and &lt;option&gt; elements. The &lt;select&gt; is a container for all the various possible options in the list. Each option is defined via an &lt;option&gt;, which specifies a value (the data that will be sent when the form is submitted), and the text to display. By including selected=&quot;selected&quot; on one of options, the browser will show that value as the chosen value when the page loads.  ","version":"Next","tagName":"h3"},{"title":"Form Example 4: Airbnb Search​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-example-4-airbnb-search","content":" Here's another form that introduces a few more concepts:    And the simplified HTML used to create it:  &lt;form id=&quot;MagicCarpetSearchBar&quot; action=&quot;/s&quot;&gt; &lt;label class=&quot;_rin72m&quot; for=&quot;magic-carpet-koan-search-bar&quot;&gt;WHERE&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;_1wl3axt0&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; spellcheck=&quot;false&quot; id=&quot;Koan-magic-carpet-koan-search-bar__input&quot; name=&quot;query&quot; placeholder=&quot;Anywhere&quot; value=&quot;&quot; /&gt; &lt;label class=&quot;_rin72m&quot; for=&quot;checkin_input&quot;&gt;CHECK IN&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;_14fdu48d&quot; id=&quot;checkin_input&quot; name=&quot;checkin&quot; placeholder=&quot;dd-mm-yyyy&quot; value=&quot;&quot; readonly=&quot;&quot; /&gt; &lt;label class=&quot;_rin72m&quot; for=&quot;checkout_input&quot;&gt;CHECK OUT&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;_14fdu48d&quot; id=&quot;checkout_input&quot; name=&quot;checkout&quot; placeholder=&quot;dd-mm-yyyy&quot; value=&quot;&quot; readonly=&quot;&quot; /&gt; &lt;label class=&quot;_rin72m&quot; for=&quot;lp-guestpicker&quot;&gt;GUESTS&lt;/label&gt; &lt;button class=&quot;_1nil34o&quot; type=&quot;button&quot;&gt;Guests&lt;/button&gt; &lt;button type=&quot;submit&quot; class=&quot;_2giblnw&quot;&gt;Search&lt;/button&gt; &lt;/form&gt;   This &lt;form&gt; will be submitted to https://www.airbnb.ca/s using the default GETmethod (all form data submitted on the URL's query string) when the submit button is clicked. However, notice how &lt;button&gt;elements have been used instead of &lt;input type=&quot;submit&quot;&gt;. A &lt;button&gt; can be used anywhere in (or outside of) a form where you need to have a clickable widget. Here two &lt;button&gt;s are being used, one to submit the form, the other to provide a custom entry for the number of guests (clicking the drop-down arrow reveals another form).  Something else that's new in this form is the use of new &lt;input&gt; attributes:  autocomplete=&quot;off&quot; - disable autocompleteautocorrect=&quot;off&quot; - an Apple extension to the web, indicating whether to have the browser offer to autocorrect text entered by the userspellcheck=&quot;false&quot; - whether or not the browser should offer to spellcheck the text entered by the user.  Another new attribute has been used on the &lt;input&gt; elements to add placeholder text:  placeholder=&quot;Anywhere&quot; ... placeholder=&quot;dd-mm-yyyy&quot;   A placeholder is a hint provided to the user about what to enter, or the format. It's text is not part of the value, and is not sent to the server. The text is usually rendered in a lighter colour, and will disappear when the user starts typing.  ","version":"Next","tagName":"h3"},{"title":"Form Example 5: Google Translate​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#form-example-5-google-translate","content":" Our next example introduces two more styles of form input controls. Google Translateallows users to enter text in one language and have it get translated by Google's translation service. There are a number of ways to enter text:  free-form text, which can span many linesupload a file to be translated    Here's a simplified version of the HTML used to create this form:  &lt;form id=&quot;gt-form&quot; action=&quot;/&quot; name=&quot;text_form&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; id=&quot;gt-sl&quot; name=&quot;sl&quot; value=&quot;auto&quot; /&gt; &lt;input type=&quot;hidden&quot; id=&quot;gt-tl&quot; name=&quot;tl&quot; value=&quot;es&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;js&quot; value=&quot;y&quot; id=&quot;js&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;prev&quot; value=&quot;_t&quot; id=&quot;prev&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;hl&quot; value=&quot;en&quot; id=&quot;hl&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;ie&quot; value=&quot;UTF-8&quot; /&gt; &lt;textarea id=&quot;source-is&quot; name=&quot;text-is&quot; disabled=&quot;&quot; dir=&quot;ltr&quot; spellcheck=&quot;false&quot; autocapitalize=&quot;off&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; class=&quot;goog-textarea short_text&quot; wrap=&quot;SOFT&quot; &gt;&lt;/textarea&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; size=&quot;40&quot; /&gt; &lt;/form&gt;   Once again, a &lt;form&gt; defines where and how to submit the user's data, and includes various hidden controls that set default values for things like language choice. However, notice that a new enctype has been used: enctype=&quot;multipart/form-data&quot;. This is done because whole files are being included beyond the usual form values.  What's new this time are the inclusion of a &lt;textarea&gt;and &lt;input type=&quot;file&quot;&gt;.  A &lt;textarea&gt; is used to create a multi-line text editing control. In this case it allows us to enter many lines of text. A &lt;textarea&gt; has numerousattributes that can be used to set things like the number of rows or cols (columns) to display, and how to wrap the text--here soft is used to indicate that we want the lines to be broken in the browser, but the text should not include CR+LF end of line pairs.  The &lt;input type=&quot;file&quot;&gt; control allows a user to Browse... for files (or folders) to upload. On the page a file upload control is displayed as a button, which when clicked opens a File dialog box, allowing the user to navigate to their chosen file(s). The files are then &quot;uploaded&quot; to the web page, before being included in the form submission and sent to the server.  ","version":"Next","tagName":"h3"},{"title":"Leverage the Platform: the right control​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#leverage-the-platform-the-right-control","content":" Before we look at styling, and think about custom UI, it's a good idea to remind ourselves about the built-in controls the web platform offers. A textbox is often our first choice, but make sure you pick the most appropriate input control type for the data you're expecting:  &lt;input type=&quot;tel&quot;&gt; - Telephone numbers. On mobile, the keyboard will show a keypad style entry vs. letters.&lt;input type=&quot;url&quot;&gt; - URLs. On mobile, the keyboard will show extra buttons (e.g., .com) to make entering the URL easier. URLs must begin with http:// or another valid scheme.&lt;input type=&quot;email&quot;&gt; - Email Address. On mobile, the keyboard will include keys like @ to make it easier to enter an email address.&lt;input type=&quot;number&quot;&gt; - A Number (integer). On mobile, the keyboard will switch to the number pad.&lt;input type=&quot;range&quot;&gt; - A Number between two values (i.e., range of values) . Gets displayed as a slider, making it easier to switch between values.&lt;input type=&quot;date&quot;&gt;, &lt;input type=&quot;time&quot;&gt;, &lt;input type=&quot;week&quot;&gt;, &lt;input type=&quot;month&quot;&gt;, &lt;input type=&quot;date-local&quot;&gt; - Date/Time values (or portions thereof). Users are provided with special purpose date controls for entering valid dates, times, etc.&lt;input type=&quot;color&quot;&gt; - Colour value. The OS will provide a colour picker control to visually select a colour.  The list goes on, and it's worth familiarizing yourself with everything you can use. Many of these controls have special native rendering, especially on mobile devices.  ","version":"Next","tagName":"h2"},{"title":"Leverage the Platform: give the browser hints for name and autocomplete​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#leverage-the-platform-give-the-browser-hints-for-name-and-autocomplete","content":" Browsers try to autofill common field information for users. As a web developer, you can improve the user experience of your forms by giving the browser hints about the data you're expecting for each form input field.  We do this using standard values for the name=&quot;...&quot; and autocomplete=&quot;...&quot; attributes on a form control. For example, if we needed a username:  &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; autocomplete=&quot;username&quot; /&gt;   Or, if we needed a user's mobile telephone number:  &lt;label for=&quot;mobile-num&quot;&gt;Mobile Number&lt;/label&gt; &lt;input type=&quot;tel&quot; name=&quot;mobile&quot; autocomplete=&quot;tel&quot; id=&quot;mobile-num&quot; /&gt;   There's a long list of standard name/autocomplete values that browsers know about and you should use whenever you want to help the user enter less information.  ","version":"Next","tagName":"h2"},{"title":"Other <input> Attributes​","type":1,"pageTitle":"HTML Forms Introduction","url":"/WebProgrammingPrinciples/Forms-Inputs/HTML-Forms-Introduction#other-input-attributes","content":" We've already seen many attributes that can be used with &lt;input&gt; controls, but there are some other important ones to know about:  autofocus - if present, indicates that the input control should automatically get focused.required - if present, indicates that the input control must have a value before the form can be submitted.tabindex - a number indicating the order in which each control should receive focus when the user press the tab key. This is useful for keyboard navigation, which users to a lot with forms.list - the id of a &lt;datalist&gt; element that provides autocomplete suggestions to be used for the control's value. For example, providing a list of possible courses in a textbox: &lt;input type=&quot;text&quot; list=&quot;subjects&quot; name=&quot;course&quot; /&gt; &lt;datalist id=&quot;subjects&quot;&gt; &lt;option value=&quot;EAC150&quot;&gt;&lt;/option&gt; &lt;option value=&quot;IPC144&quot;&gt;&lt;/option&gt; &lt;option value=&quot;ULI101&quot;&gt;&lt;/option&gt; &lt;option value=&quot;IOS110&quot;&gt;&lt;/option&gt; &lt;/datalist&gt;  ","version":"Next","tagName":"h2"},{"title":"Introduction to JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript","content":"","keywords":"","version":"Next"},{"title":"JavaScript Resources​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-resources","content":" Throughout the coming weeks, we'll make use of a number of important online resources. They are listed here so you can make yourself aware of them, and begin to explore on your own. All programmers, no matter how experienced, have to return to these documents on a routine basis, so it's good to know about them.  JavaScript on MDN JavaScript GuideJavaScript Reference Eloquent JavaScriptJavaScript for impatient programmers (ES2022 edition)  ","version":"Next","tagName":"h2"},{"title":"JavaScript Environments​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-environments","content":" Unlike C, which is compiled to machine code, JavaScript is meant to be run within a host environment. There are many possible environments, but we will focus on the following:  Web Browsers, and their associated developer tools, primarily: Chrome DevToolsFirefox Developer Tools node.js, and its command line REPL (Read-Eval-Print-Loop)  If you haven't done so already, you should install all of the above.  ","version":"Next","tagName":"h2"},{"title":"JavaScript Engines​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-engines","content":" JavaScript is parsed, executed, and managed (i.e., memory, garbage collection, etc) by an engine written in C/C++. There are a number of JavaScript engines available, the most common of which are:  V8, maintained an used by Google in Chrome and in node.jsSpiderMonkey, maintained and used by Mozilla in FirefoxChakraCore, maintained and used by Microsoft in EdgeJavaScriptCore, maintained and used by Apple in Safari  These engines, much like car engines, are meant to be used within a larger context. We will encounter them indirectly via web browsers and in node.js.  It's not important to understand a lot about each of these engines at this point, other than to be aware that each has its own implementation of the ECMAScript standards, its own performance characteristics (i.e., some are faster at certain things), as well as its own set of bugs.  ","version":"Next","tagName":"h3"},{"title":"Running JavaScript Programs​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#running-javascript-programs","content":" JavaScript statements can be stored in an external file with a .js file extension, or embedded within HTML code via the HTML &lt;script&gt; element. As a developer, you also have a number of options for writing and executing JavaScript statements or files:  From the command line via node.js. You'll learn more about node.js in subsequent courses, but we'll also use it sometimes in this course to quickly try test JavaScript expressions, and to run JavaScript programs outside the browser. Using Firefox's Developer Tools, and in particular the Web Console, JavaScript Debugger, and Scratchpad. Using Chrome's DevTools, and in particular the Console and Sources Debugger Finally, we'll eventually write JavaScript that connects with HTML and CSS to create dynamic web pages and applications.  Take some time to install and familiarize yourself with all of the methods listed above.  ","version":"Next","tagName":"h3"},{"title":"JavaScript Syntax​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-syntax","content":" ","version":"Next","tagName":"h2"},{"title":"Recommend Readings​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#recommend-readings","content":" We will spend a month learning JavaScript, and there is no one best way to do it. The more you read and experiment the better. The following chapters/pages give a good overview:  Chapter 1. Basic JavaScript of Exploring JS (ES5).MDN JavaScript Introduction TutorialChapter 1. Values, Types and Operators and Chapter 2. Program Structure of Eloquent JavaScript (2nd Ed.).  Important Ideas​  Like C, JavaScript is Case-Sensitive: customerCount is not the same thing as CustomerCount or customercount Name things using camelCase (first letter lowercase, subsequent words start with uppercase) vs. snake_case. Semicolons are optional in JavaScript, but highly recommended. We'll expect you to use them in this course, and using them will make working in C++, Java, CSS, etc. much easier, since you have to use them there. Comments work like C/C++, and can be single or multi-line  // This is a single line comment. NOTE: the space between the // and first letter. /* This is a multi-line comment, and can be as long as you need. */   Whitespace: JavaScript will mostly ignore whitespace (spaces, tabs, newlines). In this course we will expect you to use good indentation practices, and for your code to be clean and readable. Many web programmers use Prettier to automatically format their code, and we will too:  // This is poorly indented, and needs more whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } } // This is much more readable due to the use of whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } }   JavaScript statements: a JavaScript program typically consists of a series of statements. A statement is a single-line of instruction made up of objects, expressions, variables, and events/event handlers. Block statement: a block statement, or compound statement, is a group of statements that are treated as a single entity and are grouped within curly brackets {...}. Opening and closing braces need to work in pairs. For example, if you use the left brace { to indicate the start of a block, then you must use the right brace } to end it. The same matching pairs applies to single '......' and double &quot;.......&quot; quotes to designate text strings. Functions are one of the primary building blocks of JavaScript. A function defines a subprogram that can be called by other parts of your code. JavaScript treats functions like other built-in types, and they can be stored in variables passed to functions, returned from functions or generated at run-time. Learning how to write code in terms of functions will be one of your primary goals as you get used to JavaScript. Variables are declared using the let keyword. You must use the let keyword to precede a variable name, but you do not need to provide a type, since the initial value will set the type.  JavaScript version note: JavaScript also supports the var and const keywords for variable declaration. We will primarily use let in this course, but be aware of var and const as well, which other developers will use.  let year; let seasonName = 'Fall'; // Referring to and using syntax: year = 2023; console.log(seasonName, year);   JavaScript Variables: variables must start with a letter (a-zA-z), underscore (_), or dollar sign ($). They cannot be a reserved (key) word. Subsequent characters can be letters, numbers, underscores.  NOTE: If you forget to use the let keyword, JavaScript will still allow you to use a variable, and simply create a global variable. We often refer to this as &quot;leaking a global,&quot; and it should always be avoided:  let a = 6; // GOOD: a is declared with let b = 7; // BAD: b is used without declaration, and is now a global   Data Types: JavaScript is a typeless language--you don't need to specify a type for your data (it will be inferred at runtime). However, internally, the following data types are used: Number - a double-precision 64-bit floating point number. Using Number you can work with both Integers and Floats. There are also some special Number types, Infinity and NaN.BigInt - a value that can be too large to be represented by a Number (larger than Number. MAX_SAFE_INTEGER,) can be represented by a BigInt. This can easily be done by appending n to the end of an integer value.String - a sequence of Unicode characters. JavaScript supports both single ('...') and double (&quot;...&quot;) quotes when defining a String.Boolean - a value of true or false. We'll also see how JavaScript supports so-called truthy and falsy values that are not pure Booleans.Object, which includes Function, Array, Date, and many more. - JavaScript supports object-oriented programming, and uses objects and functions as first-class members of the language.Symbol - a primitive type in JavaScript that represents a unique and anonymous value/identifier. They can normally be used as an object's unique properties.null - a value that means &quot;this is intentionally nothing&quot; vs. undefinedundefined - a special value that indicates a value has never been defined.  Declaration\tType\tValuelet s1 = &quot;some text&quot;;\tString\t&quot;some text&quot; let s2 = 'some text';\tString\t&quot;some text&quot; let s3 = '172';\tString\t&quot;172&quot; let s4 = '172' + 4;\tString\t&quot;1724&quot; (concatenation vs. addition) let n1 = 172;\tNumber\t172 (integer) let n2 = 172.45;\tNumber\t172.45 (double-precision float) let n3 = 9007199254740993n;\tBigInt\t9007199254740993n (integer) let b1 = true;\tBoolean\ttrue let b2 = false;\tBoolean\tfalse let b3 = !b2;\tBoolean\ttrue let s = Symbol(&quot;Sym&quot;);\tsymbol\tSymbol(Sym) let c;\tundefined\tundefined let d = null;\tobject\tnull  Consider a simple program from your C course, and how it would look in JavaScript   // Area of a Circle, based on https://scs.senecac.on.ca/~btp100/pages/content/input.html // area.c #include &lt;stdio.h&gt; // for printf int main(void) { const float pi = 3.14159f; // pi is a constant float float radius = 4.2; // radius is a float float area; // area is a float area = pi * radius * radius; // calculate area from radius printf(&quot;Area = %f\\n&quot;, area); // copy area to standard output return 0; }   Now the same program in JavaScript:  const pi = 3.14159; // pi is a Number let radius = 4.2; // radius is a Number let area; // area is (currently) undefined area = pi * radius * radius; // calculate area from radius console.log('Area = ' + area); // print area to the console   We could also have written it like this, using Math.PI, which we'll learn about later:  let radius = 4.2; // radius is a Number let area = Math.PI * radius * radius; // calculate area from radius console.log('Area', area); // print area to the console   Common JavaScript Operators (there are more, but these are a good start):  Operator\tOperation\tExample+\tAddition of Numbers\t3 + 4 +\tConcatenation of Strings\t&quot;Hello &quot; + &quot;World&quot; -\tSubtraction of Numbers\tx - y *\tMultiplication of Numbers\t3 * n /\tDivision of Numbers\t2 / 4 %\tModulo\t7 % 3 (gives 1 remainder) ++\tPost/Pre Increment\tx++, ++x --\tPost/Pre Decrement\tx--, --x =\tAssignment\ta = 6 +=\tAssignment with addition\ta += 7 same as a = a + 7. Can be used to join Strings too -=\tAssignment with subtraction\ta -= 7 same as a = a - 7 *=\tAssignment with multiplication\ta *= 7 same as a = a * 7 /=\tAssignment with division\ta /= 7 same as a = a / 7 &amp;&amp;\tLogical AND\tif(x &gt; 3 &amp;&amp; x &lt; 10) both must be true ()\tCall/Create\t() invokes a function, f() means invoke/call function stored in variable f ||\tLogical OR\tif(x === 3 || x === 10) only one must be true |\tBitwise OR\t3.1345|0 gives 3 as an integer !\tLogical NOT\tif(!(x === 2)) negates an expression ==\tEqual\t1 == 1 but also 1 == &quot;1&quot; due to type coercion ===\tStrict Equal\t1 === 1 but 1 === &quot;1&quot; is not true due to types. Prefer === !=\tNot Equal\t1 != 2, with type coercion !==\tStrict Not Equal\t1 !== &quot;1&quot;. Prefer !== &gt;\tGreater Than\t7 &gt; 3 &gt;=\tGreater Than Or Equal\t7 &gt;=7 and 7 &gt;= 3 &lt;\tLess Than\t3 &lt; 10 &lt;=\tLess Than Or Equal\t3 &lt; 10 and 3 &lt;=3 typeof\tType Of\ttypeof &quot;Hello&quot; gives 'string', typeof 6 gives 'number' cond ? a : b\tTernary\tstatus = (age &gt;= 18) ? 'adult' : 'minor';  JavaScript version note: you may encounter =&gt; in JavaScript code, which looks very similar to &lt;= or &gt;=. If you see =&gt; it is an arrow function, which is new ES6 syntax for declaring a function expression. We will slowly introduce this syntax, especially in later courses.  JavaScript is dynamic, and variables can change value and type at runtime:  let a; // undefined a = 6; // 6, Number a++; // 7, Number a--; // 6, Number a += 3; // 9, Number a = 'Value=' + a; // &quot;Value=9&quot;, String a = !!a; // true, Boolean a = null; // null   JavaScript is a garbage collected language. Unlike C, memory automatically gets freed at runtime when variables are not longer in scope or reachable. We still need to be careful not to leak memory (i.e., hold onto data longer than necessary, or forever) and block the garbage collector from doing its job. Strings: JavaScript doesn't distinguish between a single char and a multi-character String--everything is a String. You define a String using either single ('...'), double (&quot;...&quot;) quotes. Try to pick one style and stick with it within a given file/program vs. mixing them. JavaScript version note: newer versions of ECMAScript also allow for the use of template literals. Instead of ' or &quot;, a template literal uses ` (backticks), and you can also interpolate expressions. A JavaScript expression is any code (e.g., literals, variables, operators, and expressions) that evaluates to a single value. The value may be a Number, String, an Object, or a logical value.  let a = 10 / 2; // arithmetic expression let b = !(10 / 2); // logical expression evaluates to false let c = '10 ' + '/' + ' 2'; // string, evaluates to &quot;10 / 2&quot; let f = function () { return 10 / 2; }; // function expression, f can now be called via the () operator let d = f(); // f() evaluates to 10/2, or the Number 5   JavaScript execution flow is determined using the following four (4) basic control structures: Sequential: an instruction is executed when the previous one is finished.Conditional: a logical condition is used to determine which instruction will be executed next - similar to the if and switch statements in C (which JavaScript also has).Looping: a series of instructions are repeatedly executed until some condition is satisfied - similar to the for and while statements in C (which JavaScript also has). There are many different types of loops in JavaScript: for example for loops and while loops, as well as ways to break out of loops or skip iterations with continue. We'll cover other types as we learn about Object and Array.Transfer: jump to, or invoke a different part of the code - similar to calling a function in C.  /** * 1. Sequence example: each statement is executed one after the other **/ let a = 3; let b = 6; let c = a + b; /** * 2. Conditional examples: a decision is made based on the evaluation of an expression, * and a code path (or branch) taken. **/ let grade; let mark = 86; if (mark &gt;= 90) { grade = 'A+'; } else if (mark &gt;= 80) { grade = 'A'; } else if (mark &gt;= 70) { grade = 'B'; } else if (mark &gt;= 60) { grade = 'C'; } else if (mark &gt;= 50) { grade = 'D'; } else { grade = 'F'; } switch (grade) { case 'A+': // do these steps if grade is A+ break; case 'A': // do these steps if grade is A break; case 'B': // do these steps if grade is B break; case 'C': // do these steps if grade is C break; case 'D': // do these steps if grade is D break; default: // do these steps in any other case break; } /** * 3. Looping example: a set of statements are repeated **/ let total = 0; for (let i = 1; i &lt; 11; i++) { total += i; console.log('i', i, 'total', total); } /** * 4. Transfer example: a set of statements are repeated **/ function add(a, b) { // declaring the add function if (!b) { // check if the b argument exists/has a value return a; // if not, simply return the value of argument a } return a + b; // otherwise, return the two arguments added together } let total; total = add(56); // invoking the add function with a single argument total = add(total, 92); // invoking the add function with two arguments  ","version":"Next","tagName":"h3"},{"title":"AJAX Fundamentals","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/AJAX-Fundamentals","content":"","keywords":"","version":"Next"},{"title":"AJAX​","type":1,"pageTitle":"AJAX Fundamentals","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/AJAX-Fundamentals#ajax","content":" AJAX is a term coined in 2005 by Jesse James Garrett that refers to an approach to web development that uses dynamic requests to a server to update portions of a page at runtime. Today, the method is so common that it's hard to talk about it not existing. But at the time, it was a game changer.  AJAX stands for Asynchronous JavaScript and XML, which is based on a group of web technologies: HTML (and at the time XHTML), CSS, JavaScript, the DOM, XML, JSON, and a web API called XMLHttpRequest, or just XHR for short.  Before 2005, web browsers lacked a lot of the modern features we take for granted today. Web servers were used to build and serve all (or most) aspects of a web page. Making changes on the page meant a full request/response trip to and from the server, in order to update content. The entire page had to be reloaded for anything of significance to change.  Today we expect &quot;real-time&quot; data to be a part of our web browsing experience. Consider a site like GMail or Google Maps. If we want to see messages in another folder, or navigate to another city, we expect to be able to do that without having to reload the entire page. AJAX makes this possible.  Instead of modifying the entire page (DOM), we instead make background requests for data from servers, and then use that data to update the page's contents live via the DOM's APIs.  ","version":"Next","tagName":"h2"},{"title":"Understanding AJAX's \"A\" (Asynchronous) and \"J\" (JavaScript)​","type":1,"pageTitle":"AJAX Fundamentals","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/AJAX-Fundamentals#understanding-ajaxs-a-asynchronous-and-j-javascript","content":" As we know from previous discussions, web browsers use HTTP/HTTPS to send requests to web servers, which build replies and send back responses (HTML, CSS, images, fonts, JavaScript, etc).  While we don't want to have to reload the entire page in order to get updates from the server, we would like to be able to leverage this communication pattern from within the running page: we need a way to make HTTP requests, wait for responses from the server, and then do something with the data.  Browsers provide a mechanism for doing this in the form of the XMLHttpRequestObject, or XHR for short. An XHR object let's us create and send HTTP requests to a server, and get back data responses in various forms (XML, HTML, JSON, text, binary, etc.)  Our XHR requests happen in the background, asynchronously (without blocking the main UI thread in the browser), so user's can continue to work and interact with the page while we wait for a response.  Finally, we work with XHR via JavaScript code. Let's look at a very basic example:  // 1. Create a new instance of an XMLHttpRequest Object using its constructor var xhr = new XMLHttpRequest(); // 2. Define an event handler for the `load` event, which happens when data arrives xhr.onload = function () { // 3. Get the data from the `xhr` object's `responseText` property var data = this.responseText; console.log('data arrived', data); }; // 4. Create an HTTP GET request to the given URL xhr.open('GET', 'http://example.com'); // 5. Send the HTTP request to the server, and wait asynchronously for the reply xhr.send();   ","version":"Next","tagName":"h2"},{"title":"Example 1: Current Bitcoin Value in USD​","type":1,"pageTitle":"AJAX Fundamentals","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/AJAX-Fundamentals#example-1-current-bitcoin-value-in-usd","content":" To demonstrate a real-world example of what we've been discussing, let's build a simple example. Imagine we want to create a web page that includes information about the current market value of Bitcoin, the most famous of the blockchain-based cryptocurrencies.  The website https://www.blockchain.com provides a number of web services we can use to get this information. In particular, we'll use https://blockchain.info/q/24hrprice, which gives the price in US dollars over the past 24 hours.  Here's an (simplified) example of what it sends when we make an HTTP request:  HTTP/2 200 date: Sun, 02 Dec 2018 22:48:35 GMT content-type: text/plain; charset=utf-8 4200.82   In the above response, we have HTTP headers, a blank line, and then the data: 4200.82.  We want our web page to include this information, but then automatically update it every minute by requesting the current value again over HTTP. Here's one way we could do it.  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Bitcoin Value&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Current Bitcoin value: &lt;span id=&quot;bitcoin-value&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;script&gt; function updateBitcoinValue(newValue) { // Update the &lt;span&gt; with the new value we get from the server var span = document.querySelector('#bitcoin-value'); span.innerHTML = newValue; // Every minute, get the new value and update the page var oneMinute = 60 * 1000; setTimeout(getCurrentValue, oneMinute); } function getCurrentValue() { var xhr = new XMLHttpRequest(); var url = 'https://blockchain.info/q/24hrprice?cors=true'; // If/When the request returns successfully, get the value and update DOM xhr.onload = function () { // Format the raw text we get from the server into a currency string var response = this.responseText; var currentValue = `${response} (USD)`; updateBitcoinValue(currentValue); }; // If the request fails, and we get an error, update the page with an error message xhr.onerror = function (e) { updateBitcoinValue('unknown (error, unable to get current value)'); }; // Open a GET request to the Blockchain API xhr.open('GET', url); // Send our HTTP request to the server, and wait for a response xhr.send(); } window.onload = function () { getCurrentValue(); }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;   By separating the data into a separate web service, it's possible for various applications to all share it, and use it in different ways.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"AJAX Fundamentals","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/AJAX-Fundamentals#suggested-readings","content":" AJAX GuideWorking with JSONUsing XMLHttpRequest ","version":"Next","tagName":"h2"},{"title":"Data Formats","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats","content":"","keywords":"","version":"Next"},{"title":"Working with Data: JSON and XML​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#working-with-data-json-and-xml","content":" Our previous example used a very simple data format: a single number. Often we'll need to work with more complex data, which includes both numbers and text, lists, and complex hierarchies. To do this, we need a format that allows us to serialize (i.e., turn into strings) data structures like Arrays, Objects, etc.  The two most popular formats for data exchange on the internet are theJavaScript Object Notation (JSON) and theExtensible Markup Language (XML).  We're going to focus mainly on JSON, but it's good to also know about XML. At one point, a lot of the techniques we will discuss were done with XML (and many languages and services still use it). However, much of the internet has standardized on JSON as a data exchange format.  Let's look at each in turn. First, consider the following food product data:  1) Name: Apple Price per Pound: $1.29 Location: Aisle 3 2) Name: Carrots Price per Pound: $0.46 Location: Aisle 2   Here's how that data might look using XML:  &lt;products&gt; &lt;product&gt; &lt;name&gt;Apple&lt;/name&gt; &lt;price currency=&quot;CAD&quot;&gt;1.29&lt;/price&gt; &lt;aisle&gt;3&lt;/aisle&gt; &lt;/product&gt; &lt;product&gt; &lt;name&gt;Carrots&lt;/name&gt; &lt;price currency=&quot;CAD&quot;&gt;0.46&lt;/price&gt; &lt;aisle&gt;2&lt;/aisle&gt; &lt;/product&gt; &lt;/products&gt;   Look familiar? XML and HTML are both markup languages. In XML, it's possible for us to create our own tags and document structure (i.e., XML Schema). You can think of HTML like an instance of XML, which is what XHTML was trying to do.  Before we look at JSON, let's look at that same data in JavaScript, using an Object Literal:  var products = [ { name: 'Apple', price: { currency: 'CAD', value: 1.29, }, aisle: 3, }, { name: 'Carrots', price: { currency: 'CAD', value: 0.46, }, aisle: 2, }, ];   Here we have two Objects in an Array. Our Objects use String, Object, and Number types to represent the data.  Finally, let's format the same data in JSON:  [ { &quot;name&quot;: &quot;Apple&quot;, &quot;price&quot;: { &quot;currency&quot;: &quot;CAD&quot;, &quot;value&quot;: 1.29 }, &quot;aisle&quot;: 3 }, { &quot;name&quot;: &quot;Carrots&quot;, &quot;price&quot;: { &quot;currency&quot;: &quot;CAD&quot;, &quot;value&quot;: 0.46 }, &quot;aisle&quot;: 2 } ]   Looks familiar, doesn't it? You'll be glad to know that since you already learned JavaScript Object Literals, you already learned 95% of JSON format at the same time.  JSON and JavaScript Object Literals are very similar, but there are some differences. JSON is a subset of JavaScript Object Literal notation:  All keys must be double-quoted strings: &quot;key&quot; vs. keyYou don't put comments in JSONYou can't include function expressions in JSON, only data types: StringNumberan (JSON) Objectan Arrayboolean true or falsethe value null  JavaScript includes built-in code for converting to/from JSON strings:  var products = [ { name: 'Apple', price: { currency: 'CAD', value: 1.29, }, aisle: 3, }, { name: 'Carrots', price: { currency: 'CAD', value: 0.46, }, aisle: 2, }, ]; // 1. Turn products Object into JSON string var json = JSON.stringify(products); // json now equals '[{&quot;name&quot;:&quot;Apple&quot;,&quot;price&quot;:{&quot;currency&quot;:&quot;CAD&quot;,&quot;value&quot;:1.29},&quot;aisle&quot;:3},{&quot;name&quot;:&quot;Carrots&quot;,&quot;price&quot;:{&quot;currency&quot;:&quot;CAD&quot;,&quot;value&quot;:0.46},&quot;aisle&quot;:2}]' // 2. Turn JSON string back into a JS Object products = JSON.parse(json); // products is now an Object   NOTE: JSON.parse() will throw an error if the string isn't properly formatted JSON, so it's good to wrap your call in a try...catch block.  ","version":"Next","tagName":"h2"},{"title":"Example 2: the Dog API​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#example-2-the-dog-api","content":" For our next example, let's work with another web service, but this time one that returns more complex data in the form of JSON.  The Dog API is a free web service that uses data from the Stanford Dogs Dataset. This dataset contains images and information about 120 breeds of dogs, and is used for machine learning and artificial intelligence training.  There are a number of endpoints we can use with this API, but we'll focus on these:  https://dog.ceo/api/breeds/list/all - get a JSON formatted list of all breeds and sub-breedshttps://dog.ceo/api/breed/hound/images/random/3 - get a JSON formatted list of image URLs for hounds, returning 3 (we can ask for more or less) In other words the URL works like this: https://dog.ceo/api/breed/{name-of-breed}/random/{number-of-images-to-return}  Our goal is to do the following:  Create a simple web page with an HTML &lt;form&gt;Use AJAX techniques to dynamically load all dog breeds into a &lt;select&gt; in our formUsers can specify how many images they want to load: 1 to 100.When the user selects a breed and clicks a &lt;button&gt;, we'll request the JSON list of imagesOnce we get the list of image URLs, we'll start creating &lt;img&gt; elements in our page to show those dogs  See the completed code in dogs.zip. We'll discuss snippets of the code below.  ","version":"Next","tagName":"h2"},{"title":"1. Create a form​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#1-create-a-form","content":" Let's start with a basic &lt;form&gt;:  &lt;form id=&quot;dogs-form&quot; action=&quot;#&quot;&gt; &lt;select id=&quot;breeds&quot; name=&quot;breeds&quot;&gt;&lt;/select&gt; &lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;100&quot; value=&quot;5&quot; /&gt; &lt;input type=&quot;button&quot; id=&quot;btn-load&quot; value=&quot;Show me dogs!&quot; /&gt; &lt;/form&gt;   Our form is very simple. Notice that it contains no &lt;option&gt; elements for the dog breeds. We will load these dynamically once the page is loaded. We include a textbox for entering a number of images to show (default is 5), and provide a &lt;button&gt; to click.  ","version":"Next","tagName":"h3"},{"title":"2. Dynamically load dog breeds into a drop-down​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#2-dynamically-load-dog-breeds-into-a-drop-down","content":" Next we need to load our dog breeds from the Dogs API. We'll do that when the page finishes loading, and the DOM is fully created:  window.onload = function () { loadDogBreeds(); };   Our loadDogBreeds function needs to create an XHR request to the Dogs API, and parse the JSON we get back:  function loadDogBreeds() { // See https://dog.ceo/dog-api/documentation/ var url = 'https://dog.ceo/api/breeds/list/all'; var xhr = new XMLHttpRequest(); xhr.onload = function () { var response = JSON.parse(this.responseText); var breedList = extractBreedList(response); updateBreedList(breedList); }; xhr.open('GET', url); xhr.send(); }   When our request comes back (i.e., xhr.onload), we'll get a JSON string that looks something like this:  &quot;{&quot;status&quot;:&quot;success&quot;,&quot;message&quot;:{&quot;affenpinscher&quot;:[],&quot;african&quot;:[],&quot;airedale&quot;:[],&quot;akita&quot;:[],&quot;appenzeller&quot;:[]}}&quot;;   If we JSON.parse() that string, we'll get an Object that looks like this:  var response = JSON.parse(this.responseText); /* { status: &quot;success&quot;, message: { affenpinscher: [], african: [], airedale: [], akita: [], appenzeller: [], ... } } */   This data has two main parts:  a status message, that tells us the server was successful in doing our querya message body, which is itself an Object of key/value pairs, with the breed name and sub-breeds (if any) in an Array.  To get all the dog breeds as a list (i.e. Array), we need to extract themessage property, then call Object.keys()on its value to create an Array out of all the names:  var breedList = Object.keys(response); /* ['affenpinscher', 'african', 'airedale', 'akita', 'appenzeller', ...] */   Next we need to take this list of breed name Strings, and create&lt;option&gt; elements that we can dynamically add to our form's &lt;select&gt;:  // Get a reference to our &lt;select&gt; var select = document.querySelector('#breeds'); // Given a breed name &quot;beagle&quot;, return an &lt;option value=&quot;beagle&gt;beagle&lt;/option&gt; function createBreedOption(name) { var option = document.createElement('option'); option.value = name; option.innerHTML = name; return option; } // Loop through each breed name in our Array, call createBreedOption() // and append the &lt;option&gt; element to our &lt;select&gt; breedList.forEach(function (breed) { var breedOption = createBreedOption(breed); select.appendChild(breedOption); });   Our web page now has a drop-down list with all 120 dog breeds.  ","version":"Next","tagName":"h3"},{"title":"3. Get dog breed image URLs when the user selects a breed​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#3-get-dog-breed-image-urls-when-the-user-selects-a-breed","content":" When the user selects a breed from our list and clicks a &lt;button&gt;, we need to make another HTTP request to the server. This time we need to get a list of image URLs for the chosen breed.  First, we need an event handler for the click:  var btnLoad = document.querySelector('#btn-load'); btnLoad.onclick = function (e) { var breed = document.querySelector('#breeds').value; loadBreedImages(breed); };   Our loadBreedImages function is nearly identical to loadDogBreeds, but we use the breed name as part of the URL:  function loadBreedImages(breed) { // See https://dog.ceo/dog-api/documentation/breed // Use the imageCount and breed variables to create our URL var imageCount = document.querySelector('#image-count').value; var url = `https://dog.ceo/api/breed/${breed}/images/random/${imageCount}`; var xhr = new XMLHttpRequest(); xhr.onload = function () { try { var response = JSON.parse(this.responseText); var breedImageList = extractBreedImageList(response); updateBreedImages(breedImageList); } catch (e) { showError('Unable to load dog breeds'); } }; xhr.open('GET', url); xhr.send(); }   As before, we make a request to the server, and get back JSON, which we parse. The resulting Object we get back looks like this:  { status: &quot;success&quot;, message: [ &quot;https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg&quot;, &quot;https://images.dog.ceo/breeds/hound-afghan/n02088094_1007.jpg&quot;, ... ] }   Once again we get a status and a message body. This time, however, the message is already an Array of URLs.  ","version":"Next","tagName":"h3"},{"title":"4. Dynamically create <img> elements for all dog breed image URLs​","type":1,"pageTitle":"Data Formats","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/Data-Formats#4-dynamically-create-img-elements-for-all-dog-breed-image-urls","content":" Using the list of URLs for dog breed images from the server, we can easily update our page to display new images:  var imagesContainer = document.querySelector('#images-container'); // Clear the imagesContainer if there is anything there now imagesContainer.innerHTML = ''; // Turn a url String into an &lt;img src=&quot;url&quot;&gt; element function createImgElement(url) { var img = document.createElement('img'); img.src = url; return img; } // Loop through the image URLs, and create new &lt;img&gt; elements breedImageList.forEach(function (url) { var img = createImgElement(url); imagesContainer.appendChild(img); });   We've now got a relatively simple page that can be changed using live data to look completely different, depending on the needs of the user. We didn't have to write HTML for every image, which would have involved hand-writing 120 * 150 = 18,000 &lt;img&gt; elements! Using AJAX we can do this with very little code.  Complete code for the example above can be found in the following file: dogs.zip. ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Introduction","content":"Introduction In languages like C, we are used to thinking about data types separately from the functions that operate upon them. We declare variables to hold data in memory, and call functions passing them variables as arguments to operate on their values. In object-oriented languages like JavaScript, we are able to combine data and functionality into higher order types, which both contain data and allow us to work with that data. In other words, we can pass data around in a program, and all the functionality that works on that data travels with it. Let's consider this idea by looking at strings in C vs. JavaScript. In C a string is a null terminated (\\0) array of char elements, for example: const char name1[31] = &quot;My name is Arnold&quot;; const char name2[31] = {'M','y',' ','n','a','m','e',' ','i','s',' ','A','r','n','o','l','d','\\0'}; With C-style strings, we perform operations using standard library functions, for example string.h: #include &lt;string.h&gt; int main(void) { char str[31]; // declare a string ... strlen(str); // find the length of a string str strcpy(str2, str); // copy a string strcmp(str2, str); // compare two strings strcat(str, &quot;...&quot;); // concatenate a string with another string } JavaScript also allows us to work with strings, but because JavaScript is an object-oriented language, a JavaScript String is an Object with various properties and methods we can use for working with text. One way to think about Objects like String is to imagine combining a C-string's data type with the functions that operate on that data. Instead of needing to specify which string we want to work with, all functions would operate a particular instance of a string. Another way to look at this would be to imagine that the data and the functions for working with that data are combined into one more powerful type. If we could do this in C, we would be able to write code that looked more like this: String str = &quot;Hello&quot;; // declare a string int len = str.len; // get the length of str str.cmp(str2); // compare str and str2 str = str.cat(&quot;...&quot;); // concatenate &quot;...&quot; onto str In the made-up code above, the data (str) is attached to functionality that we can call via the .* notation. Using str.*, we no longer need to indicate to the functions which string to work with: all string functions work on the string data to which they are attached. This is very much how String and other Object types work in JavaScript. By combining the string character data and functionality into one type (i.e., a String), we can easily create and work with text in our programs. Also, because we work with strings at a higher level of abstraction (i.e., not as arrays of char), JavaScript deals with memory management for us, allowing our strings to grow or shrink at runtime.","keywords":"","version":"Next"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises","content":"","keywords":"","version":"Next"},{"title":"A Larger Problem Combining Everything:​","type":1,"pageTitle":"Practice Exercises","url":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises#a-larger-problem-combining-everything","content":" You are asked to write JavaScript code to process a String which is in the form of a Comma-Separated Values (CSV) formatted data dump of user information. The data might look something like this:  0134134,John Smith,555-567-2341,62 inches 0134135 , June Lee , 5554126347 , 149 cm 0134136, Kim Thomas , 5324126347, 138cm`   Write a series of functions to accomplish the following, building a larger program as you go. You can begin with exercise.js:  Split the string into an Array of separate rows (i.e., an Array with rows separated by \\n). Bonus: how could we deal with data that includes both Unix (\\n) and Windows (\\r\\n) line endings? Each row contains information user info: ID, Name, Phone Number, and Height info all separated by commas. Split each row into an Array with all of its different fields. You need to deal with extra and/or no whitespace between the commas. Get rid of any extra spaces around the Name field Using a RegExp, extract the Area Code from the Phone Number field. All Phone Numbers are in one of two formats: &quot;555-555-5555&quot; or &quot;5555555555&quot;. Check if the Height field has &quot;cm&quot; at the end. If it does, strip that out, convert the number to inches, and turn it into a String in the form &quot;xx inches&quot;. For example: &quot;152 cm&quot; should become &quot;59 inches&quot;. After doing all of the above steps, create a new record with ID, Name, Area Code, Height In Inches and separate them with commas Combine all these processed records into a new CSV formatted string, with rows separated by \\n.  A sample solution is provided in solution.js. ","version":"Next","tagName":"h2"},{"title":"Arrays","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays","content":"","keywords":"","version":"Next"},{"title":"Declaring JavaScript Arrays​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#declaring-javascript-arrays","content":" Like creating a String, we can create an Array in JavaScript using either a literal or the Array constructor function:  let arr = new Array(1, 2, 3); // array constructor let arr2 = [1, 2, 3]; // array literal   Like arrays in C, a JavaScript Array has a length, and items contained within it can be accessed via an index:  let arr = [1, 2, 3]; let len = arr.length; // len is 3 let item0 = arr[0]; // item0 is 1   Unlike languages such as C, a JavaScript Array can contain any type of data, including mixed types:  let list = [0, '1', 'two', true];   JavaScript Arrays can also contain holes (i.e., be missing certain elements), change size dynamically at runtime, and we don't need to specify an initial size:  let arr = []; // empty array arr[5] = 56; // element 5 now contains 56, and arr's length is now 6   NOTE: a JavaScript Array is really a map, which is a data structure that associates values with unique keys (often called a key-value pair). JavaScript arrays are a special kind of map that uses numbers for the keys, which makes them look and behave very much like arrays in other languages. We will encounter this map structure again when we look at how to create Objects.  ","version":"Next","tagName":"h2"},{"title":"Accessing Elements in an Array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#accessing-elements-in-an-array","content":" Like arrays in C, we can use index notation to obtain an element at a given index:  let numbers = [50, 12, 135]; let firstNumber = numbers[0]; let lastNumber = numbers[numbers.length - 1];   JavaScript also allows us to use a technique called Destructuring Assignment to unpack values in an Array (or Object, see below) into distinct variables. Consider each of the following methods, both of which accomplish the same goal:  // Co-ordinates for Seneca's Newnham Campus let position = [43.796, -79.3486]; // Separate the two values into their own unique variables. // Version 1 - index notation let lat = position[0]; let lng = position[1]; // Version 2 - destructure let [lat, lng] = position;   This technique is useful when working with structured data, where you know exactly how many elements are in an array, and need to access them:  let dateString = `17/02/2001`; let [day, month, year] = dateString.split('/'); console.log(`The day is ${day}, month is ${month}, and year is ${year}`);   Here we .split() the string '17/02/2001' at the '/' character, which will produce the Array ['17', '02', '2001']. Next, we destructure this Array's values into the variables day, month, year.  You can also ignore values (i.e., only unpack the one or ones you want):  let dateString = `17/02/2001`; // Ignore the first index in the array, unpack only position 1 and 2 let [, month, year] = dateString.split('/'); console.log(`The month is ${month}, and year is ${year}`); let emailAddress = `jsmith@myseneca.ca`; // Only unpack the first position, ignoring the second let [username] = emailAddress.split('@'); console.log(`The username for ${emailAddress} is ${username}`);   ","version":"Next","tagName":"h2"},{"title":"Array Properties and Methods​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#array-properties-and-methods","content":" arr.length - a property that tells us the number of elements in the array.  ","version":"Next","tagName":"h2"},{"title":"Methods that modify the original array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-that-modify-the-original-array","content":" arr.push(element) - a method to add one (or more) element(s) to the end of the array. Using push() modifies the array (increasing its size). You can also use arr.unshift(element) to add one (or more) element to the start of the array.arr.pop() - a method to remove the last element in the array and return it. Using pop() modifies the array (reducing its size). You can also use arr.shift() to remove the first element in the array and return it.  ","version":"Next","tagName":"h3"},{"title":"Methods that do not modify the original array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-that-do-not-modify-the-original-array","content":" arr.concat([4, 5], 6) - returns a new array with the original array joined together with other arrays or values provided.arr.includes(element) - returns true if the array includes the given element, otherwise false.arr.indexOf(element) - returns the index of the given element in the array, if it exists, otherwise -1 (meaning not found).arr.join(&quot;\\n&quot;) - returns a string created by joining (concatenating) all elements in the array with the given delimiter (String).  ","version":"Next","tagName":"h3"},{"title":"Methods for iterating across the elements in an Array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-for-iterating-across-the-elements-in-an-array","content":" JavaScript's Array type also provides a long list of useful methods for working with list data. All of these methods work in roughly the same way:  // Define an Array let list = [1, 2, 3, 4]; // Define a function that you want to call on each element of the array function operation(element) { // do something with element... } // Call the Array method that you want, passing your function operation list.arrayOperation(operation);   JavaScript will call the given function on every element in the array, one after the other. Using these methods, we are able to work with the elements in an Array instead of only being able to do things with the Array itself.  As a simple example, let's copy our list Array and add 3 to every element. We'll do it once with a for-loop, and the second time with the forEach() method:  // Create a new Array that adds 3 to every item in list, using a for-loop let listCopy = []; for (let i = 0; i &lt; list.length; i++) { let element = list[i]; element += 3; listCopy.push(element); }   Now the same code using the Array's forEach() method:  let listCopy = []; list.forEach(function (element) { listCopy.push(element + 3); });   We've been able to get rid of all the indexing code, and with it, the chance for off-by-one errors. We also don't have to write code to get the element out of the list: we just use the variable passed to our function.  These Array methods are so powerful that there are often functions that do exactly what we need. For example, we could shorten our code above even further but using the map() method. The map() method takes one Array, and calls a function on every element, creating and returning a new Array with those elements:  let listCopy = list.map(function (element) { return element + 3; });   Here are some of the Array methods you should work on learning:  arr.forEach() - calls the provided function on each element in the array.arr.map() - creates and returns a new array constructed by calling the provided function on each element of the original array.arr.find() - finds and returns an element from the array which matches a condition you define. See also arr.findLast(), arr.findIndex(), and arr.findLastIndex(), which all work in similar ways.arr.filter() - creates and returns a new array containing only those elements that match a condition you define in your function.arr.every() - returns true if all of the elements in the array meet a condition you define in your function.  There are more Array methods you can learn as you progress with JavaScript, but these will get you started.  ","version":"Next","tagName":"h3"},{"title":"Iterating over String, Array, and other collections​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#iterating-over-string-array-and-other-collections","content":" The most familiar way to iterate over a String or Array works as you'd expect:  let s = 'Hello World!'; for (let i = 0; i &lt; s.length; i++) { let char = s.charAt(i); console.log(i, char); // Prints: // 0, H // 1, e // 2, l // ... } let arr = [10, 20, 30, 40]; for (let i = 0; i &lt; arr.length; i++) { let elem = arr[i]; console.log(i, elem); // Prints: // 0, 10 // 1, 20 // 2, 30 // ... }   The standard for loop works, but is not the best we can do. Using a for loop is prone to various types of errors: off-by-one errors, for example. It also requires extra code to convert an index counter into an element.  An alternative approach is available in ES6, for...of:  let s = 'Hello World!'; for (let char of s) { console.log(char); // Prints: // H // e // l // ... } let arr = [10, 20, 30, 40]; for (let elem of arr) { console.log(elem); // Prints: // 10 // 20 // 30 // ... }   Using for...of we eliminate the need for a loop counter altogether, which has the added benefit that we'll never under- or over- shoot our collection's element list; we'll always loop across exactly the right number of elements within the given collection.  The for...of loop works with all collection types, from String to Array toarguments to NodeList (as well as newer collection types likeMap,Set, etc.). ","version":"Next","tagName":"h2"},{"title":"Learning resources","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Resources/learning-resources","content":"","keywords":"","version":"Next"},{"title":"Mozilla Developer Network (MDN)​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingPrinciples/Resources/learning-resources#mozilla-developer-network-mdn","content":" Mozilla Developer Network (MDN) Learn Web DevelopmentHTML Element ReferenceCSS ReferenceJavaScript ReferenceDOM Document Reference  ","version":"Next","tagName":"h2"},{"title":"Online Books (free)​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingPrinciples/Resources/learning-resources#online-books-free","content":" Eloquent JavaScriptExploring JavaScript (es5)Exploring ES6  ","version":"Next","tagName":"h2"},{"title":"Software​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingPrinciples/Resources/learning-resources#software","content":" FirefoxChromeVisual Studio Codenode.js  ","version":"Next","tagName":"h2"},{"title":"Tools​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingPrinciples/Resources/learning-resources#tools","content":" Firefox Developer ToolsChrome DevToolsW3C Markup ValidatorW3C CSS ValidatorPrettier Source Code FormatterESlint JavaScript Linter  ","version":"Next","tagName":"h2"},{"title":"Online Web Code Tools​","type":1,"pageTitle":"Learning resources","url":"/WebProgrammingPrinciples/Resources/learning-resources#online-web-code-tools","content":" JSFiddleCodePenJS BinGlitch ","version":"Next","tagName":"h2"},{"title":"Strings","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Strings","content":"","keywords":"","version":"Next"},{"title":"String Properties and Methods​","type":1,"pageTitle":"Strings","url":"/WebProgrammingPrinciples/Objects-Built-ins/Strings#string-properties-and-methods","content":" s.length - will tell us the length of the string (UTF-16 code units)s.charAt(1) - returns the character at the given position (UTF-16 code unit). We can also use s[1] and use an index notation to get a particular character from the string.s.concat() - returns a new string created by concatenating the original with the given arguments.s.padStart(2, '0) - returns a new string padded with the given substring until the length meets the minimum length given. See also s.padEnd().s.includes(&quot;tex&quot;) - returns true if the search string is found within the string, otherwise false if not found.s.startsWith(&quot;some&quot;) - returns true if the string starts with the given substring, otherwise false.s.endsWith(&quot;text&quot;) - returns true if the string ends with the given substring, otherwise false.s.indexOf(&quot;t&quot;) - returns the first index position of the given substring within s, or -1 if the substring is not found within s. See also s.lastIndexOf()s.match(regex) - tries to match a regular expression against the string, returning the matches. See discussion of RegExp below.s.replace(regex, &quot;replacement&quot;) - returns a new string with the first occurrence of a matched RegExp replaced by the replacement text. See also s.replaceAll(), which replaces all occurrences.s.slice(2, 3) - returns a new string extracted (sliced) from within the original string. A beginning index and (optional) end index mark the position of the slice.s.split() - returns an Array (see discussion below) of substrings by splitting the original string based on the given separator (String or RegExp).s.toLowerCase() - returns a new string with all characters converted to lower case.s.toUpperCase() - returns a new string with all characters converted to upper case.s.trim() - returns a new string with leading and trailing whitespace removed.  JavaScript Version Note: modern JavaScript also supports template literals, also sometimes called template strings. Template literals use back-ticks instead of single- or double-quotes, and allow you to interpolate JavaScript expressions. For example:  let a = 1; let s = 'The value is ' + 1 * 6; // Use ${...} to interpolate the value of an expression into a string let templateVersion = `The value is ${1 * 6}`;  ","version":"Next","tagName":"h2"},{"title":"RegExp","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp","content":"","keywords":"","version":"Next"},{"title":"Declaring JavaScript RegExp​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#declaring-javascript-regexp","content":" Like String or Array, we can declare a RegExp using either a literal or the RegExp constructor:  let regex = /colou?r/; // regex literal uses /.../ let regex2 = new RegExp('colou?r');   Regular expressions can also have advanced search flags, which indicate how the search is supposed to be performed. These flags include g (globally match all occurrences vs. only matching once),i (ignore case when matching), and m (match across line breaks, multi-line matching) among others.  let regex = /pattern/gi; // find all matches (global) and ignore case let regex2 = new RegExp('pattern', 'gi'); // same thing using the constructor instead   ","version":"Next","tagName":"h2"},{"title":"Understanding Regular Expression Patterns​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#understanding-regular-expression-patterns","content":" Regular expressions are dense, and often easier to write than to read. It's helpful to use various tools to help you as you experiment with patterns, and try to understand and debug your own regular expressions:  regexr.comRegulexregexpal.com  ","version":"Next","tagName":"h2"},{"title":"Matching Specific Characters​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#matching-specific-characters","content":" \\ ^ $ . * + ? ( ) [ ] { } | all have special meaning, and if you need to match them, you have to escape them with a leading \\. For example: \\$ to match a $. Any other character will match itself. abc is a valid regular expression and means match the letters abc. The . means any character. For example a. would match ab, a3, or a&quot;. If you need to match the . itself, make sure you escape it: .\\. means a period followed by any character We specify a set of possible characters using []. For example, if we wanted to match any vowel, we might do [aeiou]. This says match any of the letters a, e, i, o, or u and would match a but not t. We can also do the opposite, and define a negated set: [^aeiou] would match anything that is not a vowel. With regular expressions, it can often be easier to define your patterns in terms of what they are not instead of what they are, since so many things are valid vs. a limited set of things that are not. We can also specify a range, [a-d] would match any of a, b, c, d but not f, g or h. Some sets are so common that we have shorthand notation. Consider the set of single digit numbers, [0123456789]. We can instead use \\d which means the same thing. The inverse is \\D (capital D), and means [^0123456789] (i.e., not one of the digits). If we wanted to match a number with three digits, we could use \\d\\d\\d, which would match 123 or 678 or 000. Another commonly needed pattern is any letter or number and is available with \\w, meaning [A-Za-z0-9_] (all upper- and lower-case letters, digits 0 to 9, and the underscore). The inverse is available as \\W and means [^A-Za-z0-9_] (everything not in the set of letters, numbers and underscore). Often we need to match blank whitespace (spaces, tabs, newlines, etc.). We can do that with \\s, and the inverse \\S (anything not a whitespace). For example, suppose we wanted to allow users to enter an id number with or without a space: \\d\\d\\d\\s?\\d\\d\\d would match both 123456 and 123 456. There are lots of other examples of pre-defined common patterns, such as \\n (newline), \\r (carriage return), \\t (tab). Consult the MDN documentation for character classes to lookup others.  ","version":"Next","tagName":"h3"},{"title":"Define Character Matching Repetition​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#define-character-matching-repetition","content":" In addition to matching a single character or character class, we can also match sequences of them, and define how many times a pattern or match can/must occur. We do this by adding extra informationafter our match pattern.  ? is used to indicate that we want to match something once or none. For example, if we want to match the word dog without an s, but also to allow dogs (with an s), we can do dogs?. The ? follows the pattern (i.e., s) that it modifies, and indicates that it is optional. * is used when we want to match zero or more of something. number \\d* would match &quot;number &quot; (no digits), &quot;number 1&quot; (one digit), and &quot;number 1234534123451334466600&quot;. + is similar to * but means one or more. vroo+m would match &quot;vroom&quot; but also &quot;vroooooooom&quot; and &quot;vroooooooooooooooooooooooooooooooom&quot; We can limit the number of matches to an exact number using {n}, which means match exactly n times. vroo{3}m would only match &quot;vroooom&quot;. We can further specify that we want a match to happen match n or more times using {n,}, or use {n,m} to indicate we want to match *at least n times and no more than m times: \\w{8,16} would match 8 to 16 word characters, &quot;ABCD1234&quot; or &quot;zA5YncUI24T_3GHO&quot;  ","version":"Next","tagName":"h3"},{"title":"Define Positional Match Parameters or Alternatives​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#define-positional-match-parameters-or-alternatives","content":" Normally the patterns we define are used to look anywhere within a string. However, sometimes it's important to specify where in the string a match is located. For example, we might care that an id number begins with some sequence of letters, or that a name doesn't end with some set of characters.  ^ means start looking for the match at the beginning of the input string. We could test to see that a string begins with a capital letter like so: ^[A-Z]. Similarly $ means make sure that the match ends the string. If we wanted to test that string was a filename that ended with a period and a three letter extension, we could use: \\.\\w{3}$ (an escaped period, followed by exactly 3 word characters, followed by the end of the string). This would match &quot;filename.txt&quot; but not &quot;filename.txt is a path&quot;. Sometimes we need to specify one of a number of possible alternatives. We do this with |, as in red|green|blue which would match any of the strings &quot;red&quot;, &quot;green&quot;, or &quot;blue&quot;.  ","version":"Next","tagName":"h3"},{"title":"Using RegExp with Strings​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#using-regexp-with-strings","content":" So far we've discussed how to declare a RegExp, and also some of the basics of defining search patterns. Now we need to look at the different ways to use our regular expression objects to perform matches.  RegExp.test(string) - used to test whether or not the given string matches the pattern described by the regular expression. If a match is made, returns true, otherwise false. /id-\\d\\d\\d/.test('id-123') returns true, /id-\\d\\d\\d/.test('id-13b') returns false. String.match(regexp) - used to find all matches of the given RegExp in the source String. These matches are returned as an Array of Strings. For example, 'This sentence has 2 numbers in it, including the number 567'.match(/\\d+/g) will return the Array ['2', '567'] (notice the use of the g flag to find all matches globally). String.replace(regexp, replacement) - used to find all matches for the given RegExp, and returns a new String with those matches replaced by the replacement String provided. For example, '50 , 60,75.'.replace(/\\s*,\\s*/g, ', ') would return '50, 60, 75.' with all whitespace normalized around the commas. String.split(RegExp) - used to break the given String into an Array of sub-strings, dividing them on the RegExp pattern. For example, 'one-two--three---four----five-----six'.split(/-+/) would return ['one', 'two', 'three', 'four', 'five', 'six'], with elements split on any number of dashes.  There are other methods you can call, and more advanced ways to extract data using RegExp, and you are encouraged to dig deeper into these concepts over time. Thinking about matching in terms of regular expressions takes practice, and often involves inverting your logic to narrow a set of possibilities into something you can define in code. ","version":"Next","tagName":"h2"},{"title":"Static Web Site Hosting","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting","content":"","keywords":"","version":"Next"},{"title":"GitHub and GitLab Accounts​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#github-and-gitlab-accounts","content":" Many of the services discussed below are commonly used with git (a command-line tool for version control) and either GitHub or GitLab (two popular online git repository hosting services).  While using git/GitHub/GitLab are beyond the scope of this course, learning them is something you'll need to do in the coming semesters.  In the meantime, you are encouraged to create accounts for yourself on both GitHub and GitLab. It's free, and doing so will make it easier to connect to other services discussed below:  Create an account on GitHubCreate an account on GitLab  ","version":"Next","tagName":"h2"},{"title":"Static Site Hosting Provides​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#static-site-hosting-provides","content":" In this course we are focused on HTML, CSS, and JavaScript for client-side web development. The web sites we will create are often referred to asstatic sites, because they are comprised of files (.html, .css, .js) with no server application. A static site only needs a web server to serve its files.  Because static sites are so simple to host (you just need to upload your files), there are many options for hosting them. Previously this was the kind of thing that people did on their own, setting up, or renting space on a web server.  Today there are numerous free options for hosting your own personal static sites. We'll briefly mention three, and focus on the simplest.  ","version":"Next","tagName":"h2"},{"title":"Prepare your Static Site for Deployment​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#prepare-your-static-site-for-deployment","content":" No matter which hosting service you use, make sure you follow these guidelines when creating your web pages.  Your site needs to have an index.html file in the root of your folder. This is necessary so that your site has an entry point, and people can navigate to it without knowing the name of your web pages. In addition to your index.html page, ou can also have other .html pages that use different names; just add links to them from your index.html page. Use relative URL paths for other assets in your site. For example, consider the following file layout: my-website/ | +--- index.html +--- about.html +--- styles/ | +--- style.css +--- images/ | +--- logo.png In your index.html, you should refer to these other files and directories using paths relative to the index.html file, without specifying a protocol, domain, etc. For example: &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/style.css&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;logo&quot;&gt;Welcome!&lt;/h1&gt; &lt;a href=&quot;about.html&quot;&gt;About&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; In the HTML above, notice how the stylesheet &lt;link&gt; and anchor &lt;a&gt; elements both use paths relative to index.html, and don't use a leading /. In the CSS file, you'd do something similar, but the paths would be relative to the styles/style.css file this time: .logo { background-image: url('../images/logo.png'); } By specifying all your file paths for scripts, stylesheets, images, etc as relative paths to the file where you include them, If you want to disallow Google and other web crawlers from indexing your page, add a robots.txt file. If you are OK with Google indexing your site, you don't need to do anything. Consider preparing your site and its assets for optimal network performance by using a bundler like Parcel. This isn't necessary, but is a best practice, and something you should learn to do as you progress. Bundlers take web asset files and package, compress, and re-write them for optimal loading. Parcel is particularly beginner-friendly, in that you don't need to do any setup. To use Parcel with your site: Make sure node.js is installed on your computer.Open a command line terminal and navigate to your web site's folder: cd my-website.Run the parcel command: npx parcel build index.html. See the parcel cli docs for details on changing the public URL if your host uses a particular path for your site (e.g., GitHub pages).Your built website, and all optimized files, will be available in the dist/ directory.  ","version":"Next","tagName":"h3"},{"title":"Option 1: Glitch​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#option-1-glitch","content":" Glitch provides both online coding and hosting together in one tool. You can remix existing pages and then add your own files or change the code.  If you need a quick way to both create and host a small web site, especially if you're just wanting to learn and experiment with something, Glitch is a good option to consider. See the help docs for more info.  ","version":"Next","tagName":"h3"},{"title":"Option 2: Netlify​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#option-2-netlify","content":" To use Netlify, first you need to Sign up. If you followed the advice above, you already have a GitHub account, and can authenticate using your GitHub (or GitLab) account vs. having to create a new one for Netlify.  Once you've signed up, the easiest way to deploy your web site is to drag-and-drop the site's folder into the dropzone on your Netlify dashboard. There is a short video tutorial available in the Netflify docs as well  Once your site is deployed, you can manage it via the Netlify Dashboard. See the Netflify docs for more info on other things you can do.  ","version":"Next","tagName":"h3"},{"title":"Option 3: GitHub Pages​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#option-3-github-pages","content":" GitHub is a git hosting service, which also offers static site hosting for users and their open source repositories. Using GitHub usually means working with git, but you can also begin by using the GitHub Desktop app, and upload your files that way.  GitHub provides static hosting via GitHub Pages. In order to use GitHub Pages for free, you'll need to host your source code on GitHub in a public repository. As a student you can get special access to GitHub and create private repositories.  ","version":"Next","tagName":"h3"},{"title":"Option 4: GitLab Pages​","type":1,"pageTitle":"Static Web Site Hosting","url":"/WebProgrammingPrinciples/Resources/Static-Web-Site-Hosting#option-4-gitlab-pages","content":" Similar to GitHub, GitLab provides git repository hosting. They also have a pages feature for hosting static sites.  The docs are excellent, and cover all aspects of setup and customization. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}