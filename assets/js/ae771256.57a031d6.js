"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[631],{1646:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Objects-Built-ins/RegExp","title":"RegExp","description":"RegExp","source":"@site/docs/Objects-Built-ins/RegExp.md","sourceDirName":"Objects-Built-ins","slug":"/Objects-Built-ins/RegExp","permalink":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Objects-Built-ins/RegExp.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"RegExp","title":"RegExp","sidebar_position":4,"description":"RegExp"},"sidebar":"courseNotesSidebar","previous":{"title":"Arrays","permalink":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays"},"next":{"title":"Practice Exercises","permalink":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises"}}');var i=s(4848),t=s(8453);const c={id:"RegExp",title:"RegExp",sidebar_position:4,description:"RegExp"},a="RegExp",o={},d=[{value:"Declaring JavaScript <code>RegExp</code>",id:"declaring-javascript-regexp",level:2},{value:"Understanding Regular Expression Patterns",id:"understanding-regular-expression-patterns",level:2},{value:"Matching Specific Characters",id:"matching-specific-characters",level:3},{value:"Define Character Matching Repetition",id:"define-character-matching-repetition",level:3},{value:"Define Positional Match Parameters or Alternatives",id:"define-positional-match-parameters-or-alternatives",level:3},{value:"Using <code>RegExp</code> with <code>String</code>s",id:"using-regexp-with-strings",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"regexp",children:"RegExp"})}),"\n",(0,i.jsxs)(n.p,{children:["A regular expression is a special string that describes a pattern to be used for matching or searching within other strings. They are also known as a ",(0,i.jsx)(n.em,{children:"regex"})," or ",(0,i.jsx)(n.em,{children:"regexp"}),", and in JavaScript we refer to ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions",children:(0,i.jsx)(n.code,{children:"RegExp"})})," when we mean the built-in ",(0,i.jsx)(n.code,{children:"Object"})," type for creating and working with regular expressions."]}),"\n",(0,i.jsx)(n.p,{children:"You can think of regular expressions as a kind of mini programming language separate from JavaScript. They are not unique to JavaScript, and learning how to write and use them will be helpful in many other programming languages."}),"\n",(0,i.jsx)(n.p,{children:"Even if you're not familiar with regular expression syntax (it takes some time to master), you've probably\nencountered similar ideas with wildcards. Consider the following Unix command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ls *.txt\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here we ask for a listing of all files whose filename ",(0,i.jsx)(n.em,{children:"ends with"})," the extension ",(0,i.jsx)(n.code,{children:".txt"}),". The ",(0,i.jsx)(n.code,{children:"*"})," has a special meaning: ",(0,i.jsx)(n.em,{children:"any character, and any number of characters"}),". Both ",(0,i.jsx)(n.code,{children:"a.txt"})," and ",(0,i.jsx)(n.code,{children:"file123.txt"})," would be matched against this pattern, since both end with ",(0,i.jsx)(n.code,{children:".txt"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Regular expressions take the idea of defining patterns using characters like ",(0,i.jsx)(n.code,{children:"*"}),", and extend it into a more powerful pattern matching language. Here's an example of a regular expression that could be used to match both common spellings of the word ",(0,i.jsx)(n.code,{children:'"colour"'})," and ",(0,i.jsx)(n.code,{children:'"color"'}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"colou?r\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"?"})," means that the preceding character ",(0,i.jsx)(n.code,{children:"u"})," is optional (it may or may not be there).\nHere's another example regular expression that could be used to match a string that starts with ",(0,i.jsx)(n.code,{children:"id-"})," followed by 1, 2, or 3 digits (",(0,i.jsx)(n.code,{children:"id-1"}),", ",(0,i.jsx)(n.code,{children:"id-12"}),", or ",(0,i.jsx)(n.code,{children:"id-999"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"id-\\d{1,3}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"\\d"})," means a digit (0-9) and the ",(0,i.jsx)(n.code,{children:"{1,3}"})," portion means ",(0,i.jsx)(n.em,{children:"at least one, and at most three"}),". Together we get ",(0,i.jsx)(n.em,{children:"at least one digit, and at most three digits"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["There are many ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters",children:"special characters"})," to learn with regular expressions, which we'll slowly introduce."]}),"\n",(0,i.jsxs)(n.h2,{id:"declaring-javascript-regexp",children:["Declaring JavaScript ",(0,i.jsx)(n.code,{children:"RegExp"})]}),"\n",(0,i.jsxs)(n.p,{children:["Like ",(0,i.jsx)(n.code,{children:"String"})," or ",(0,i.jsx)(n.code,{children:"Array"}),", we can declare a ",(0,i.jsx)(n.code,{children:"RegExp"})," using either a literal or the ",(0,i.jsx)(n.code,{children:"RegExp"})," constructor:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let regex = /colou?r/; // regex literal uses /.../\nlet regex2 = new RegExp('colou?r');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Regular expressions can also have ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Advanced_searching_with_flags_2",children:"advanced search flags"}),",\nwhich indicate how the search is supposed to be performed.\nThese flags include ",(0,i.jsx)(n.code,{children:"g"})," (globally match all occurrences vs. only matching once),\n",(0,i.jsx)(n.code,{children:"i"})," (ignore case when matching), and ",(0,i.jsx)(n.code,{children:"m"})," (match across line breaks, multi-line matching) among others."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let regex = /pattern/gi; // find all matches (global) and ignore case\nlet regex2 = new RegExp('pattern', 'gi'); // same thing using the constructor instead\n"})}),"\n",(0,i.jsx)(n.h2,{id:"understanding-regular-expression-patterns",children:"Understanding Regular Expression Patterns"}),"\n",(0,i.jsx)(n.p,{children:"Regular expressions are dense, and often easier to write than to read. It's helpful to use\nvarious tools to help you as you experiment with patterns, and try to understand and debug\nyour own regular expressions:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://regexr.com/",children:"regexr.com"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://jex.im/regulex",children:"Regulex"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.regexpal.com/",children:"regexpal.com"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"matching-specific-characters",children:"Matching Specific Characters"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"\\ ^ $ . * + ? ( ) [ ] { } |"})," all have special meaning, and if you need to match them, you have to escape them with a leading ",(0,i.jsx)(n.code,{children:"\\"}),". For example: ",(0,i.jsx)(n.code,{children:"\\$"})," to match a ",(0,i.jsx)(n.code,{children:"$"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Any other character will match itself. ",(0,i.jsx)(n.code,{children:"abc"})," is a valid regular expression and means ",(0,i.jsx)(n.em,{children:"match the letters abc"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"."})," means ",(0,i.jsx)(n.em,{children:"any character"}),". For example ",(0,i.jsx)(n.code,{children:"a."})," would match ",(0,i.jsx)(n.code,{children:"ab"}),", ",(0,i.jsx)(n.code,{children:"a3"}),", or ",(0,i.jsx)(n.code,{children:'a"'}),". If you need to match the ",(0,i.jsx)(n.code,{children:"."})," itself, make sure you escape it: ",(0,i.jsx)(n.code,{children:".\\."})," means ",(0,i.jsx)(n.em,{children:"a period followed by any character"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["We specify a set of possible characters using ",(0,i.jsx)(n.code,{children:"[]"}),". For example, if we wanted to match any vowel, we might do ",(0,i.jsx)(n.code,{children:"[aeiou]"}),". This says ",(0,i.jsx)(n.em,{children:"match any of the letters a, e, i, o, or u"})," and would match ",(0,i.jsx)(n.code,{children:"a"})," but not ",(0,i.jsx)(n.code,{children:"t"}),". We can also do the opposite, and define a negated set: ",(0,i.jsx)(n.code,{children:"[^aeiou]"})," would match anything that is ",(0,i.jsx)(n.em,{children:"not"})," a vowel. With regular expressions, it can often be easier to define your patterns in terms of what they are not instead of what they are, since so many things are valid vs. a limited set of things that are not. We can also specify a range, ",(0,i.jsx)(n.code,{children:"[a-d]"})," would match any of ",(0,i.jsx)(n.code,{children:"a, b, c, d"})," but not ",(0,i.jsx)(n.code,{children:"f, g"})," or ",(0,i.jsx)(n.code,{children:"h"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Some sets are so common that we have shorthand notation. Consider the set of single digit numbers, ",(0,i.jsx)(n.code,{children:"[0123456789]"}),". We can instead use ",(0,i.jsx)(n.code,{children:"\\d"})," which means the same thing. The inverse is ",(0,i.jsx)(n.code,{children:"\\D"})," (capital ",(0,i.jsx)(n.code,{children:"D"}),"), and means ",(0,i.jsx)(n.code,{children:"[^0123456789]"})," (i.e., ",(0,i.jsx)(n.em,{children:"not one of the digits"}),"). If we wanted to match a number with three digits, we could use ",(0,i.jsx)(n.code,{children:"\\d\\d\\d"}),", which would match ",(0,i.jsx)(n.code,{children:"123"})," or ",(0,i.jsx)(n.code,{children:"678"})," or ",(0,i.jsx)(n.code,{children:"000"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Another commonly needed pattern is ",(0,i.jsx)(n.em,{children:"any letter or number"})," and is available with ",(0,i.jsx)(n.code,{children:"\\w"}),", meaning ",(0,i.jsx)(n.code,{children:"[A-Za-z0-9_]"})," (all upper- and lower-case letters, digits 0 to 9, and the underscore). The inverse is available as ",(0,i.jsx)(n.code,{children:"\\W"})," and means ",(0,i.jsx)(n.code,{children:"[^A-Za-z0-9_]"})," (everything ",(0,i.jsx)(n.em,{children:"not"})," in the set of letters, numbers and underscore)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Often we need to match blank whitespace (spaces, tabs, newlines, etc.). We can do that with ",(0,i.jsx)(n.code,{children:"\\s"}),", and the inverse ",(0,i.jsx)(n.code,{children:"\\S"})," (anything not a whitespace). For example, suppose we wanted to allow users to enter an id number with or without a space: ",(0,i.jsx)(n.code,{children:"\\d\\d\\d\\s?\\d\\d\\d"})," would match both ",(0,i.jsx)(n.code,{children:"123456"})," and ",(0,i.jsx)(n.code,{children:"123 456"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["There are lots of other examples of pre-defined common patterns, such as ",(0,i.jsx)(n.code,{children:"\\n"})," (newline), ",(0,i.jsx)(n.code,{children:"\\r"})," (carriage return), ",(0,i.jsx)(n.code,{children:"\\t"})," (tab). Consult the ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions",children:"MDN documentation for character classes"})," to lookup others."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"define-character-matching-repetition",children:"Define Character Matching Repetition"}),"\n",(0,i.jsxs)(n.p,{children:["In addition to matching a single character or character class, we can also match sequences of them,\nand define ",(0,i.jsx)(n.em,{children:"how many"})," times a pattern or match can/must occur. We do this by adding extra information\n",(0,i.jsx)(n.em,{children:"after"})," our match pattern."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"?"})," is used to indicate that we want to match something ",(0,i.jsx)(n.em,{children:"once or none"}),". For example, if we want to match the word ",(0,i.jsx)(n.code,{children:"dog"})," without an ",(0,i.jsx)(n.code,{children:"s"}),", but also to allow ",(0,i.jsx)(n.code,{children:"dogs"})," (with an ",(0,i.jsx)(n.code,{children:"s"}),"), we can do ",(0,i.jsx)(n.code,{children:"dogs?"}),". The ",(0,i.jsx)(n.code,{children:"?"})," follows the pattern (i.e., ",(0,i.jsx)(n.code,{children:"s"}),") that it modifies, and indicates that it is optional."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"*"})," is used when we want to match ",(0,i.jsx)(n.em,{children:"zero or more"})," of something. ",(0,i.jsx)(n.code,{children:"number \\d*"})," would match ",(0,i.jsx)(n.code,{children:'"number "'})," (no digits), ",(0,i.jsx)(n.code,{children:'"number 1"'})," (one digit), and ",(0,i.jsx)(n.code,{children:'"number 1234534123451334466600"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"+"})," is similar to ",(0,i.jsx)(n.code,{children:"*"})," but means ",(0,i.jsx)(n.em,{children:"one or more"}),". ",(0,i.jsx)(n.code,{children:"vroo+m"})," would match ",(0,i.jsx)(n.code,{children:'"vroom"'})," but also ",(0,i.jsx)(n.code,{children:'"vroooooooom"'})," and ",(0,i.jsx)(n.code,{children:'"vroooooooooooooooooooooooooooooooom"'})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["We can limit the number of matches to an exact number using ",(0,i.jsx)(n.code,{children:"{n}"}),", which means ",(0,i.jsxs)(n.em,{children:["match exactly ",(0,i.jsx)(n.code,{children:"n"})," times"]}),". ",(0,i.jsx)(n.code,{children:"vroo{3}m"})," would only match ",(0,i.jsx)(n.code,{children:'"vroooom"'}),". We can further specify that we want a match to happen ",(0,i.jsxs)(n.em,{children:["match ",(0,i.jsx)(n.code,{children:"n"})," or more times"]})," using ",(0,i.jsx)(n.code,{children:"{n,}"}),", or use ",(0,i.jsx)(n.code,{children:"{n,m}"})," to indicate we want to match *at least ",(0,i.jsx)(n.code,{children:"n"})," times and no more than ",(0,i.jsx)(n.code,{children:"m"})," times: ",(0,i.jsx)(n.code,{children:"\\w{8,16}"})," would match 8 to 16 word characters, ",(0,i.jsx)(n.code,{children:'"ABCD1234"'})," or ",(0,i.jsx)(n.code,{children:'"zA5YncUI24T_3GHO"'})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"define-positional-match-parameters-or-alternatives",children:"Define Positional Match Parameters or Alternatives"}),"\n",(0,i.jsxs)(n.p,{children:["Normally the patterns we define are used to look ",(0,i.jsx)(n.em,{children:"anywhere"})," within a string. However, sometimes\nit's important to specify ",(0,i.jsx)(n.em,{children:"where"})," in the string a match is located. For example, we might care that\nan id number ",(0,i.jsx)(n.em,{children:"begins"})," with some sequence of letters, or that a name doesn't ",(0,i.jsx)(n.em,{children:"end"})," with some set of characters."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"^"})," means start looking for the match at the ",(0,i.jsx)(n.em,{children:"beginning"})," of the input string. We could test to see that a string begins with a capital letter like so: ",(0,i.jsx)(n.code,{children:"^[A-Z]"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Similarly ",(0,i.jsx)(n.code,{children:"$"})," means make sure that the match ends the string. If we wanted to test that string was a filename that ended with a period and a three letter extension, we could use: ",(0,i.jsx)(n.code,{children:"\\.\\w{3}$"})," (an escaped period, followed by exactly 3 word characters, followed by the end of the string). This would match ",(0,i.jsx)(n.code,{children:'"filename.txt"'})," but not ",(0,i.jsx)(n.code,{children:'"filename.txt is a path"'}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Sometimes we need to specify one of a number of possible alternatives. We do this with ",(0,i.jsx)(n.code,{children:"|"}),", as in ",(0,i.jsx)(n.code,{children:"red|green|blue"})," which would match any of the strings ",(0,i.jsx)(n.code,{children:'"red"'}),", ",(0,i.jsx)(n.code,{children:'"green"'}),", or ",(0,i.jsx)(n.code,{children:'"blue"'}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"using-regexp-with-strings",children:["Using ",(0,i.jsx)(n.code,{children:"RegExp"})," with ",(0,i.jsx)(n.code,{children:"String"}),"s"]}),"\n",(0,i.jsxs)(n.p,{children:["So far we've discussed how to declare a ",(0,i.jsx)(n.code,{children:"RegExp"}),", and also some of the basics of defining search patterns.\nNow we need to look at the different ways to use our regular expression objects to perform matches."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test",children:(0,i.jsx)(n.code,{children:"RegExp.test(string)"})})," - used to test whether or not the given string matches the pattern described by the regular expression. If a match is made, returns ",(0,i.jsx)(n.code,{children:"true"}),", otherwise ",(0,i.jsx)(n.code,{children:"false"}),". ",(0,i.jsx)(n.code,{children:"/id-\\d\\d\\d/.test('id-123')"})," returns ",(0,i.jsx)(n.code,{children:"true"}),", ",(0,i.jsx)(n.code,{children:"/id-\\d\\d\\d/.test('id-13b')"})," returns ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match",children:(0,i.jsx)(n.code,{children:"String.match(regexp)"})})," - used to find all matches of the given ",(0,i.jsx)(n.code,{children:"RegExp"})," in the source ",(0,i.jsx)(n.code,{children:"String"}),". These matches are returned as an ",(0,i.jsx)(n.code,{children:"Array"})," of ",(0,i.jsx)(n.code,{children:"String"}),"s. For example, ",(0,i.jsx)(n.code,{children:"'This sentence has 2 numbers in it, including the number 567'.match(/\\d+/g)"})," will return the ",(0,i.jsx)(n.code,{children:"Array"})," ",(0,i.jsx)(n.code,{children:"['2', '567']"})," (notice the use of the ",(0,i.jsx)(n.code,{children:"g"})," flag to find all matches globally)."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace",children:(0,i.jsx)(n.code,{children:"String.replace(regexp, replacement)"})})," - used to find all matches for the given ",(0,i.jsx)(n.code,{children:"RegExp"}),", and returns a new ",(0,i.jsx)(n.code,{children:"String"})," with those matches replaced by the replacement ",(0,i.jsx)(n.code,{children:"String"})," provided. For example, ",(0,i.jsx)(n.code,{children:"'50 , 60,75.'.replace(/\\s*,\\s*/g, ', ')"})," would return ",(0,i.jsx)(n.code,{children:"'50, 60, 75.'"})," with all whitespace normalized around the commas."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split",children:(0,i.jsx)(n.code,{children:"String.split(RegExp)"})})," - used to break the given ",(0,i.jsx)(n.code,{children:"String"})," into an ",(0,i.jsx)(n.code,{children:"Array"})," of sub-strings, dividing them on the ",(0,i.jsx)(n.code,{children:"RegExp"})," pattern. For example, ",(0,i.jsx)(n.code,{children:"'one-two--three---four----five-----six'.split(/-+/)"})," would return ",(0,i.jsx)(n.code,{children:"['one', 'two', 'three', 'four', 'five', 'six']"}),", with elements split on any number of dashes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["There are other ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Working_with_regular_expressions",children:"methods you can call"}),", and more ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_parentheses",children:"advanced ways to extract data"})," using RegExp, and you are encouraged to dig deeper into these concepts over time. Thinking about matching in terms of regular expressions takes practice, and often involves inverting your logic to narrow a set of possibilities into something you can define in code."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var r=s(6540);const i={},t=r.createContext(i);function c(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);