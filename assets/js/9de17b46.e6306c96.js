"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[935],{6457:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Advanced-Objects-Inheritance/Objects-JavaScript","title":"Objects in JavaScript","description":"Objects in JavaScript","source":"@site/docs/Advanced-Objects-Inheritance/Objects-JavaScript.md","sourceDirName":"Advanced-Objects-Inheritance","slug":"/Advanced-Objects-Inheritance/Objects-JavaScript","permalink":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Advanced-Objects-Inheritance/Objects-JavaScript.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"Objects-JavaScript","title":"Objects in JavaScript","sidebar_position":1,"description":"Objects in JavaScript"},"sidebar":"courseNotesSidebar","previous":{"title":"Practice Exercises","permalink":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises"},"next":{"title":"Constructor Functions","permalink":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions"}}');var s=t(4848),o=t(8453);const a={id:"Objects-JavaScript",title:"Objects in JavaScript",sidebar_position:1,description:"Objects in JavaScript"},i="Objects in JavaScript",c={},d=[{value:"Accessing Elements in an Object",id:"accessing-elements-in-an-object",level:2},{value:"Destructuring Objects",id:"destructuring-objects",level:3},{value:"Modifying Object Properties",id:"modifying-object-properties",level:2},{value:"Using Objects: dealing with optional parameters",id:"using-objects-dealing-with-optional-parameters",level:2},{value:"Updating, Clearing, and Removing properties",id:"updating-clearing-and-removing-properties",level:2},{value:"Using Objects: creating sets to track arbitrary lists",id:"using-objects-creating-sets-to-track-arbitrary-lists",level:2},{value:"Complex Property Types: <code>Object</code>, <code>Function</code>",id:"complex-property-types-object-function",level:2},{value:"Suggested Readings",id:"suggested-readings",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"objects-in-javascript",children:"Objects in JavaScript"})}),"\n",(0,s.jsxs)(n.p,{children:["So far we've been working with built-in ",(0,s.jsx)(n.code,{children:"Objects"})," in JavaScript. We can also create\nour own in order to model complex data types in our programs. There are a number\nof ways to do this, and we'll look at a few of them now."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Object"})," in JavaScript is a ",(0,s.jsx)(n.em,{children:"map"})," (also known as an ",(0,s.jsx)(n.em,{children:"associative array"})," or a ",(0,s.jsx)(n.em,{children:"dictionary"}),"),\nwhich is a data structure composed of a collection of ",(0,s.jsx)(n.em,{children:"key"})," and ",(0,s.jsx)(n.em,{children:"value"})," pairs. We call an ",(0,s.jsx)(n.code,{children:"Object"}),"'s key/value pairs ",(0,s.jsx)(n.em,{children:"properties"}),". Imagine a JavaScript ",(0,s.jsx)(n.code,{children:"Object"}),' as a dynamic "bag" of properties, a\nproperty-bag. Each ',(0,s.jsx)(n.em,{children:"key"})," is a unique ",(0,s.jsx)(n.code,{children:"String"}),", and an ",(0,s.jsx)(n.code,{children:"Object"})," can only contain a given ",(0,s.jsx)(n.em,{children:"key"})," once. An ",(0,s.jsx)(n.code,{children:"Object"})," can have any number of ",(0,s.jsx)(n.em,{children:"properties"}),", and they can be added and removed at runtime."]}),"\n",(0,s.jsxs)(n.p,{children:["Much like we did with an ",(0,s.jsx)(n.code,{children:"Array"})," or ",(0,s.jsx)(n.code,{children:"RegExp"}),", we can create instances of ",(0,s.jsx)(n.code,{children:"Objects"}),"\nvia literals. An ",(0,s.jsx)(n.code,{children:"Object"})," literal always starts with ",(0,s.jsx)(n.code,{children:"{"})," and ends with ",(0,s.jsx)(n.code,{children:"}"}),". In between these curly\nbraces we can optionally include a list of any properties (comma separated) we want to attach to this ",(0,s.jsx)(n.code,{children:"Object"})," instance. These properties are written using a standard ",(0,s.jsx)(n.code,{children:"key: value"})," style, with the property's name ",(0,s.jsx)(n.code,{children:"String"})," coming first, followed by a ",(0,s.jsx)(n.code,{children:":"}),", then its value. The value can be any JavaScript value, including functions or other ",(0,s.jsx)(n.code,{children:"Objects"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Here are a few examples:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// an empty Object, with no properties\nlet o = {};\n\n// a `person` Object, with one property, `name`\nlet person = { name: 'Tim Wu' };\n\n// a `campus` Object, with `name` as well as co-ordinates (`lat`, `lng`).\n// NOTE: as the Object literal gets longer, we break it into multiple lines.\nlet campus = {\n  name: 'Seneca@York',\n  lat: 43.7714,\n  lng: -79.4988,\n};\n\n// a `menu` Object, which contains lists of menu items per meal\nlet menu = {\n  breakfast: ['eggs', 'toast', 'banana', 'coffee'],\n  lunch: ['salad', 'chicken', 'apple', 'milk'],\n  dinner: ['salmon', 'rice', 'green beans'],\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"accessing-elements-in-an-object",children:"Accessing Elements in an Object"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object"})," property names are ",(0,s.jsx)(n.code,{children:"String"}),"s, and we can refer to them either via the ",(0,s.jsx)(n.em,{children:"dot operator"})," ",(0,s.jsx)(n.code,{children:".name"}),",\nor using the ",(0,s.jsx)(n.em,{children:"bracket operator"})," ",(0,s.jsx)(n.code,{children:"['name']"})," (similar to indexing in an ",(0,s.jsx)(n.code,{children:"Array"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let person = { name: 'Tim Wu' };\n\n// get the value of the `name` property using the . operator\nconsole.log(person.name);\n\n// get the value of the `name` property using the [] operator\nconsole.log(person['name']);\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Why would you choose the dot operator over the bracket operator, or vice versa? The dot operator is probably more commonly used; however, the bracket operator is useful in a number of scenarios. First, if you need to use a reserved JavaScript keyword for your property key, you'll need to refer to it as a string (e.g., ",(0,s.jsx)(n.code,{children:"obj['for']"}),"). Second, it's sometimes useful to be able to pass a variable in order to lookup a property value for a name that will be different at runtime. For example, if you are using usernames as keys, you might do ",(0,s.jsx)(n.code,{children:"users[currentUsername]"}),", where ",(0,s.jsx)(n.code,{children:"currentUsername"})," is a variable holding a ",(0,s.jsx)(n.code,{children:"String"})," for the logged in user."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"destructuring-objects",children:"Destructuring Objects"}),"\n",(0,s.jsxs)(n.p,{children:["In the same way that we ",(0,s.jsx)(n.em,{children:"destructured"})," ",(0,s.jsx)(n.code,{children:"Array"})," values into new variables, we can also use the same\ntechnique with an ",(0,s.jsx)(n.code,{children:"Object"}),". Recall that JavaScript allows us to ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",children:"Destructuring Assignment"})," to unpack values in an ",(0,s.jsx)(n.code,{children:"Array"})," or ",(0,s.jsx)(n.code,{children:"Object"})," into distinct variables. Consider each of the following methods, both of which accomplish the same goal:"]}),"\n",(0,s.jsxs)(n.p,{children:["With an ",(0,s.jsx)(n.code,{children:"Array"}),", we learned that you can ",(0,s.jsx)(n.em,{children:"destructure"})," various elements into new variables:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Co-ordinates for Seneca's Newnham Campus\nlet position = [43.796, -79.3486];\n\nlet [lat, lng] = position;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The same can be done with an ",(0,s.jsx)(n.code,{children:"Object"}),". Imagine a complex ",(0,s.jsx)(n.code,{children:"Object"}),", with lots of properties, but we're only interested in a few of them:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let senecaNewnham = {\n  address: '1750 Finch Ave. East',\n  city: 'Toronto',\n  province: 'Ontario',\n  postalCode: 'M2J 2X5',\n  phoneNumber: '416.491.5050',\n  lat: 43.796,\n  lng: -79.3486,\n};\n\n// Destructure only the `lat` and `lng` properties\nlet { lat, lng } = senecaNewnham;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is a powerful technique for extracting data from an ",(0,s.jsx)(n.code,{children:"Object"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"modifying-object-properties",children:"Modifying Object Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object"})," literals allow us to define an initial set of properties on an ",(0,s.jsx)(n.code,{children:"Object"}),", but we aren't\nlimited to that set. We can easily add new ones:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let data = {};\n\ndata.score = 17;\ndata.level = 3;\ndata.health = '***';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here we define an empty ",(0,s.jsx)(n.code,{children:"Object"}),", but then add new properties. Because we can add properties\nafter an ",(0,s.jsx)(n.code,{children:"Object"})," is created, we always have to deal with a property not existing. If we try to access\na property that does not exist on an ",(0,s.jsx)(n.code,{children:"Object"}),", there won't be an error. Instead, we will get back\n",(0,s.jsx)(n.code,{children:"undefined"})," for its value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let currentScore = data.score; // `score` exists on `data`, and we get back the value `17`\nlet inventory = data.inventory; // `inventory` does not exist on `data`, so we get back `undefined`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because properties may or may not exist at runtime, it's important to always check for a value\nbefore trying to use it. We could rewrite the above to first check if ",(0,s.jsx)(n.code,{children:"data"})," has an ",(0,s.jsx)(n.code,{children:"inventory"}),"\nproperty:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (data.inventory) {\n  // `data` has a value for `inventory`, use data.inventory here...\n} else {\n  // there is no `inventory` on `data`, do something else...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Another common situation where you have to deal with this is working with deep structures. Consider\nan ",(0,s.jsx)(n.code,{children:"Object"})," that defines the structure of a level in a video game. The level includes various ",(0,s.jsx)(n.code,{children:"rooms"}),",\nsome of which contain a ",(0,s.jsx)(n.code,{children:"monster"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let gameLevel = {\n  name: 'Level 1',\n  rooms: {\n    // Each room has a unique ID\n    R31343: {\n      name: 'Front Hallway',\n    },\n    R31344: {\n      name: 'Kitchen',\n      monster: {\n        name: 'Bear',\n        strength: 15,\n      },\n    },\n    R31345: {\n      name: 'Back Hallway',\n    },\n    R31346: {\n      name: 'Sitting Room',\n      monster: {\n        name: 'Dog',\n        strength: 8,\n      },\n    },\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When working this code, we can access a particular room by its ",(0,s.jsx)(n.code,{children:"ID"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get a reference to the Kitchen\nlet room = gameLevel.rooms.R31344;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However, we used an ",(0,s.jsx)(n.code,{children:"ID"})," that doesn't exist, we'd get back ",(0,s.jsx)(n.code,{children:"undefined"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Get a reference to the TV Room (no such room!)\nlet room = gameLevel.rooms.R31347; // <-- room is `undefined`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If we then try to access the ",(0,s.jsx)(n.code,{children:"monster"})," in that room, our program will crash:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let room = gameLevel.rooms.R31347; // <-- room is `undefined`\nconsole.log(room.monster); // <-- crash! room is `undefined` so we can't access `monster within it\n"})}),"\n",(0,s.jsx)(n.p,{children:"JavaScript provides a few ways to deal with this problem. Consider:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let room = gameLevel.rooms.R31347;\n\n// Version 1\nif (room) {\n  // only access room if it is truthy\n}\n\n// Version 2\nif (room && room.monster) {\n  // only try to get .monster if room is truthy\n}\n\n// Version 3\nif (room?.monster) {\n  // same as 2, but using ?. syntax\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the third version above we've used ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining",children:"optional chaining"})," via the ",(0,s.jsx)(n.code,{children:"?."})," operator. This stops us from going any further in an object chain, when something is undefined."]}),"\n",(0,s.jsx)(n.h2,{id:"using-objects-dealing-with-optional-parameters",children:"Using Objects: dealing with optional parameters"}),"\n",(0,s.jsxs)(n.p,{children:["A very common pattern in JavaScript programs that uses this concept is optional argument\npassing to functions. Instead of using an unknown number of ",(0,s.jsx)(n.code,{children:"arguments"})," for a function, we\noften use an ",(0,s.jsx)(n.code,{children:"options"})," ",(0,s.jsx)(n.code,{children:"Object"}),", which may contain values to be used in the function. Consider\nthe case of starting a game and sometimes passing existing user data:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Make sure `options` exists, and use an empty `Object` instead if it's missing.\n// If we don't do this, we'll get an error if we try to do `options.score`, since\n// we can't lookup the `score` property on `undefined`.\nfunction initGame(options = {}) {\n  // If the user already has a score, use that, otherwise default to 0\n  let score = options.score || 0;\n  // If the user is already on a level, use that, otherwise default to 1\n  let level = options.level || 1;\n  // If the user has collected an items in her inventory, use that, otherwise an empty Array\n  let inventory = options.inventory || [];\n\n  // Begin the game, passing the values we have determined above\n  playGame(score, level, inventory);\n}\n\n// Define our options: we have a score and level, but no inventory\nlet options = {\n  score: 25,\n  level: 2,\n};\ninitGame(options);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the code above, we have an ",(0,s.jsx)(n.code,{children:"options"})," ",(0,s.jsx)(n.code,{children:"Object"})," that defines some, but not all of the\nproperties our ",(0,s.jsx)(n.code,{children:"initGame"})," function might use. We wrote ",(0,s.jsx)(n.code,{children:"initGame"})," using a single argument\nso that it was easier to call: we didn't need to worry about the order or number of arguments,\nand could instead just define an ",(0,s.jsx)(n.code,{children:"Object"})," with all of the properties we had. The ",(0,s.jsx)(n.code,{children:"initGame"}),"\nfunction examined the ",(0,s.jsx)(n.code,{children:"options"})," at runtime to see which properties existed, and which were\n",(0,s.jsx)(n.code,{children:"undefined"})," and needed a default value instead. Recall that we can use the ",(0,s.jsx)(n.em,{children:"logical OR"})," (",(0,s.jsx)(n.code,{children:"||"}),")\noperator to choose between two values at runtime."]}),"\n",(0,s.jsxs)(n.p,{children:["It's also common to see people use ",(0,s.jsx)(n.em,{children:"destructuring"})," here:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function processStudent(student) {\n  let { name, studentId, username, email } = student;\n  // Use values destructured from student object\n}\n\nprocessStudent({\n  name: 'Tim Wu',\n  studentId: '10341346',\n  username: 'timw',\n  email: 'timw@myseneca.ca',\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The value of what we've done above is that passing many arguments to a function is easier when we can name them as properties on an ",(0,s.jsx)(n.code,{children:"Object"})," instead of having to pass them positionally as arguments."]}),"\n",(0,s.jsx)(n.h2,{id:"updating-clearing-and-removing-properties",children:"Updating, Clearing, and Removing properties"}),"\n",(0,s.jsxs)(n.p,{children:["We've seen that properties can be defined when declared as part of a literal and\nadded later via the ",(0,s.jsx)(n.code,{children:"."})," or ",(0,s.jsx)(n.code,{children:"[]"})," operators. We can also update or remove values\nafter they are created:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let o = {};\n\n// Add a name property\no.name = 'Tim Wu';\n\n// Update the name property to a new value, removing the old one.\no.name = 'Mr. Timothy Wu';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Object"}),"'s property keys are unique, and setting a value for ",(0,s.jsx)(n.code,{children:"o.name"})," more than once\ndoesn't add more properties--it overwrites the value already stored in the existing property.\nWe can also ",(0,s.jsx)(n.em,{children:"clear"})," (remove the value but not the key) or ",(0,s.jsx)(n.em,{children:"delete"})," (remove the entire property\nfrom the object, key and value) things from an ",(0,s.jsx)(n.code,{children:"Object"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let o = {};\n\n// Add a `height` property\no.height = '35 inches';\n\n// Add an owner ID property\no.owner = '012341341';\n\n// Clear the value of `height`. We leave the `height` key, but get rid of the '35 inches' value\no.height = null;\n\n// Completely remove the owner property from the object (both the key and its value)\ndelete o.owner;\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Why would you choose to assign ",(0,s.jsx)(n.code,{children:"null"})," vs. use ",(0,s.jsx)(n.code,{children:"delete"}),"? Often we want to get rid of a key's value, but will use the key again in the future (e.g., add a new value). In such cases we just ",(0,s.jsx)(n.em,{children:"null the value"})," by assigning the key a value of ",(0,s.jsx)(n.code,{children:"null"}),". If we know that we'll never use this key again, and we don't want to retain it on the ",(0,s.jsx)(n.code,{children:"Object"}),", we can instead completely remove the property (key and value) with ",(0,s.jsx)(n.code,{children:"delete"}),". You'll see both used. For the most part, setting a key's value to ",(0,s.jsx)(n.code,{children:"null"})," is probably what you want."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-objects-creating-sets-to-track-arbitrary-lists",children:"Using Objects: creating sets to track arbitrary lists"}),"\n",(0,s.jsxs)(n.p,{children:["Another common use of ",(0,s.jsx)(n.code,{children:"Object"}),"s, and their unique property keys, is to keep track of a sets, for example\nto count or keep track of an unknown number of items. Consider the following program, which tracks how many times each\ncharacter appears within a ",(0,s.jsx)(n.code,{children:"String"}),". The code uses the ",(0,s.jsx)(n.code,{children:"[]"})," operator to allow for the keys to be created\nand accessed via a variable (",(0,s.jsx)(n.code,{children:"char"}),"). Without an ",(0,s.jsx)(n.code,{children:"Object"})," we would have to hard-code variables for each\nseparate letter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// An empty `Object`, which we'll populate with keys (letters) and values (counts)\nlet characterCounts = {};\n\nlet sentence = 'The quick brown fox jumped over the lazy dog.';\nlet char;\nlet count;\n\n// Loop through all characters in sentence\nfor (let char of sentence) {\n  // Get the current count for this character, or use 0 if we haven't seen it before\n  count = characterCounts[char] || 0;\n  // Increase the count by 1, and store it in our object\n  characterCounts[char] = count + 1;\n}\n\nconsole.log(characterCounts);\n/* Our characterCounts Object now looks like this, and there were 8 spaces, 2 'h's, etc:\n{ T: 1,\n  h: 2,\n  e: 4,\n  ' ': 8,\n  q: 1,\n  u: 2,\n  i: 1,\n  c: 1,\n  k: 1,\n  b: 1,\n  r: 2,\n  o: 4,\n  w: 1,\n  n: 1,\n  f: 1,\n  x: 1,\n  j: 1,\n  m: 1,\n  p: 1,\n  d: 2,\n  v: 1,\n  t: 1,\n  l: 1,\n  a: 1,\n  z: 1,\n  y: 1,\n  g: 1,\n  '.': 1 }\n*/\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"complex-property-types-object-function",children:["Complex Property Types: ",(0,s.jsx)(n.code,{children:"Object"}),", ",(0,s.jsx)(n.code,{children:"Function"})]}),"\n",(0,s.jsxs)(n.p,{children:["We said earlier that ",(0,s.jsx)(n.code,{children:"Object"})," properties can be any valid JavaScript type. That includes\n",(0,s.jsx)(n.code,{children:"Number"}),", ",(0,s.jsx)(n.code,{children:"String"}),", ",(0,s.jsx)(n.code,{children:"Boolean"}),", etc., also ",(0,s.jsx)(n.code,{children:"Object"})," and ",(0,s.jsx)(n.code,{children:"Function"}),". A property may define\na complex ",(0,s.jsx)(n.code,{children:"Object"})," of its own:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let part = {\n  id: 5,\n  info: {\n    name: 'inner gasket',\n    shelf: 56713,\n    ref: [5618, 5693],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here we define a ",(0,s.jsx)(n.code,{children:"part"}),", which has an id (",(0,s.jsx)(n.code,{children:"part.id"}),") as well as a complex property named ",(0,s.jsx)(n.code,{children:"info"}),",\nwhich is itself an ",(0,s.jsx)(n.code,{children:"Object"}),". We access properties deep in an ",(0,s.jsx)(n.code,{children:"Object"})," the same way as a simple\nproperty, for example: ",(0,s.jsx)(n.code,{children:"part.info.ref.length"})," means: get the ",(0,s.jsx)(n.code,{children:"length"})," of the ",(0,s.jsx)(n.code,{children:"ref"})," array on the\n",(0,s.jsx)(n.code,{children:"info"})," property of the ",(0,s.jsx)(n.code,{children:"part"})," ",(0,s.jsx)(n.code,{children:"Object"}),". An ",(0,s.jsx)(n.code,{children:"Object"}),"'s properties can be ",(0,s.jsx)(n.code,{children:"Object"}),"s many levels\ndeep, and we use the ",(0,s.jsx)(n.code,{children:"."})," or ",(0,s.jsx)(n.code,{children:"[]"})," operators to access these child properties."]}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"Object"})," property can also be a function. We call these functions ",(0,s.jsx)(n.em,{children:"methods"}),". A ",(0,s.jsx)(n.em,{children:"method"})," has\naccess to other properties on the ",(0,s.jsx)(n.code,{children:"Object"})," via the ",(0,s.jsx)(n.code,{children:"this"})," keyword, which refers to the current\n",(0,s.jsx)(n.code,{children:"Object"})," instance itself. Let's add a ",(0,s.jsx)(n.code,{children:"toString()"})," method to our ",(0,s.jsx)(n.code,{children:"part"})," ",(0,s.jsx)(n.code,{children:"Object"})," above:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let part = {\n  id: 5,\n  info: {\n    name: 'inner gasket',\n    shelf: 56713,\n    ref: [5618, 5693],\n  },\n  toString: function () {\n    return `${this.info.name} (#${this.id})`;\n  },\n};\n\nconsole.log(part.toString()); // prints \"inner gasket (#5)\" to the console.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"toString"})," property is just like any other key we've added previously, except its value\nis an ",(0,s.jsx)(n.em,{children:"anonymous function"}),". Just as we previously bound function expressions to variables,\nhere a function expression is bound to an ",(0,s.jsx)(n.code,{children:"Object"}),"'s property. When we write ",(0,s.jsx)(n.code,{children:"part.toString"})," we\nare accessing the function stored at this key, and by adding the ",(0,s.jsx)(n.code,{children:"()"})," operator, we can invoke it:\n",(0,s.jsx)(n.code,{children:"part.toString()"})," says ",(0,s.jsx)(n.em,{children:"get the function stored at part.toString and call it"}),". Our function\naccesses other properties on the ",(0,s.jsx)(n.code,{children:"part"})," ",(0,s.jsx)(n.code,{children:"Object"})," by using ",(0,s.jsx)(n.code,{children:"this.*"})," instead of ",(0,s.jsx)(n.code,{children:"part.*"}),". When the\nfunction is run, ",(0,s.jsx)(n.code,{children:"this"})," will be the same as ",(0,s.jsx)(n.code,{children:"part"})," (i.e., a reference to ",(0,s.jsx)(n.em,{children:"this"})," ",(0,s.jsx)(n.code,{children:"Object"})," instance)."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this",children:[(0,s.jsx)(n.code,{children:"this"})," keyword in JavaScript"]})," is used in different contexts, and has a different meaning depending on where and how it is used. We will return to ",(0,s.jsx)(n.code,{children:"this"})," and its various meanings throughout the course."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"suggested-readings",children:"Suggested Readings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS",children:"Object-oriented JavaScript for beginners"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"http://exploringjs.com/es5/ch17.html",children:"ExploringJS, Chapter 17. Objects and Inheritance"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"http://exploringjs.com/es5/ch20.html",children:"ExploringJS, Chapter 20. Dates"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"http://exploringjs.com/es5/ch21.html",children:"ExploringJS, Chapter 21. Math"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const s={},o=r.createContext(s);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);