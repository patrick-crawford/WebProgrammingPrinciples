"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[5679],{309:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"Functions-Scope/Scope-Closures","title":"Scope & Closures","description":"Scope & Closures","source":"@site/docs/Functions-Scope/Scope-Closures.md","sourceDirName":"Functions-Scope","slug":"/Functions-Scope/Scope-Closures","permalink":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Functions-Scope/Scope-Closures.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"Scope-Closures","title":"Scope & Closures","sidebar_position":2,"description":"Scope & Closures"},"sidebar":"courseNotesSidebar","previous":{"title":"Functions","permalink":"/WebProgrammingPrinciples/Functions-Scope/Functions"},"next":{"title":"Practice Exercises","permalink":"/WebProgrammingPrinciples/Functions-Scope/Practice-Exercises"}}');var o=i(4848),t=i(8453);const a={id:"Scope-Closures",title:"Scope & Closures",sidebar_position:2,description:"Scope & Closures"},c="Scope",r={},l=[{value:"Overwriting Variables in Child Scopes",id:"overwriting-variables-in-child-scopes",level:2},{value:"Closures",id:"closures",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"scope",children:"Scope"})}),"\n",(0,o.jsxs)(n.p,{children:["JavaScript variables were historically ",(0,o.jsx)(n.em,{children:"declared"})," with the ",(0,o.jsx)(n.code,{children:"var"})," keyword. Modern JavaScript has switched to ",(0,o.jsx)(n.code,{children:"let"}),", ",(0,o.jsx)(n.code,{children:"const"}),". The way each works is different, and it's important to understand these differences."]}),"\n",(0,o.jsxs)(n.p,{children:["We often ",(0,o.jsx)(n.em,{children:"assign"})," a value when we ",(0,o.jsx)(n.em,{children:"declare"})," it, though we don't have to do both at once:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"let x; // declared, no assignment (value is `undefined`)\nx = 7; // assignment of previously declared variable\nlet y = x; // declaration and assignment combined\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A variable always has a ",(0,o.jsx)(n.em,{children:"scope"}),", which is the location(s) in the code where it\nis usable. Consider the variables ",(0,o.jsx)(n.code,{children:"total"})," and ",(0,o.jsx)(n.code,{children:"value"}),", as well as the\n",(0,o.jsx)(n.code,{children:"add"})," function below:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var total = 7; // global variable, accessible everywhere\n\nfunction add(n) {\n  var value = total + n; // local variable, accessible anywhere within the function only\n  return value;\n}\n\nconsole.log('Total is', total); // Works, because `total` is in the same scope\nconsole.log('Value is', value); // `undefined`, since `value` isn't defined in this scope\nconsole.log('New Total', add(16)); // Works, because `add` is defined in the same scope\n"})}),"\n",(0,o.jsxs)(n.p,{children:["When using the ",(0,o.jsx)(n.code,{children:"var"})," keyword, variables use ",(0,o.jsx)(n.em,{children:"function scope"}),", while variables declared with ",(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"})," use ",(0,o.jsx)(n.em,{children:"block scope"}),". Coming from C/C++, using ",(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"})," will likely feel more familiar`:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c",children:'int main()\n{\n  {\n      int x = 10;       // x is declared with block scope\n  }\n  {\n      printf("%d", x);  // Error: x is not accessible here\n  }\n  return 0;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Now in JavaScript:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function main() {\n  {\n    var x = 10; // x is declared in a block, but is scoped to `main`\n  }\n  {\n    console.log(x); // works, because `x` is accessible everywhere in `main`\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Because variables declared using ",(0,o.jsx)(n.code,{children:"var"})," have ",(0,o.jsx)(n.strong,{children:"function scope"}),", programmers tended to define them at the top of their functions. They don't strictly need to do this, since JavaScript will ",(0,o.jsx)(n.em,{children:"hoist"})," or raise all variables declared with ",(0,o.jsx)(n.code,{children:"var"})," in a function to the top of the function's scope:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function f() {\n  var y = x + 1;\n  var x = 2;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"At runtime, this will be transformed into the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function f() {\n    var x;          // declaration is hoisted (but not assignment) to the top\n\n    var y = x + 1;  // `NaN`, since `undefined` + 1 can't be resolved\n    x = 2;          // note: `x` is not declared above, only the assignment is now here\n"})}),"\n",(0,o.jsx)(n.p,{children:"This also happens when we forget to declare a local variable:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function f() {\n  x = 2; // `x` is assigned a value, but not declared\n  return x + 1;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"At runtime, this will be transformed into the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var x; // `x` is not found in the scope of `f`, so it becomes global\n\nfunction f() {\n  x = 2;\n  return x + 1;\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The previous example introduces another important concept with JavaScript scopes, namely,\nthat scopes can be ",(0,o.jsx)(n.em,{children:"nested"})," within one another. Hoisting is moving variable declarations to the beginning of a scope. For example, function declarations are hoisted completely, which means we can call a function ",(0,o.jsx)(n.em,{children:"before"})," we declare it."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"f(); // this will work, as f's declaration gets hoisted\nfunction f() {}\nf(); // this will also work, because f has been declared as you expect.\n\ng(); // this will not work, since g's declaration will be hoisted, but not the assignment.\nvar g = function () {};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Many of the confusing aspects of function scope and hoisting are solved by using ",(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"}),", which work at the block level instead. Consider these two loops:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Version 1 using var\nfor (var i = 0; i < 10; i++) {\n  console.log('The value of i is ' + i);\n}\n\n// Version 2 using let\nfor (let i = 0; i < 10; i++) {\n  console.log('The value of i is ' + i);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the preceding code, the scope of ",(0,o.jsx)(n.code,{children:"i"})," is different in version 1 vs. 2. In version 1, the declaration of ",(0,o.jsx)(n.code,{children:"i"})," will actually cause a variable to be created in the scope of the owning function. This may or may not be what you expect (i.e., the variable ",(0,o.jsx)(n.code,{children:"i"})," will exist outside the loop). In version 2, this is not the case, and ",(0,o.jsx)(n.code,{children:"i"})," is scoped to the function body only (i.e., you can't access it before or after the loop)."]}),"\n",(0,o.jsx)(n.p,{children:"We're discussing both function and block scopes because JavaScript supports each of them, and code you'll work on will use both methods. It's important to understand each approach."}),"\n",(0,o.jsxs)(n.p,{children:["For new code that you write, you are encouraged to prefer ",(0,o.jsx)(n.code,{children:"let"})," and ",(0,o.jsx)(n.code,{children:"const"})," and use block scope."]}),"\n",(0,o.jsx)(n.h2,{id:"overwriting-variables-in-child-scopes",children:"Overwriting Variables in Child Scopes"}),"\n",(0,o.jsxs)(n.p,{children:["Since variables defined with ",(0,o.jsx)(n.code,{children:"var"})," have function scope, and because functions can be nested, we have to be careful when naming our variables and arguments so as to not overwrite a variable in a parent scope. Or, we can use this to temporarily do exactly that. In both cases, we need to understand how nested scopes work."]}),"\n",(0,o.jsxs)(n.p,{children:["Consider the the following code, where a variable named ",(0,o.jsx)(n.code,{children:"x"})," is used in three different scopes. What will be printed to the ",(0,o.jsx)(n.code,{children:"console"})," when ",(0,o.jsx)(n.code,{children:"child"})," is called?"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var x = 1;\n\nfunction parent() {\n  var x = 2;\n\n  function child(x) {\n    console.log(x);\n  }\n\n  child(3);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The first declaration of ",(0,o.jsx)(n.code,{children:"x"})," creates a global variable (i.e., available in every scope).\nThen, in ",(0,o.jsx)(n.code,{children:"parent"})," we re-declare ",(0,o.jsx)(n.code,{children:"x"}),", creating a new local variable, which overwrites (or hides)\nthe global variable ",(0,o.jsx)(n.code,{children:"x"})," in this scope (i.e., within the body of ",(0,o.jsx)(n.code,{children:"parent"}),"). Next, we define\nyet another scope for ",(0,o.jsx)(n.code,{children:"child"}),", which also uses ",(0,o.jsx)(n.code,{children:"x"})," as the name of its only argument (essentially\nanother local variable). When we do ",(0,o.jsx)(n.code,{children:"child(3)"}),", we are binding the value ",(0,o.jsx)(n.code,{children:"3"})," to the ",(0,o.jsx)(n.code,{children:"x"}),"\nargument defined for the scope of ",(0,o.jsx)(n.code,{children:"child"}),", and in so doing yet again overwriting the parent ",(0,o.jsx)(n.code,{children:"x"}),".\nIn the end, the console will show ",(0,o.jsx)(n.code,{children:"3"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"We can do this in error as well, and cause unexpected behaviour:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var total = 5;\n\nfunction increase(n) {\n  var total = n + n;\n}\n\nincrease(50);\nconsole.log(total);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here we expect to see ",(0,o.jsx)(n.code,{children:"100"})," but instead will get ",(0,o.jsx)(n.code,{children:"5"})," on the ",(0,o.jsx)(n.code,{children:"console."})," The problem is\nthat we have redefined, and thus overwritten ",(0,o.jsx)(n.code,{children:"total"})," inside the ",(0,o.jsx)(n.code,{children:"increase"})," function. During\nthe call to ",(0,o.jsx)(n.code,{children:"increase"}),", the new local variable ",(0,o.jsx)(n.code,{children:"total"})," will be used, and then go out of scope.\nAfter the function completes, the original global variable ",(0,o.jsx)(n.code,{children:"total"})," will again be used."]}),"\n",(0,o.jsx)(n.h2,{id:"closures",children:"Closures"}),"\n",(0,o.jsxs)(n.p,{children:["A closure is a function that has ",(0,o.jsx)(n.em,{children:"closed over"})," a scope, retaining this scope even after it would\notherwise disappear through the normal rules of execution. In the following function, the\nvariable ",(0,o.jsx)(n.code,{children:"x"})," goes out of scope as soon as the function finishes executing:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function f() {\n  var x = 7;\n  return x * 2;\n  // After this return, and f completes, `x` will no longer be available.\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"In JavaScript, functions have access not only to their own local variables, but also\nto any variables in their parents' scope. That is, if a variable is used (referenced)\nbut not declared in a function, JavaScript will visit the parent scope to find the variable.\nThis can happen for any number of child/parent levels up to the global level."}),"\n",(0,o.jsx)(n.p,{children:"The following is an example of this, and probably one you've seen before:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"var x = 7;\n\nfunction f() {\n  return x * 2; // `x` not declared here, JS will look in the parent scope (global)\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Consider this example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function parent() {\n  var x = 7;\n\n  function child() {\n    return x * 2;\n  }\n\n  return child();\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here ",(0,o.jsx)(n.code,{children:"x"})," is used in ",(0,o.jsx)(n.code,{children:"child"}),", but declared in ",(0,o.jsx)(n.code,{children:"parent"}),". The ",(0,o.jsx)(n.code,{children:"child"})," function has access\nto all variables in its own scope, plus those in the ",(0,o.jsx)(n.code,{children:"parent"})," scope. This nesting of scopes\nrelies on JavaScript's function scope rules, and allows us to share data."]}),"\n",(0,o.jsx)(n.p,{children:"Sometimes we need to capture data in a parent scope, and retain it for a longer period of time\nthan would otherwise be granted for a given invocation. Consider this example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function createAccumulator(value) {\n  return function (n) {\n    value += n;\n    return value;\n  };\n}\n\nvar add = createAccumulator(10);\nadd(1); // returns 11\nadd(2); // returns 13\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here the ",(0,o.jsx)(n.code,{children:"createAccumulator"})," function takes an argument ",(0,o.jsx)(n.code,{children:"value"}),", the initial value to use\nfor an accumulator function. It returns an anonymous function which takes a value ",(0,o.jsx)(n.code,{children:"n"})," (a ",(0,o.jsx)(n.code,{children:"Number"}),") and adds it to the ",(0,o.jsx)(n.code,{children:"value"})," before returning it. The ",(0,o.jsx)(n.code,{children:"add"})," function is created by invoking ",(0,o.jsx)(n.code,{children:"createAccumulator"})," with the initial ",(0,o.jsx)(n.code,{children:"value"})," of ",(0,o.jsx)(n.code,{children:"10"}),". The function that is returned by ",(0,o.jsx)(n.code,{children:"createAccumulator"})," has access to ",(0,o.jsx)(n.code,{children:"value"})," in its parent's scope. Normally, ",(0,o.jsx)(n.code,{children:"value"})," would be\ndestroyed as soon as ",(0,o.jsx)(n.code,{children:"createAccumulator"})," finished executing. However, we have created a ",(0,o.jsx)(n.em,{children:"closure"})," to capture the variable ",(0,o.jsx)(n.code,{children:"value"})," in a scope that is now attached to the function we're creating and returning. As long as the returned function exists (i.e., as long as ",(0,o.jsx)(n.code,{children:"add"})," holds on to it), the variable ",(0,o.jsx)(n.code,{children:"value"})," will continue to exist in our child function's scope: the variables that existed when this function was created continue to live on like a memory, attached to the lifetime of the returned function."]}),"\n",(0,o.jsxs)(n.p,{children:["Closures make it possible to ",(0,o.jsx)(n.em,{children:"associate"})," some ",(0,o.jsx)(n.em,{children:"data"})," (i.e., the environment) with a\nfunction that can then operate on that data. We see similar strategies in pure\nobject-oriented languages, where data (properties) can be associated with an object,\nand functions (methods) can then operate on that data. Closures play a somewhat\nsimilar role, however, they are more lightweight and allow for dynamic (i.e., runtime)\nassociations."]}),"\n",(0,o.jsx)(n.p,{children:'By connecting data and functionality, closures help to reduce global variables, provide\nways to "hide" data, allow a mechanism for creating private "methods", avoid overwriting\nother variables in unexpected ways.'}),"\n",(0,o.jsx)(n.p,{children:"As we go further with JavaScript and web programming, we will encounter many instances\nwhere closures can be used to manage variable lifetimes, and associated functions with\nspecific objects. For now, be aware of their existence, and know that it is an advanced\nconcept that will take some time to fully master. This is only our first exposure to it."}),"\n",(0,o.jsxs)(n.p,{children:["Another way we'll see closures used, is in conjunction with ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Immediately-invoked_function_expression",children:"Immediately-Invoked Function Expressions (IIFE)"}),". Consider\nthe following rewrite of the code above:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"let add = (function (value) {\n  return function (n) {\n    value += n;\n    return value;\n  };\n})(10);\n\nadd(1); // returns 11\nadd(2); // returns 13\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here we've declared ",(0,o.jsx)(n.code,{children:"add"})," to be the value of invoking the anonymous function expression\nwritten between the first ",(0,o.jsx)(n.code,{children:"(...)"})," parentheses. In essence, we have created a function\nthat gets executed immediately, and which returns another function that we will use\ngoing forward in our program."]}),"\n",(0,o.jsxs)(n.p,{children:["This is an advanced technique to be aware of at this point, but not one you need to master\nright away. We'll see it used, and use it ourselves, in later weeks to to avoid global variables, simulate block scope in JavaScript, and to choose or generate function implementations at runtime (e.g., ",(0,o.jsx)(n.a,{href:"https://remysharp.com/2010/10/08/what-is-a-polyfill",children:"polyfill"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var s=i(6540);const o={},t=s.createContext(o);function a(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);