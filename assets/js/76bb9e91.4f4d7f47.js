"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[884],{5360:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"Functions-Scope/Functions","title":"Functions","description":"Functions","source":"@site/docs/Functions-Scope/Functions.md","sourceDirName":"Functions-Scope","slug":"/Functions-Scope/Functions","permalink":"/WebProgrammingPrinciples/Functions-Scope/Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Functions-Scope/Functions.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"Functions","title":"Functions","sidebar_position":1,"description":"Functions"},"sidebar":"courseNotesSidebar","previous":{"title":"Practice Exercises","permalink":"/WebProgrammingPrinciples/Introduction/Practice-Exercises"},"next":{"title":"Scope & Closures","permalink":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures"}}');var s=t(4848),i=t(8453);const r={id:"Functions",title:"Functions",sidebar_position:1,description:"Functions"},a="Functions",c={},l=[{value:"User-defined Functions",id:"user-defined-functions",level:2},{value:"Function Declarations",id:"function-declarations",level:3},{value:"Function Expressions",id:"function-expressions",level:3},{value:"Arrow Functions",id:"arrow-functions",level:3},{value:"Parameters and <code>arguments</code>",id:"parameters-and-arguments",level:3},{value:"Parameters and <code>...</code>",id:"parameters-and-",level:3},{value:"Dealing with Optional and Missing Arguments",id:"dealing-with-optional-and-missing-arguments",level:3},{value:"Return Value",id:"return-value",level:3},{value:"Function Naming",id:"function-naming",level:3},{value:"Invoking Functions, the Execution Operator",id:"invoking-functions-the-execution-operator",level:3},{value:"Built-in/Global Functions",id:"built-inglobal-functions",level:2},{value:"Suggested Readings",id:"suggested-readings",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"functions",children:"Functions"})}),"\n",(0,s.jsxs)(n.p,{children:["A function is a ",(0,s.jsx)(n.em,{children:"subprogram"}),", or a smaller portion of code that\ncan be called (i.e., invoked) by another part of your program, another function,\nor by the environment in response to some user or device action (e.g., clicking a button,\na network request, the page closing). Functions ",(0,s.jsx)(n.em,{children:"can"})," take values (i.e., arguments)\nand may ",(0,s.jsx)(n.em,{children:"return"})," a value."]}),"\n",(0,s.jsxs)(n.p,{children:["Functions are first-class members of JavaScript, and play a critical role in developing\nJavaScript programs. JavaScript functions can take other functions as arguments,\ncan return functions as values, can be bound to variables or ",(0,s.jsx)(n.code,{children:"Object"})," properties, and\ncan even have their own properties. We'll talk about more of this when we visit JavaScript's\nobject-oriented features."]}),"\n",(0,s.jsxs)(n.p,{children:["Learning to write code in terms of functions takes practice. JavaScript supports\n",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Functional_programming",children:"functional programming"}),". Web\napplications are composed of lots of small components that need to get wired together\nusing functions, have to share data (i.e., state), and interoperate with other code\nbuilt into the browser, or in third-party frameworks, libraries, and components."]}),"\n",(0,s.jsxs)(n.p,{children:["We use JavaScript functions in a number of ways. First, we encapsulate\na series of statements into higher-order logic, giving a name to a set of repeatable\nsteps we can call in different ways and places in our code. Second, we use them\nto define actions to be performed in response to events, whether user initiated or\ntriggered by the browser. Third, we use them to define behaviours for objects, what\nis normally called a ",(0,s.jsx)(n.em,{children:"member function"})," or ",(0,s.jsx)(n.em,{children:"method"}),". Fourth, we use them to define\n",(0,s.jsx)(n.em,{children:"constructor"})," functions, which are used to create new objects. We'll look at all\nof these in the coming weeks."]}),"\n",(0,s.jsxs)(n.p,{children:["Before we dive into that, we'll try to teach you that writing many smaller functions\nis often ",(0,s.jsx)(n.a,{href:"https://martinfowler.com/bliki/FunctionLength.html",children:"better than having a few large ones"}),". Smaller code is ",(0,s.jsx)(n.a,{href:"https://dzone.com/articles/rule-30-%E2%80%93-when-method-class-or",children:"easier to test, easier to understand"}),",\nand generally ",(0,s.jsx)(n.a,{href:"https://dubroy.com/blog/method-length-are-short-methods-actually-worse/",children:"has fewer bugs"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"user-defined-functions",children:"User-defined Functions"}),"\n",(0,s.jsx)(n.p,{children:"JavaScript has many built-in functions, which we'll get to below; however, it also\nallows you to write your own and/or use functions written by other developers (libraries, frameworks)."}),"\n",(0,s.jsx)(n.p,{children:"These user-defined functions can take a number of forms."}),"\n",(0,s.jsx)(n.h3,{id:"function-declarations",children:"Function Declarations"}),"\n",(0,s.jsxs)(n.p,{children:["The first is the ",(0,s.jsx)(n.em,{children:"function declaration"}),", which looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// The most basic function, a so-called NO OPERATION function\nfunction noop() {}\n\n// square function accepts one parameter `n`, returns its value squared.\nfunction square(n) {\n  return n * n;\n}\n\n// add function accepts two parameters, `a` and `b`, returns their sum.\nfunction add(a, b) {\n  return a + b;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here the ",(0,s.jsx)(n.code,{children:"function"})," keyword initiates a ",(0,s.jsx)(n.em,{children:"function declaration"}),", followed by a\n",(0,s.jsx)(n.em,{children:"name"}),", a ",(0,s.jsx)(n.em,{children:"parameter list"})," in round parenthesis, and the function's ",(0,s.jsx)(n.em,{children:"body"})," surrounded\nby curly braces. There is no semi-colon after the function body."]}),"\n",(0,s.jsx)(n.h3,{id:"function-expressions",children:"Function Expressions"}),"\n",(0,s.jsxs)(n.p,{children:["The second way to create a function is using a ",(0,s.jsx)(n.em,{children:"function expression"}),". Recall that\nexpressions evaluate to a value: a function expression evaluates to a ",(0,s.jsx)(n.code,{children:"function"})," Object.\nThe resulting value is often bound (i.e., assigned) to a variable, or used as a parameter."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let noop = function () {};\n\nlet square = function (n) {\n  return n * n;\n};\n\nlet add = function add(a, b) {\n  return a + b;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"A few things to note:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The function's ",(0,s.jsx)(n.em,{children:"name"})," is often omitted. Instead we return an ",(0,s.jsx)(n.em,{children:"anonymous function"})," and bind it to a variable. We'll access it again via the variable name. In the case of recursive functions, we sometimes include it to make it easier for functions to call themselves. You'll see it done both ways."]}),"\n",(0,s.jsxs)(n.li,{children:["We ",(0,s.jsx)(n.em,{children:"did"})," use a semi-colon at the end of our function expression. We do this to signify the end of our assignment statement ",(0,s.jsx)(n.code,{children:"let add = ... ;"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["In general, ",(0,s.jsx)(n.em,{children:"function declarations"})," are likely a better choice (when you can choose) due to subtle errors introduced with declaration order and hosting (see below); however, both are used widely and are useful."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"arrow-functions",children:"Arrow Functions"}),"\n",(0,s.jsxs)(n.p,{children:["Modern JavaScript also introduces a new function syntax called an ",(0,s.jsx)(n.a,{href:"https://eloquentjavascript.net/03_functions.html#h_/G0LSjQxoo",children:"Arrow Function"}),' or "Fat Arrow". These functions are more terse, using the ',(0,s.jsx)(n.code,{children:"=>"})," notation (not to be confused with the ",(0,s.jsx)(n.code,{children:"<="})," and ",(0,s.jsx)(n.code,{children:">="})," comparison operators):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let noop = () => {};\n\nlet square = (n) => n * n;\n\nlet add = (a, b) => a + b;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When you see ",(0,s.jsx)(n.code,{children:"let add = (a, b) => a + b;"})," it is short-hand for ",(0,s.jsx)(n.code,{children:"let add = function(a, b) { return a + b; }"}),", where ",(0,s.jsx)(n.code,{children:"=>"})," replaces the ",(0,s.jsx)(n.code,{children:"function"})," keyword and comes ",(0,s.jsx)(n.em,{children:"after"})," the parameter list, and the ",(0,s.jsx)(n.code,{children:"return"})," keyword is optional, when functions return a single value."]}),"\n",(0,s.jsxs)(n.p,{children:["Arrow functions also introduce some new semantics for the ",(0,s.jsx)(n.code,{children:"this"})," keyword, which we'll address later."]}),"\n",(0,s.jsx)(n.p,{children:"You should be aware of Arrow functions, since many web developers use them heavily. However, don't feel pressure to use them yet if you find their syntax confusing."}),"\n",(0,s.jsxs)(n.h3,{id:"parameters-and-arguments",children:["Parameters and ",(0,s.jsx)(n.code,{children:"arguments"})]}),"\n",(0,s.jsx)(n.p,{children:"Function definitions in both cases take parameter lists, which can be empty, single, or multiple\nin length. Just as with variable declaration, no type information is given:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function emptyParamList() {}\n\nfunction singleParam(oneParameter) {}\n\nfunction multipleParams(one, two, three, four) {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A function can ",(0,s.jsx)(n.em,{children:"accept"})," any number of arguments when it is called, including none. This would\nbreak in many other languages, but not JavaScript:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function log(a) {\n  console.log(a);\n}\n\nlog('correct'); // logs \"correct\"\nlog('also', 'correct'); // logs \"also\"\nlog(); // logs undefined\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because we can invoke a function with any number of arguments, we have to write our functions\ncarefully, and test things before we make assumptions. How can we deal with a caller\nsending 2 vs. 10 values to our function?"}),"\n",(0,s.jsxs)(n.p,{children:["One way we do this is using the built-in ",(0,s.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments",children:[(0,s.jsx)(n.code,{children:"arguments"})," Object"]}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Every function has an implicit ",(0,s.jsx)(n.code,{children:"arguments"})," variable available to it, which is an array-like\nobject containing all the arguments passed to the function. We can use ",(0,s.jsx)(n.code,{children:"arguments.length"})," to obtain the actual number of arguments passed to the function at runtime, and use array index\nnotation (e.g., ",(0,s.jsx)(n.code,{children:"arguments[0]"}),") to access an argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function log(a) {\n  console.log(arguments.length, a, arguments[0]);\n}\n\nlog(\'correct\'); // 1, "correct", "correct"\nlog(\'also\', \'correct\'); // 2, "also", "also"\nlog(); // 0, undefined, undefined\n'})}),"\n",(0,s.jsx)(n.p,{children:"We can use a loop to access all arguments, no matter the number passed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function sum() {\n  const count = arguments.length;\n  let total = 0;\n  for (let i = 0; i < count; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n\nsum(1); // 1\nsum(1, 2); // 3\nsum(1, 2, 3, 4); // 10\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You may have wondered previously how ",(0,s.jsx)(n.code,{children:"console.log()"}),' can work with one, two, three, or\nmore arguments. The answer is that all JavaScript functions work this way, and you can use it\nto "overload" your functions with different argument patterns, making them useful\nin more than one scenario.']}),"\n",(0,s.jsxs)(n.h3,{id:"parameters-and-",children:["Parameters and ",(0,s.jsx)(n.code,{children:"..."})]}),"\n",(0,s.jsxs)(n.p,{children:['Modern JavaScript also supports naming the "rest" of the parameters passed to a function. These ',(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters",children:"Rest Parameters"})," allow us to specify that all final arguments to a function, no matter how many, should be available to the function as a named ",(0,s.jsx)(n.code,{children:"Array"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["There are ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters#Difference_between_rest_parameters_and_the_arguments_object",children:"some advantages"})," to ",(0,s.jsx)(n.em,{children:"not"})," using the implicit ",(0,s.jsx)(n.code,{children:"arguments"})," keyword, which rest parameters provide."]}),"\n",(0,s.jsx)(n.p,{children:'We can convert the example above to this, naming our arbitrary list of "numbers":'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function sum(...numbers) {\n  let total = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    total += numbers[i];\n  }\n  return total;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dealing-with-optional-and-missing-arguments",children:"Dealing with Optional and Missing Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["Because we ",(0,s.jsx)(n.em,{children:"can"})," change the number of arguments we pass to a function at runtime, we\nalso have to deal with missing data, or optional parameters. Consider the case of\na function to calculate a player's score in a video game. In some cases we may want to\ndouble a value, for example, as a bonus for doing some action a third time in a row:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateScore(currentScore, value, bonus) {\n  return bonus ? currentScore + value * bonus : currentScore + value;\n}\n\nupdateScore(10, 3);\nupdateScore(10, 3);\nupdateScore(10, 3, 2);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here we call ",(0,s.jsx)(n.code,{children:"updateScore"})," three different times, sometimes with 2 arguments, and\nonce with 3. Our ",(0,s.jsx)(n.code,{children:"updateScore"})," function has been written so it will work in both cases.\nWe've used a ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator",children:"conditional ternary operator"})," to\ndecide whether or not to add an extra bonus score. When we say ",(0,s.jsx)(n.code,{children:"bonus ? ... : ..."})," we are\nchecking to see if the ",(0,s.jsx)(n.code,{children:"bonus"})," argument is ",(0,s.jsx)(n.em,{children:"truthy"})," or ",(0,s.jsx)(n.em,{children:"falsy"}),"--that is, did the caller provide a value for it? If they did, we do one thing, if not, we do another."]}),"\n",(0,s.jsx)(n.p,{children:"Here's another common way you'll see code like this written, using a default value:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateScore(currentScore, value, bonus) {\n  // See if `bonus` is truthy (has a value or is undefined) and use it, or default to 1\n  bonus = bonus || 1;\n  return currentScore + value * bonus;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, before we use the value of ",(0,s.jsx)(n.code,{children:"bonus"}),", we do an extra check to see if it\nactually has a value or not. If it does, we use that value as is; but if it doesn't, we\ninstead assign it a value of ",(0,s.jsx)(n.code,{children:"1"}),". Then, our calculation will always work, since multiplying\nthe value by ",(0,s.jsx)(n.code,{children:"1"})," will be the same as not using a bonus."]}),"\n",(0,s.jsxs)(n.p,{children:["The idiom ",(0,s.jsx)(n.code,{children:"bonus = bonus || 1"})," is very common in JavaScript. It uses the\n",(0,s.jsxs)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR_()",children:["Logical Or Operator ",(0,s.jsx)(n.code,{children:"||"})]})," to test whether ",(0,s.jsx)(n.code,{children:"bonus"})," evaluates to a value or not, and prefers that value if possible to the fallback default of ",(0,s.jsx)(n.code,{children:"1"}),". We could also have written it out using an ",(0,s.jsx)(n.code,{children:"if"})," statements like these:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateScore(currentScore, value, bonus) {\n  if (bonus) {\n    return currentScore + value * bonus;\n  }\n  return currentScore + value;\n}\n\nfunction updateScore(currentScore, value, bonus) {\n  if (!bonus) {\n    bonus = 1;\n  }\n  return currentScore + value * bonus;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript programmers tend to use the ",(0,s.jsx)(n.code,{children:"bonus = bonus || 1"})," pattern because it is\nless repetitive, using less code, and therefore less likely to introduce bugs. We could\nshorten it even further to this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateScore(currentScore, value, bonus) {\n  return currentScore + value * (bonus || 1);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Because this pattern is so common, modern JavaScript has added a built-in way to handle ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters",children:"Default Parameters"}),". Instead of using ",(0,s.jsx)(n.code,{children:"||"})," notation in the body of the function, we can specify a default value for any named parameter when it is declared. This frees us from having to check for, and set default values in the function body. Using default parameters, we could convert our code above to this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateScore(currentScore, value, bonus = 1) {\n  return currentScore + value * bonus;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now, if ",(0,s.jsx)(n.code,{children:"bonus"})," has a value (i.e., is passed as a parameter), we use it; otherwise, we use ",(0,s.jsx)(n.code,{children:"1"})," as a default."]}),"\n",(0,s.jsx)(n.h3,{id:"return-value",children:"Return Value"}),"\n",(0,s.jsxs)(n.p,{children:["Functions always ",(0,s.jsx)(n.em,{children:"return"})," a value, whether implicitly or explicitly. If the ",(0,s.jsx)(n.code,{children:"return"}),"\nkeyword is used, the expression following it is returned from the function. If\nit is omitted, the function will return ",(0,s.jsx)(n.code,{children:"undefined"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function implicitReturnUndefined() {\n  // no return keyword, the function will return `undefined` anyway\n}\n\nfunction explicitReturnUndefined() {\n  return;\n  // return keyword, but no expression given, which is also `undefined`\n}\n\nfunction explicitReturn() {\n  return 1;\n  // return keyword, followed by `Number` expression evalutes to `Number`\n}\n\nfunction explicitReturn2() {\n  return 'Hello' + ' World!';\n  // return keyword, followed by expression evaluating to a `String`\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"function-naming",children:"Function Naming"}),"\n",(0,s.jsxs)(n.p,{children:["Functions are typically named using the same rules we learned for naming any\nvariable: ",(0,s.jsx)(n.code,{children:"camelCase"})," and using the set of valid letters, numbers, etc. and avoiding\nlanguage keywords."]}),"\n",(0,s.jsx)(n.p,{children:"Function declarations always give a name to the function, while function expressions\noften omit it, using a variable name instead:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Name goes after the `function` keyword in a declaration\nfunction validateUser() {\n    ...\n}\n\n// Name is used only at the level of the bound variable, function is anonymous\nlet validateUser = function() {\n    ...\n};\n\n// Name is repeated, which is correct but not common. Used with recursive functions\nlet validateUser = function validateUser() {\n    ...\n};\n\n// Names are different, which is also correct, but not common as it can lead to confusion\nlet validateUser = function validate() {\n    // the validate name is only accessible here, within the function body\n    ...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Because JavaScript allows us to bind function objects (i.e., result of function expressions)\nto variables, it is common to create functions without names, but immediately pass them\nto functions as arguments. The only way to use this function is via the argument name:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// The parameter `fn` will be a function, and `n` a number\nfunction execute(fn, n) {\n  // Call the function referred to by the argument (i.e, variable) `fn`, passing `n` as its argument\n  return fn(n);\n}\n\n// 1. Call the `execute` function, passing an anonymous function, which squares its argument, and the value 3\nexecute(function (n) {\n  return n * n;\n}, 3);\n\n// 2. Same thing as above, but with different formatting\nexecute(function (n) {\n  return n * n;\n}, 3);\n\n// 3. Same thing as above, using an Arrow Function\nexecute((n) => n * n, 3);\n\nlet doubleIt = function (num) {\n  return num * 2;\n};\n\n// 4. Again call `execute`, but this time pass `doubleIt` as the function argument\nexecute(doubleIt, 3);\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can also use functions declared via function declarations used this way, and bind them to variables:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function greeting(greeting, name) {\n  return greeting + ' ' + name;\n}\n\nvar sayHi = greeting; // also bind a reference to greeting to sayHi\n\n// We can now call `greeting` either with `greeting()` or `sayHi()`\nconsole.log(greeting('Hello', 'Steven'));\nconsole.log(sayHi('Hi', 'Kim'));\n"})}),"\n",(0,s.jsx)(n.p,{children:"JavaScript treats functions like other languages treat numbers or booleans, and lets\nyou use them as values. This is a very powerful feature, but can cause some confusion\nas you get started with JavaScript."}),"\n",(0,s.jsx)(n.p,{children:"You might ask why we would ever choose to define functions using variables. One common reason is to swap function implementations at runtime, depending on the state of the program. Consider the following code for displaying the user interface depending on whether the user is logged in or not:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Display partial UI for guests and non-authenticated users, hiding some features\nfunction showUnauthenticatedUI() {\n    ...\n}\n\n// Display full UI for authenticated users\nfunction showAuthenticatedUI() {\n    ...\n}\n\n// We will never call showUnauthenticatedUI or showAuthenticatedUI directly.\n// Instead, we will use showUI to hold a reference to one or the other,\n// and default to the unauthenticated version at first (i.e., until the user logs in).\nlet showUI = showUnauthenticatedUI;\n\n...\n\n// Later in the program, when a user logs in, we can swap the implementation\n// without touching any of our UI code.\nfunction authenticate(user) {\n    ...\n    showUI = showAuthenticatedUI;\n}\n\n...\n\n// Whenever we need to refresh/display the UI, we can always safely call\n// whichever function is currently bound to `showUI`.\nshowUI();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"invoking-functions-the-execution-operator",children:"Invoking Functions, the Execution Operator"}),"\n",(0,s.jsxs)(n.p,{children:["In many of the examples above, we've been invoking (i.e., calling, running, executing) functions\nbut haven't said much about it. We invoke a function by using the ",(0,s.jsx)(n.code,{children:"()"})," operator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let f = function () {\n  console.log('f was invoked');\n};\nf();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the code above, ",(0,s.jsx)(n.code,{children:"f"})," is a variable that is assigned the value returned by a function expression. This means ",(0,s.jsx)(n.code,{children:"f"})," is a regular variable, and we can use it like any other variable. For example, we could create another variable and share its value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let f = function () {\n  console.log('f was invoked');\n};\nlet f2 = f;\nf(); // invokes the function\nf2(); // also invokes the function\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"f"})," and ",(0,s.jsx)(n.code,{children:"f2"})," refer to the the same function object. What is the difference\nbetween saying ",(0,s.jsx)(n.code,{children:"f"})," vs. ",(0,s.jsx)(n.code,{children:"f()"})," in the line ",(0,s.jsx)(n.code,{children:"let f2 = f;"}),"? When we write ",(0,s.jsx)(n.code,{children:"f()"}),'\nwe are really saying, "Get the value of ',(0,s.jsx)(n.code,{children:"f"}),' (the function referred to) and invoke it." However,\nwhen we write ',(0,s.jsx)(n.code,{children:"f"})," (without ",(0,s.jsx)(n.code,{children:"()"}),'), we are saying, "Get the value of ',(0,s.jsx)(n.code,{children:"f"}),' (the function referred to)" so that we can do something with it (assign it to another variable, pass it to a function, etc).']}),"\n",(0,s.jsxs)(n.p,{children:["The same thing is true of function declarations, which also produce ",(0,s.jsx)(n.code,{children:"function"})," Objects:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function f() {\n  console.log('f was invoked');\n}\nlet f2 = f;\nf2(); // also invokes the function\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The distinction between referring to a function object via its bound variable name (",(0,s.jsx)(n.code,{children:"f"}),") vs\ninvoking that same function (",(0,s.jsx)(n.code,{children:"f()"}),") is important, because JavaScript programs treat functions\nas ",(0,s.jsx)(n.em,{children:"data"}),", just as you would a ",(0,s.jsx)(n.code,{children:"Number"}),". Consider the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function checkUserName(userName, customValidationFn) {\n  // If `customValidationFn` exists, and is a function, use that to validate `userName`\n  if (customValidationFn && typeof customValidationFn === 'function') {\n    return customValidationFn(userName);\n  }\n  // Otherwise, use a default validation function\n  return defaultValidationFn(userName);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here the ",(0,s.jsx)(n.code,{children:"checkUserName"})," function takes two arguments: the first a ",(0,s.jsx)(n.code,{children:"String"})," for a username;\nthe second an optional (i.e., may not exist) function to use when validating this username.\nDepending on whether or not we are passed a function for ",(0,s.jsx)(n.code,{children:"customValidationFn"}),", we will either\nuse it, or use a default validation function (defined somewhere else)."]}),"\n",(0,s.jsxs)(n.p,{children:["Notice the line ",(0,s.jsx)(n.code,{children:"if(customValidationFn && typeof customValidationFn === 'function') {"})," where\n",(0,s.jsx)(n.code,{children:"customValidationFn"})," is used like any other variable (accessing the value it refers to vs. doing an invocation), to check if it has a value, and if its value is actually a function. Only then is it save to invoke it."]}),"\n",(0,s.jsx)(n.p,{children:"It's important to remember that JavaScript functions aren't executed until they are called\nvia the invocation operator, and may also be used as values without being called."}),"\n",(0,s.jsx)(n.h2,{id:"built-inglobal-functions",children:"Built-in/Global Functions"}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript provides a small number of ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Function_properties",children:"built-in global functions"})," for working with its data types, for example:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt",children:(0,s.jsx)(n.code,{children:"parseInt()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat",children:(0,s.jsx)(n.code,{children:"parseFloat()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN",children:(0,s.jsx)(n.code,{children:"isNaN()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite",children:(0,s.jsx)(n.code,{children:"isFinite()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI",children:(0,s.jsx)(n.code,{children:"decodeURI()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent",children:(0,s.jsx)(n.code,{children:"decodeURIComponent()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI",children:(0,s.jsx)(n.code,{children:"encodeURI()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent",children:(0,s.jsx)(n.code,{children:"encodeURIComponent()"})})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There are also global functions that exist for historical reasons, but should be avoided for performance, usability, and/or security reasons:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",children:(0,s.jsx)(n.code,{children:"eval()"})})," dangerous to parse and run user-defined strings"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt",children:(0,s.jsx)(n.code,{children:"prompt()"})})," and ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/alert",children:(0,s.jsx)(n.code,{children:"alert()"})})," synchronous calls that block the UI thread."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:['Most of JavaScripts "standard library" comes in the form of ',(0,s.jsx)(n.em,{children:"methods"})," on global objects\nvs. global functions. A ",(0,s.jsx)(n.em,{children:"method"})," is a function that is bound to a variable belonging\nto an object, also known as a ",(0,s.jsx)(n.em,{children:"property"}),". We'll be covering these in more depth later, but\nhere are some examples"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/console",children:(0,s.jsx)(n.code,{children:"console.*"})}),". There are\nquite a few worth learning, but here are some to get you started:\n_ ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/log",children:(0,s.jsx)(n.code,{children:"console.log()"})}),", ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/warn",children:(0,s.jsx)(n.code,{children:"console.warn()"})}),", and ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/error",children:(0,s.jsx)(n.code,{children:"console.error()"})}),"\n_ ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/assert",children:(0,s.jsx)(n.code,{children:"console.assert()"})}),"\n_ ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/count",children:(0,s.jsx)(n.code,{children:"console.count()"})}),"\n_ ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Console/dir",children:(0,s.jsx)(n.code,{children:"console.dir()"})})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math",children:(0,s.jsx)(n.code,{children:"Math.*"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs",children:(0,s.jsx)(n.code,{children:"Math.abs()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max",children:(0,s.jsx)(n.code,{children:"Math.max()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min",children:(0,s.jsx)(n.code,{children:"Math.min()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random",children:(0,s.jsx)(n.code,{children:"Math.random()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round",children:(0,s.jsx)(n.code,{children:"Math.round()"})})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",children:(0,s.jsx)(n.code,{children:"Date.*"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now",children:(0,s.jsx)(n.code,{children:"Date.now()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime",children:(0,s.jsx)(n.code,{children:"Date.getTime()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth",children:(0,s.jsx)(n.code,{children:"Date.getMonth()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay",children:(0,s.jsx)(n.code,{children:"Date.getDay()"})})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",children:(0,s.jsx)(n.code,{children:"JSON.*"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse",children:(0,s.jsx)(n.code,{children:"JSON.parse()"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify",children:(0,s.jsx)(n.code,{children:"JSON.stringify()"})})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Much of web programming is done using ",(0,s.jsx)(n.code,{children:"Objects"})," and calling their methods. JavaScript is a small language, but the ecosystem of ",(0,s.jsx)(n.code,{children:"Objects"}),", APIs, libraries, and frameworks allows it to do anything."]}),"\n",(0,s.jsx)(n.h2,{id:"suggested-readings",children:"Suggested Readings"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"http://exploringjs.com/es5/ch15.html",children:"ExploringJS, Chapter 15. Functions"})," and ",(0,s.jsx)(n.a,{href:"http://exploringjs.com/es5/ch16.html",children:"Chapter 16. Variables: Scopes, Environments, and Closures"})]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://eloquentjavascript.net/03_functions.html",children:"Eloquent JavaScript, Chapter 3. Functions"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",children:"Functions Guide"})," and ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",children:"Reference"})," on MDN."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);