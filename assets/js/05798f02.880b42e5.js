"use strict";(self.webpackChunkOERTemplate=self.webpackChunkOERTemplate||[]).push([[486],{5733:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Advanced-Objects-Inheritance/Constructor-Functions","title":"Constructor Functions","description":"Constructor Functions","source":"@site/docs/Advanced-Objects-Inheritance/Constructor-Functions.md","sourceDirName":"Advanced-Objects-Inheritance","slug":"/Advanced-Objects-Inheritance/Constructor-Functions","permalink":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions","draft":false,"unlisted":false,"editUrl":"https://github.com/catherine-leung/OERTemplate/tree/main/docs/Advanced-Objects-Inheritance/Constructor-Functions.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"Constructor-Functions","title":"Constructor Functions","sidebar_position":2,"description":"Constructor Functions"},"sidebar":"courseNotesSidebar","previous":{"title":"Objects in JavaScript","permalink":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript"},"next":{"title":"Practice Exercise","permalink":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Practice-Exercise"}}');var o=t(4848),r=t(8453);const i={id:"Constructor-Functions",title:"Constructor Functions",sidebar_position:2,description:"Constructor Functions"},c="Constructor Functions",a={},d=[{value:"Object Prototypes",id:"object-prototypes",level:2},{value:"JavaScript&#39;s <code>class</code> and <code>Object</code>",id:"javascripts-class-and-object",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"constructor-functions",children:"Constructor Functions"})}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes we need to create lots of ",(0,o.jsx)(n.code,{children:"Objects"})," that have the same layout. For example, we might\nbe defining lots of users in an application. All of our user ",(0,o.jsx)(n.code,{children:"Objects"})," need to work the same way\nso that we can pass them around within our program, to and from functions. Every ",(0,o.jsx)(n.code,{children:"user"})," needs\nto have the same set of properties and methods, so we decide to write a factory function that can\nbuild our ",(0,o.jsx)(n.code,{children:"user"})," ",(0,o.jsx)(n.code,{children:"Objects"})," for us based on some data. We call such functions a ",(0,o.jsx)(n.code,{children:"Constructor"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Define a Constructor function, `User`\nfunction User(id, name) {\n  // Attach the id to an Object referenced by `this`\n  this.id = id;\n  // Attach the name to an Object referenced by `this`\n  this.name = name;\n}\n\n// Create a new instance of a User (Object)\nlet user1 = new User(1, 'Sam Smith');\n// Create another new instance of a User (Object)\nlet user2 = new User(2, 'Joan Winston');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice that unlike all previous functions we've defined, the ",(0,o.jsx)(n.code,{children:"User"})," function starts with a\ncapital ",(0,o.jsx)(n.code,{children:"U"})," instead of a lower case ",(0,o.jsx)(n.code,{children:"u"}),". We use this naming convention to indicate that\n",(0,o.jsx)(n.code,{children:"User"})," is special: a constructor function. A constructor function needs to be called with\nthe extra ",(0,o.jsx)(n.code,{children:"new"})," keyword in front of it. When we say ",(0,o.jsx)(n.code,{children:"new User(...)"})," we are saying,\n",(0,o.jsx)(n.em,{children:"create a new object, and pass it along to User so it can attach various things to it"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["A constructor can also add methods to an object via ",(0,o.jsx)(n.code,{children:"this"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Define a Constructor function, `User`\nfunction User(id, name) {\n  this.id = id;\n  this.name = name;\n\n  // Add a toString method\n  this.toString = function () {\n    return `${this.name} (#${this.id})`;\n  };\n}\n\n// Create a new instance of a User (Object)\nlet user1 = new User(1, 'Sam Smith');\nconsole.log(user1.toString()); // 'Sam Smith (#1)\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the code above, we're creating a new function every time we create a new User. As we\nstart to create lots of users, we'll also be creating lots of duplicate functions. This will\ncause our program to use more and more resources (memory), which can lead to issues as the\nprogram scales."}),"\n",(0,o.jsx)(n.h2,{id:"object-prototypes",children:"Object Prototypes"}),"\n",(0,o.jsxs)(n.p,{children:["What we would really like is a way to separate the parts of a User that are different for each\nuser (the data: ",(0,o.jsx)(n.code,{children:"id"}),", ",(0,o.jsx)(n.code,{children:"name"}),"), but somehow share the parts that are the same (the methods: ",(0,o.jsx)(n.code,{children:"toString"}),").\nJavaScript gives us a way to accomplish this via an ",(0,o.jsx)(n.code,{children:"Object"}),"'s ",(0,o.jsx)(n.code,{children:"prototype"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["JavaScript is unique among programming languages in the way it accomplishes sharing\nbetween ",(0,o.jsx)(n.code,{children:"Object"}),"s. All object-oriented languages provide some mechanism for us to share or\ninherit things like methods in a type hierarchy. For example, C++ and Java use classes, which\ncan inherit from one another to define methods on parents vs. children.\nJavaScript uses ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain",children:(0,o.jsx)(n.em,{children:"prototypal inheritance"})})," and a special property called ",(0,o.jsx)(n.code,{children:"prototype"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["In JavaScript, we always talk about ",(0,o.jsx)(n.code,{children:"Object"}),"s, because every object is an instance of ",(0,o.jsx)(n.code,{children:"Object"}),".\nNotice the capital ",(0,o.jsx)(n.code,{children:"O"})," in ",(0,o.jsx)(n.code,{children:"Object"}),", which should give you an indication of what it is: a constructor\nfunction. In a previous week we said that an ",(0,o.jsx)(n.code,{children:"Array"})," is an ",(0,o.jsx)(n.code,{children:"Object"}),", and a ",(0,o.jsx)(n.code,{children:"RegExp"})," is an ",(0,o.jsx)(n.code,{children:"Object"}),".\nThis is true because of JavaScript's type system, where almost everything is ",(0,o.jsx)(n.em,{children:"chained"})," to ",(0,o.jsx)(n.code,{children:"Object"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["JavaScript objects always have a prototype, which is an object to which their ",(0,o.jsx)(n.code,{children:".prototype"})," property\nrefers. At runtime, when we refer to an object's property, JavaScript first looks for that property\non the object itself. If it doesn't find it, the prototype object is visited, and the same search is\ndone. The process continues until the end of the prototype chain is reached at ",(0,o.jsx)(n.code,{children:"Object"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's rewrite our ",(0,o.jsx)(n.code,{children:"User"})," so that the ",(0,o.jsx)(n.code,{children:"toString"})," method is moved from each user instance to the\nprototype of all user instances:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// Define a Constructor function, `User`\nfunction User(id, name) {\n  this.id = id;\n  this.name = name;\n}\n\nUser.prototype.toString = function () {\n  return `${this.name} (#${this.id})`;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This code looks very similar to what we originally wrote. Notice that we've moved\n",(0,o.jsx)(n.code,{children:"toString"})," out of the ",(0,o.jsx)(n.code,{children:"User"})," function, and instead attached it to ",(0,o.jsx)(n.code,{children:"User.prototype"}),".\nBy doing so, we'll only ever need a single copy of this function: every ",(0,o.jsx)(n.code,{children:"new User()"})," instance\nwe create will also include a reference to a prototype object, which contains our function.\nWhen we use ",(0,o.jsx)(n.code,{children:"user1.toString()"}),", JavaScript will do something like this:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["does ",(0,o.jsx)(n.code,{children:"user1"})," have a property called ",(0,o.jsx)(n.code,{children:"toString"}),"? No, we didn't add one in the constructor."]}),"\n",(0,o.jsxs)(n.li,{children:["does ",(0,o.jsx)(n.code,{children:"user1.prototype"})," have a property called ",(0,o.jsx)(n.code,{children:"toString"}),"? Yes, use that."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["What if we'd written ",(0,o.jsx)(n.code,{children:"user1.something()"}),"?"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["does ",(0,o.jsx)(n.code,{children:"user1"})," have a property called ",(0,o.jsx)(n.code,{children:"something"}),"? No, we didn't add one in the constructor."]}),"\n",(0,o.jsxs)(n.li,{children:["does ",(0,o.jsx)(n.code,{children:"user1.prototype"})," have a property called ",(0,o.jsx)(n.code,{children:"something"}),"? No."]}),"\n",(0,o.jsxs)(n.li,{children:["does ",(0,o.jsx)(n.code,{children:"user1.prototype.prototype"})," (i.e., ",(0,o.jsx)(n.code,{children:"Object"}),") have a property called ",(0,o.jsx)(n.code,{children:"something"}),"? No."]}),"\n",(0,o.jsx)(n.li,{children:"there are no more objects in the prototype chain, throw an error"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"user1.something();\n// TypeError: user1.something is not a function\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Whenever a method is used on a prototype, we still pass the current instance so we can get access\nto its data. Notice in our ",(0,o.jsx)(n.code,{children:"User.prototype.toString"})," method, we still referred to ",(0,o.jsx)(n.code,{children:"this"}),", which\nwill be the instance of our user, and give us access to the correct data (",(0,o.jsx)(n.code,{children:"name"}),", ",(0,o.jsx)(n.code,{children:"id"}),")."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["There are times when defining a method inside a constructor makes sense vs. putting it on the prototype. The prototype will only have access to ",(0,o.jsx)(n.em,{children:"public properties"})," of an object instance, meaning things you explicitly add to ",(0,o.jsx)(n.code,{children:"this"})," and expose to the rest of your program. Sometimes we want to define some data, but ",(0,o.jsx)(n.em,{children:"hide"})," it from the rest of a program, so it can't be changed after it gets created. Consider the following example, which uses a ",(0,o.jsx)(n.em,{children:"closure"})," to retain access to a variable in the scope of the constructor without exposing it:"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function User(id, name) {\n  this.id = id;\n  this.name = name;\n\n  // private variable within User function, not attached to `this`.\n  // Normally this variable would go out of scope after User() completed;\n  // however, we will use a closure function below to capture this scope.\n  let createdAt = Date.now();\n\n  // Return the number of ms this player has been playing\n  this.playerAgeMS = function () {\n    let currentTime = Date.now();\n\n    // Access `createdAt` in the parent scope, which we retain via this closure function.\n    // Calculate how many ms between createdAt and the current time.\n    return currentTime - createdAt + ' ms';\n  };\n}\n\nlet user = new User(1, 'Tom');\n// We can access the total time this player has existed, but not modify it.\nconsole.log(user.playerAgeMS());\n// displays \"4183 ms\"\nconsole.log(user.playerAgeMS());\n// displays \"5287 ms\"\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"javascripts-class-and-object",children:["JavaScript's ",(0,o.jsx)(n.code,{children:"class"})," and ",(0,o.jsx)(n.code,{children:"Object"})]}),"\n",(0,o.jsxs)(n.p,{children:["For a long time, JavaScript didn't have any notion of a class. Most Object-Oriented languages are based on the idea of a class, but JavaScript only has runtime instances (i.e., ",(0,o.jsx)(n.code,{children:"Object"}),"s) and didn't need them."]}),"\n",(0,o.jsxs)(n.p,{children:["In recent years, a new syntax has been added to JavaScript to allow those more familiar with traditional OOP style programming to define their ",(0,o.jsx)(n.code,{children:"Object"}),"s using a new ",(0,o.jsx)(n.code,{children:"class"})," keyword."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's recreate our code above as a ",(0,o.jsx)(n.code,{children:"class"})," in JavaScript:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"class User {\n  id;\n  name;\n\n  constructor(id, name) {\n    this.id = id;\n    this.name = name;\n  }\n\n  toString() {\n    return `${this.name} (#${this.id})`;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This code still uses the same prototype technique we learned above above, but does so in a more familiar syntax."}),"\n",(0,o.jsx)(n.p,{children:"We can even use other OOP features like inheritance:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"class Student extends User {\n  email;\n\n  constructor(id, name, email) {\n    // Call the User() constructor to set the inherited properties\n    super(id, name);\n    this.email = email;\n  }\n\n  // Override the toString() method for a Student\n  toString() {\n    return `\"${this.name}\" <${this.email}>`;\n  }\n}\n\nlet student = new Student('10234134', 'Jen Hogan', 'jhogan@myseneca.ca');\nconsole.log(student.id, student.name, student.email);\nconsole.log(student.toString());\n"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(6540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);