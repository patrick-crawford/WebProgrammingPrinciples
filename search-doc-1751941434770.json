{"searchDocs":[{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Box-Model-Layout/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"Constructor Functions","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions","content":"","keywords":"","version":"Next"},{"title":"Object Prototypes​","type":1,"pageTitle":"Constructor Functions","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions#object-prototypes","content":" What we would really like is a way to separate the parts of a User that are different for each user (the data: id, name), but somehow share the parts that are the same (the methods: toString). JavaScript gives us a way to accomplish this via an Object's prototype.  JavaScript is unique among programming languages in the way it accomplishes sharing between Objects. All object-oriented languages provide some mechanism for us to share or inherit things like methods in a type hierarchy. For example, C++ and Java use classes, which can inherit from one another to define methods on parents vs. children. JavaScript uses prototypal inheritance and a special property called prototype.  In JavaScript, we always talk about Objects, because every object is an instance of Object. Notice the capital O in Object, which should give you an indication of what it is: a constructor function. In a previous week we said that an Array is an Object, and a RegExp is an Object. This is true because of JavaScript's type system, where almost everything is chained to Object.  JavaScript objects always have a prototype, which is an object to which their .prototype property refers. At runtime, when we refer to an object's property, JavaScript first looks for that property on the object itself. If it doesn't find it, the prototype object is visited, and the same search is done. The process continues until the end of the prototype chain is reached at Object.  Let's rewrite our User so that the toString method is moved from each user instance to the prototype of all user instances:  // Define a Constructor function, `User` function User(id, name) { this.id = id; this.name = name; } User.prototype.toString = function () { return `${this.name} (#${this.id})`; };   This code looks very similar to what we originally wrote. Notice that we've movedtoString out of the User function, and instead attached it to User.prototype. By doing so, we'll only ever need a single copy of this function: every new User() instance we create will also include a reference to a prototype object, which contains our function. When we use user1.toString(), JavaScript will do something like this:  does user1 have a property called toString? No, we didn't add one in the constructor.does user1.prototype have a property called toString? Yes, use that.  What if we'd written user1.something()?  does user1 have a property called something? No, we didn't add one in the constructor.does user1.prototype have a property called something? No.does user1.prototype.prototype (i.e., Object) have a property called something? No.there are no more objects in the prototype chain, throw an error  user1.something(); // TypeError: user1.something is not a function   Whenever a method is used on a prototype, we still pass the current instance so we can get access to its data. Notice in our User.prototype.toString method, we still referred to this, which will be the instance of our user, and give us access to the correct data (name, id).  There are times when defining a method inside a constructor makes sense vs. putting it on the prototype. The prototype will only have access to public properties of an object instance, meaning things you explicitly add to this and expose to the rest of your program. Sometimes we want to define some data, but hide it from the rest of a program, so it can't be changed after it gets created. Consider the following example, which uses a closure to retain access to a variable in the scope of the constructor without exposing it:  function User(id, name) { this.id = id; this.name = name; // private variable within User function, not attached to `this`. // Normally this variable would go out of scope after User() completed; // however, we will use a closure function below to capture this scope. let createdAt = Date.now(); // Return the number of ms this player has been playing this.playerAgeMS = function () { let currentTime = Date.now(); // Access `createdAt` in the parent scope, which we retain via this closure function. // Calculate how many ms between createdAt and the current time. return currentTime - createdAt + ' ms'; }; } let user = new User(1, 'Tom'); // We can access the total time this player has existed, but not modify it. console.log(user.playerAgeMS()); // displays &quot;4183 ms&quot; console.log(user.playerAgeMS()); // displays &quot;5287 ms&quot;   ","version":"Next","tagName":"h2"},{"title":"JavaScript's class and Object​","type":1,"pageTitle":"Constructor Functions","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Constructor-Functions#javascripts-class-and-object","content":" For a long time, JavaScript didn't have any notion of a class. Most Object-Oriented languages are based on the idea of a class, but JavaScript only has runtime instances (i.e., Objects) and didn't need them.  In recent years, a new syntax has been added to JavaScript to allow those more familiar with traditional OOP style programming to define their Objects using a new class keyword.  Let's recreate our code above as a class in JavaScript:  class User { id; name; constructor(id, name) { this.id = id; this.name = name; } toString() { return `${this.name} (#${this.id})`; } }   This code still uses the same prototype technique we learned above above, but does so in a more familiar syntax.  We can even use other OOP features like inheritance:  class Student extends User { email; constructor(id, name, email) { // Call the User() constructor to set the inherited properties super(id, name); this.email = email; } // Override the toString() method for a Student toString() { return `&quot;${this.name}&quot; &lt;${this.email}&gt;`; } } let student = new Student('10234134', 'Jen Hogan', 'jhogan@myseneca.ca'); console.log(student.id, student.name, student.email); console.log(student.toString());  ","version":"Next","tagName":"h2"},{"title":"Objects in JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript","content":"","keywords":"","version":"Next"},{"title":"Accessing Elements in an Object​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#accessing-elements-in-an-object","content":" Object property names are Strings, and we can refer to them either via the dot operator .name, or using the bracket operator ['name'] (similar to indexing in an Array):  let person = { name: 'Tim Wu' }; // get the value of the `name` property using the . operator console.log(person.name); // get the value of the `name` property using the [] operator console.log(person['name']);   Why would you choose the dot operator over the bracket operator, or vice versa? The dot operator is probably more commonly used; however, the bracket operator is useful in a number of scenarios. First, if you need to use a reserved JavaScript keyword for your property key, you'll need to refer to it as a string (e.g., obj['for']). Second, it's sometimes useful to be able to pass a variable in order to lookup a property value for a name that will be different at runtime. For example, if you are using usernames as keys, you might do users[currentUsername], where currentUsername is a variable holding a String for the logged in user.  ","version":"Next","tagName":"h2"},{"title":"Destructuring Objects​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#destructuring-objects","content":" In the same way that we destructured Array values into new variables, we can also use the same technique with an Object. Recall that JavaScript allows us to Destructuring Assignment to unpack values in an Array or Object into distinct variables. Consider each of the following methods, both of which accomplish the same goal:  With an Array, we learned that you can destructure various elements into new variables:  // Co-ordinates for Seneca's Newnham Campus let position = [43.796, -79.3486]; let [lat, lng] = position;   The same can be done with an Object. Imagine a complex Object, with lots of properties, but we're only interested in a few of them:  let senecaNewnham = { address: '1750 Finch Ave. East', city: 'Toronto', province: 'Ontario', postalCode: 'M2J 2X5', phoneNumber: '416.491.5050', lat: 43.796, lng: -79.3486, }; // Destructure only the `lat` and `lng` properties let { lat, lng } = senecaNewnham;   This is a powerful technique for extracting data from an Object.  ","version":"Next","tagName":"h3"},{"title":"Modifying Object Properties​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#modifying-object-properties","content":" Object literals allow us to define an initial set of properties on an Object, but we aren't limited to that set. We can easily add new ones:  let data = {}; data.score = 17; data.level = 3; data.health = '***';   Here we define an empty Object, but then add new properties. Because we can add properties after an Object is created, we always have to deal with a property not existing. If we try to access a property that does not exist on an Object, there won't be an error. Instead, we will get backundefined for its value:  let currentScore = data.score; // `score` exists on `data`, and we get back the value `17` let inventory = data.inventory; // `inventory` does not exist on `data`, so we get back `undefined`   Because properties may or may not exist at runtime, it's important to always check for a value before trying to use it. We could rewrite the above to first check if data has an inventoryproperty:  if (data.inventory) { // `data` has a value for `inventory`, use data.inventory here... } else { // there is no `inventory` on `data`, do something else... }   Another common situation where you have to deal with this is working with deep structures. Consider an Object that defines the structure of a level in a video game. The level includes various rooms, some of which contain a monster:  let gameLevel = { name: 'Level 1', rooms: { // Each room has a unique ID R31343: { name: 'Front Hallway', }, R31344: { name: 'Kitchen', monster: { name: 'Bear', strength: 15, }, }, R31345: { name: 'Back Hallway', }, R31346: { name: 'Sitting Room', monster: { name: 'Dog', strength: 8, }, }, }, };   When working this code, we can access a particular room by its ID:  // Get a reference to the Kitchen let room = gameLevel.rooms.R31344;   However, we used an ID that doesn't exist, we'd get back undefined:  // Get a reference to the TV Room (no such room!) let room = gameLevel.rooms.R31347; // &lt;-- room is `undefined`   If we then try to access the monster in that room, our program will crash:  let room = gameLevel.rooms.R31347; // &lt;-- room is `undefined` console.log(room.monster); // &lt;-- crash! room is `undefined` so we can't access `monster within it   JavaScript provides a few ways to deal with this problem. Consider:  let room = gameLevel.rooms.R31347; // Version 1 if (room) { // only access room if it is truthy } // Version 2 if (room &amp;&amp; room.monster) { // only try to get .monster if room is truthy } // Version 3 if (room?.monster) { // same as 2, but using ?. syntax }   In the third version above we've used optional chaining via the ?. operator. This stops us from going any further in an object chain, when something is undefined.  ","version":"Next","tagName":"h2"},{"title":"Using Objects: dealing with optional parameters​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#using-objects-dealing-with-optional-parameters","content":" A very common pattern in JavaScript programs that uses this concept is optional argument passing to functions. Instead of using an unknown number of arguments for a function, we often use an options Object, which may contain values to be used in the function. Consider the case of starting a game and sometimes passing existing user data:  // Make sure `options` exists, and use an empty `Object` instead if it's missing. // If we don't do this, we'll get an error if we try to do `options.score`, since // we can't lookup the `score` property on `undefined`. function initGame(options = {}) { // If the user already has a score, use that, otherwise default to 0 let score = options.score || 0; // If the user is already on a level, use that, otherwise default to 1 let level = options.level || 1; // If the user has collected an items in her inventory, use that, otherwise an empty Array let inventory = options.inventory || []; // Begin the game, passing the values we have determined above playGame(score, level, inventory); } // Define our options: we have a score and level, but no inventory let options = { score: 25, level: 2, }; initGame(options);   In the code above, we have an options Object that defines some, but not all of the properties our initGame function might use. We wrote initGame using a single argument so that it was easier to call: we didn't need to worry about the order or number of arguments, and could instead just define an Object with all of the properties we had. The initGamefunction examined the options at runtime to see which properties existed, and which wereundefined and needed a default value instead. Recall that we can use the logical OR (||) operator to choose between two values at runtime.  It's also common to see people use destructuring here:  function processStudent(student) { let { name, studentId, username, email } = student; // Use values destructured from student object } processStudent({ name: 'Tim Wu', studentId: '10341346', username: 'timw', email: 'timw@myseneca.ca', });   The value of what we've done above is that passing many arguments to a function is easier when we can name them as properties on an Object instead of having to pass them positionally as arguments.  ","version":"Next","tagName":"h2"},{"title":"Updating, Clearing, and Removing properties​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#updating-clearing-and-removing-properties","content":" We've seen that properties can be defined when declared as part of a literal and added later via the . or [] operators. We can also update or remove values after they are created:  let o = {}; // Add a name property o.name = 'Tim Wu'; // Update the name property to a new value, removing the old one. o.name = 'Mr. Timothy Wu';   An Object's property keys are unique, and setting a value for o.name more than once doesn't add more properties--it overwrites the value already stored in the existing property. We can also clear (remove the value but not the key) or delete (remove the entire property from the object, key and value) things from an Object.  let o = {}; // Add a `height` property o.height = '35 inches'; // Add an owner ID property o.owner = '012341341'; // Clear the value of `height`. We leave the `height` key, but get rid of the '35 inches' value o.height = null; // Completely remove the owner property from the object (both the key and its value) delete o.owner;   Why would you choose to assign null vs. use delete? Often we want to get rid of a key's value, but will use the key again in the future (e.g., add a new value). In such cases we just null the value by assigning the key a value of null. If we know that we'll never use this key again, and we don't want to retain it on the Object, we can instead completely remove the property (key and value) with delete. You'll see both used. For the most part, setting a key's value to null is probably what you want.  ","version":"Next","tagName":"h2"},{"title":"Using Objects: creating sets to track arbitrary lists​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#using-objects-creating-sets-to-track-arbitrary-lists","content":" Another common use of Objects, and their unique property keys, is to keep track of a sets, for example to count or keep track of an unknown number of items. Consider the following program, which tracks how many times each character appears within a String. The code uses the [] operator to allow for the keys to be created and accessed via a variable (char). Without an Object we would have to hard-code variables for each separate letter.  // An empty `Object`, which we'll populate with keys (letters) and values (counts) let characterCounts = {}; let sentence = 'The quick brown fox jumped over the lazy dog.'; let char; let count; // Loop through all characters in sentence for (let char of sentence) { // Get the current count for this character, or use 0 if we haven't seen it before count = characterCounts[char] || 0; // Increase the count by 1, and store it in our object characterCounts[char] = count + 1; } console.log(characterCounts); /* Our characterCounts Object now looks like this, and there were 8 spaces, 2 'h's, etc: { T: 1, h: 2, e: 4, ' ': 8, q: 1, u: 2, i: 1, c: 1, k: 1, b: 1, r: 2, o: 4, w: 1, n: 1, f: 1, x: 1, j: 1, m: 1, p: 1, d: 2, v: 1, t: 1, l: 1, a: 1, z: 1, y: 1, g: 1, '.': 1 } */   ","version":"Next","tagName":"h2"},{"title":"Complex Property Types: Object, Function​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#complex-property-types-object-function","content":" We said earlier that Object properties can be any valid JavaScript type. That includesNumber, String, Boolean, etc., also Object and Function. A property may define a complex Object of its own:  let part = { id: 5, info: { name: 'inner gasket', shelf: 56713, ref: [5618, 5693], }, };   Here we define a part, which has an id (part.id) as well as a complex property named info, which is itself an Object. We access properties deep in an Object the same way as a simple property, for example: part.info.ref.length means: get the length of the ref array on theinfo property of the part Object. An Object's properties can be Objects many levels deep, and we use the . or [] operators to access these child properties.  An Object property can also be a function. We call these functions methods. A method has access to other properties on the Object via the this keyword, which refers to the currentObject instance itself. Let's add a toString() method to our part Object above:  let part = { id: 5, info: { name: 'inner gasket', shelf: 56713, ref: [5618, 5693], }, toString: function () { return `${this.info.name} (#${this.id})`; }, }; console.log(part.toString()); // prints &quot;inner gasket (#5)&quot; to the console.   The toString property is just like any other key we've added previously, except its value is an anonymous function. Just as we previously bound function expressions to variables, here a function expression is bound to an Object's property. When we write part.toString we are accessing the function stored at this key, and by adding the () operator, we can invoke it:part.toString() says get the function stored at part.toString and call it. Our function accesses other properties on the part Object by using this.* instead of part.*. When the function is run, this will be the same as part (i.e., a reference to this Object instance).  The this keyword in JavaScript is used in different contexts, and has a different meaning depending on where and how it is used. We will return to this and its various meanings throughout the course.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Objects in JavaScript","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Objects-JavaScript#suggested-readings","content":" Object-oriented JavaScript for beginnersExploringJS, Chapter 17. Objects and InheritanceExploringJS, Chapter 20. DatesExploringJS, Chapter 21. Math ","version":"Next","tagName":"h2"},{"title":"Practice Exercise","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Practice-Exercise","content":"","keywords":"","version":"Next"},{"title":"Morse Code translator​","type":1,"pageTitle":"Practice Exercise","url":"/WebProgrammingPrinciples/Advanced-Objects-Inheritance/Practice-Exercise#morse-code-translator","content":" Morse code is a system of encoding developed in the 1800s that allowed transmission of textual messages over signal systems that only supported on/off (1 and 0) notations.  Complete the program below as specified. Your program should be able to translate messages like-- --- .-. ... ./-.-. --- -.. . into MORSE CODE and vice versa. Use what you learned above about Objects, and also some of the built-in Objects we've studied, in particularRegExp and String.  Use the following limited set of morse code to use in this exercise. You could expand your program to handle more complex messages later if you want:  Letter\tMorseA\t.- B\t-... C\t-.-. D\t-.. E\t. F\t..-. G\t--. H\t.... I\t.. J\t.--- K\t-.- L\t.-.. M\t-- N\t-. O\t--- P\t.--. Q\t--.- R\t.-. S\t... T\t- U\t..- V\t...- W\t.-- X\t-..- Y\t-.-- Z\t--.. space\t/  NOTE: letters are separated by a single space (' ') within a word, and words are separated with a /. For example, the words MORSE CODE would translate to -- --- .-. ... ./-.-. --- -.. .  // Object to provide lookup of morse code (value) for a given letter (key). let alpha = { // define the mapping here as a literal }; // Object to provide lookup of letter (value) for a given morse code (key). let morse = {}; // Hint: use the [] operator to specify these special key values rather than a literal. // Return `true` if all characters are morse code. Use a RegExp. function isMorse(characters) {} // Return `true` if all characters are part of the alphabet defined in `alpha`. Use a RegExp. // Bonus: can you rewrite it using `Object.keys()` and your `alpha` Object instead? // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys function isAlpha(characters) {} // Given an alphabet message, convert and return in morse code. Use your morse and/or alpha object. // Return undefined if text is not alpha. function textToMorse(text) {} // Given a morse code message, convert and return in text. Use your morse and/or alpha object. // Return undefined if morse is not proper code. function morseToText(morse) {} // Message class that takes a `message` (String), which can be either morse or alpha. // Use your functions above to decide how to store a value for `any` on `this` class Message { constructor(text) {} // Return the message as morse code, converting if necessary toMorse() {} // Return the message as alpha characters, converting if necessary toAlpha() {} } let msg1 = new Message( '--- -... .--- . -.-. - .../.. -./.--- .- ...- .- ... -.-. .-. .. .--. -/.- .-. ./...- . .-. -.--/.--. --- .-- . .-. ..-. ..- .-..' ); console.log(msg1.toAlpha()); console.log(msg1.toMorse()); let msg2 = new Message('I am learning how to use Objects in JavaScript'); console.log(msg2.toMorse()); console.log(msg2.toAlpha());   You can download the code above as well as a possible solution. ","version":"Next","tagName":"h2"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Client-side-Validation/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/CSS-Styling/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Forms-Inputs/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/DOM-Events/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Elements-Media/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Practice-Exercises","content":"Practice Exercises For each of the following, write a function that takes the given arguments, and returns or produces (e.g., console.log) the given result. Given r (radius) of a circle, calculate the area of a circle (A = π _ r _ r). Simulate rolling a dice using random(). The function should allow the caller to specify any number of sides, but default to 6 if no side count is given: roll() (assume 6 sided, return random number between 1 and 6) vs. roll(50) (50 sided, return number between 1 and 50). Write a function that converts values in Celcius to Farenheit: convert(0) should return &quot;32 F&quot;. Modify your solution to the previous function to allow a second argument: &quot;F&quot; or &quot;C&quot;, and use that to determine what the scale of the value is, converting to the opposite: convert(122, &quot;F&quot;) should return &quot;50 C&quot;. Function taking any number of arguments (Numbers), returning true if they are all less than 50: isUnder50(1, 2, 3, 5, 4, 65) should return false. Function allowing any number of arguments (Numbers), returning their sum: sum(1, 2, 3) should return 6. Function allowing any number of arguments of any type, returns true only if none of the arguments is falsy. allExist(true, true, 1) should return true, but allExist(1, &quot;1&quot;, 0) should return false. Function to create a JavaScript library name generator: generateName(&quot;dog&quot;) should return &quot;dog.js&quot; Function to check if a number is a multiple of 3 (returns true or false) Check if a number is between two other numbers, being inclusive if the final argument is true: checkBetween(66, 1, 50, true) should return false. Function to calculate the HST (13%) on a purchase amount Function to subtract a discount % from a total. If no % is given, return the original value. Function that takes a number of seconds as a Number, returning a String formatted like &quot;X Days, Y Hours, Z Minutes&quot; rounded to the nearest minute. Modify your solution above to only include units that make sense: &quot;1 Minute&quot; vs. &quot;3 Hours, 5 Minutes&quot; vs. &quot;1 Day, 1 Hour, 56 Minutes&quot; etc Function that takes any number of arguments (Numbers), and returns them in reverse order, concatenated together as a String: flip(1, 2, 3) should return &quot;321&quot; Function that takes two Numbers and returns their sum as an Integer value (i.e., no decimal portion): intSum(1.6, 3.333333) should return 4 Function that returns the number of matches found for the first argument in the remaining arguments: findMatches(66, 1, 345, 2334, 66, 67, 66) should return 2 Function to log all arguments larger than 255: showOutsideByteRange(1, 5, 233, 255, 256, 0) should log 256 to the console Function that takes a String and returns its value properly encoded for use in a URL. prepareString(&quot;hello world&quot;) should return &quot;hello%20world&quot; Using the previous function, write an enclosing function that takes any number of String arguments and returns them in encoded form, concatenated together like so: &quot;?...&amp;...&amp;...&quot; where &quot;...&quot; are the encoded strings. buildQueryString(&quot;hello world&quot;, &quot;goodnight moon&quot;) should return &quot;?hello%20world&amp;goodnight%20moon&quot; Function that takes a Function followed by any number of Numbers, and applies the function to all the numbers, returning the total: applyFn(function(x) { return x * x;}, 1, 2, 3) should return 14. After you try writing these yourself, take a look at a possible solution","keywords":"","version":"Next"},{"title":"Running a Development Web Environment","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment","content":"","keywords":"","version":"Next"},{"title":"Code Editor​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#code-editor","content":" For our code editor, we will be using Visual Studio Code, which is a free (open source) code editor created and maintained by Microsoft. It also works on Windows, macOS, and Linux. Make sure you have downloaded and installed it on all the computers you will use for web development.  ","version":"Next","tagName":"h2"},{"title":"Web Client​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#web-client","content":" For our web client we will use the many web browsers we introduced in Week 1, namely:  Google Chrome for desktop and AndroidMicrosoft Edge and Internet Explorer (IE)Apple Safari and Safari for iOSMozilla FirefoxOpera  There are many more, and you are highly encouraged to install as many as possible.  ","version":"Next","tagName":"h2"},{"title":"Web Server​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#web-server","content":" We will also need a web server to host our web pages and applications. Installing and running a web server can be complicated. Industry-grade web servers likeApache and nginx are free and can be installed and run on your local computer; however, they are much more complicated and powerful than anything we will need for hosting our initial web pages.  For our purposes, we will use one of the many simple node.js based HTTP servers. In order to use them, do the following:  Make sure you have installed node.js on your computer.In a terminal window, navigate to the directory that you want your web server to host. For example cd my-websiteNow download and run a web server using the npx command.  For example, you can use the serve web server like this:  cd my-website npx serve Need to install the following packages: serve@14.2.1 Ok to proceed? (y) ┌──────────────────────────────────────────┐ │ │ │ Serving! │ │ │ │ - Local: http://localhost:3000 │ │ - Network: http://10.7.133.229:3000 │ │ │ │ Copied local address to clipboard! │ │ │ └──────────────────────────────────────────┘   You can now open your web browser to http://localhost:3000 and browser your files. This uses the http protocol, and connects you to the special IP address127.0.0.1, also known as localhost(i.e., you can also use http://localhost:3000). The localhost IP address always refers to this computer, and allows you to connect network clients to your own machine. The final :3000 portion of the URL is a port number. Together,http://127.0.0.1:3000 means connect using HTTP to my local computer on port 3000.  NOTE: the second External IP address will be different than the above, but 127.0.0.1 will always be correct.  When you are done testing your web site, stop the web server by pressing CTRL-Cin your terminal window. To run the server again, use npx serve.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Running a Development Web Environment","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Development-Web-Environment#suggested-readings","content":" HTML: HyperText Markup Language on MDNHTML BasicsLearning HTML: Guides and TutorialsHTML Reference ","version":"Next","tagName":"h2"},{"title":"Practical Examples","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/Practical-Examples","content":"Practical Examples Lists: ordered and unorderedAnchors: creating hyperlinksImages: using imgText: text sections","keywords":"","version":"Next"},{"title":"HTML","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML","content":"","keywords":"","version":"Next"},{"title":"HTML Document​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#html-document","content":" The first HTML page ever created was built by Tim Berners-Lee on August 6, 1991.  Since then, the web has gone through many versions:  HTML - created in 1990 and standardized in 1997 as HTML 4xHTML - a rewrite of HTML using XML in 2000HTML5 - the current standard.  ","version":"Next","tagName":"h2"},{"title":"Basic HTML5 Document​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#basic-html5-document","content":" Here's a basic HTML5 web page:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;My Web Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- This is a comment --&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   Let's break this down and look at what's happening.  &lt;!doctype html&gt; tells the browser what kind of document this is (HTML5), and how to interpret/render it&lt;html&gt; the root element of our document: all other elements will be included within &lt;html&gt;...&lt;/html&gt;.&lt;head&gt; provides various information about the document as opposed to providing its content. This is metadata that describes the document to search engines, web browsers, and other tools.&lt;meta&gt; an example of metadata, in this case defining the character set used in the document: utf-8&lt;title&gt; an example of a specific (named) metadata element: the document's title, shown in the browser's title bar. There are a number of specific named metadata elements like this.&lt;body&gt; the content of the document is contained within &lt;body&gt;...&lt;/body&gt;.&lt;!-- ... --&gt; a comment, similar to using /* ... */ in C or JavaScript&lt;h1&gt; a heading element (there are headings 1 through 6), which is a title or sub-title in a document.  Now let's try creating and loading this file in our browser:  Make a directory on your computer called my-websiteCreate a new file in my-website named index.html (the index.html name is important, as it represents the main entry point to a directory of HTML files and other web resources)Use Visual Studio Code to open your my-website/index.html fileCopy the HTML we just discussed above, and paste it into your editorSave your index.html fileIn a terminal, navigate to your my-website directoryStart a web server by typing npx serve (you must do this from within the my-website directory)Open your web browser (Chrome, Firefox, etc) and enter http://localhost:3000 in the URL barMake sure you can see a new page with Hello World! in black text.  Now let's make a change to our document:  Go back to your editor and change the index.html file so that instead of Hello World! you have This is my web page.Save your index.html file.Go back to your browser and hit the Refresh button.Make sure your web page now says This is my web page.  Every time we update anything in our web page, we have to refresh the web page in our browser. The web server will serve the most recent version of the file on disk when it is requested. Web browsers and servers disconnect from one another after processing a request/response.  ","version":"Next","tagName":"h2"},{"title":"Common HTML Elements​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#common-html-elements","content":" There are many HTML elements you'll learn and use, but the following is a good initial set to get you started.  You can see an example page that uses every HTML element here.  ","version":"Next","tagName":"h2"},{"title":"Metadata​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#metadata","content":" Information about the document vs. the document's content goes in various metadata elements:  &lt;link&gt; - links from this document to external resources, such as CSS stylesheets&lt;meta&gt; - metadata that can't be included via other elements&lt;title&gt; - the document's title  ","version":"Next","tagName":"h3"},{"title":"Major Document Sections​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#major-document-sections","content":" &lt;html&gt; - the document's root element, containing all other elements&lt;head&gt; - machine-readable metadata about the document&lt;body&gt; - the document's content  ","version":"Next","tagName":"h3"},{"title":"Content Sections​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#content-sections","content":" These are organizational blocks within the document, helping give structure to the content and provide clues to browsers, screen readers, and other software about how to present the content:  &lt;header&gt; - introductory material at the top of a document&lt;nav&gt; - content related to navigation (a menu, index, links, etc)&lt;main&gt; - the main content of the document. For example, a news article's paragraphs vs. ads, links, navigation buttons, etc.&lt;h1&gt;, &lt;h2&gt;, ..., &lt;h6&gt; - (sub) headers for different sections of content&lt;footer&gt; - end material (author, copyright, links)  ","version":"Next","tagName":"h3"},{"title":"Text Content​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#text-content","content":" We organize content into &quot;boxes,&quot; some of which have unique layout characteristics.  &lt;div&gt; - a generic container we use to attach CSS styles to a particular area of content&lt;ol&gt; - an ordered list (1, 2, 3) of list items&lt;ul&gt; - an unordered list (bullets) of list items&lt;li&gt; - a list item in an &lt;ul&gt; or &lt;ol&gt;&lt;p&gt; - a paragraph&lt;blockquote&gt; - an extended quotation  ","version":"Next","tagName":"h3"},{"title":"Inline Text​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#inline-text","content":" We also use elements within larger text content to indicate that certain words or phrases are to be shown differently:  &lt;a&gt; - an &quot;anchor&quot; element, which will produce a hyperlink, allowing users to click and navigate to some other document.&lt;code&gt; - formats the text as computer code vs. regular text.&lt;em&gt; - adds emphasis to the text (often in italics)&lt;span&gt; - another generic container, used to define CSS styles  ","version":"Next","tagName":"h3"},{"title":"Multimedia​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#multimedia","content":" In addition to text, HTML5 also defines a number of rich media elements:  &lt;img&gt; - an element used to embed images in a document.&lt;audio&gt; - an element used to embed sound in a document.&lt;video&gt; - an element used to embed video in a document&lt;canvas&gt; - a graphical area (rectangle) used to draw with either 2D or 3D using JavaScript.  ","version":"Next","tagName":"h3"},{"title":"Scripting​","type":1,"pageTitle":"HTML","url":"/WebProgrammingPrinciples/HTML-Fundamentals/HTML#scripting","content":" We create dynamic web content and applications through the use of scripting:  &lt;script&gt; - used to embed executable code in a document, typically JavaScript. ","version":"Next","tagName":"h3"},{"title":"Scope","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures","content":"","keywords":"","version":"Next"},{"title":"Overwriting Variables in Child Scopes​","type":1,"pageTitle":"Scope","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures#overwriting-variables-in-child-scopes","content":" Since variables defined with var have function scope, and because functions can be nested, we have to be careful when naming our variables and arguments so as to not overwrite a variable in a parent scope. Or, we can use this to temporarily do exactly that. In both cases, we need to understand how nested scopes work.  Consider the the following code, where a variable named x is used in three different scopes. What will be printed to the console when child is called?  var x = 1; function parent() { var x = 2; function child(x) { console.log(x); } child(3); }   The first declaration of x creates a global variable (i.e., available in every scope). Then, in parent we re-declare x, creating a new local variable, which overwrites (or hides) the global variable x in this scope (i.e., within the body of parent). Next, we define yet another scope for child, which also uses x as the name of its only argument (essentially another local variable). When we do child(3), we are binding the value 3 to the xargument defined for the scope of child, and in so doing yet again overwriting the parent x. In the end, the console will show 3.  We can do this in error as well, and cause unexpected behaviour:  var total = 5; function increase(n) { var total = n + n; } increase(50); console.log(total);   Here we expect to see 100 but instead will get 5 on the console. The problem is that we have redefined, and thus overwritten total inside the increase function. During the call to increase, the new local variable total will be used, and then go out of scope. After the function completes, the original global variable total will again be used.  ","version":"Next","tagName":"h2"},{"title":"Closures​","type":1,"pageTitle":"Scope","url":"/WebProgrammingPrinciples/Functions-Scope/Scope-Closures#closures","content":" A closure is a function that has closed over a scope, retaining this scope even after it would otherwise disappear through the normal rules of execution. In the following function, the variable x goes out of scope as soon as the function finishes executing:  function f() { var x = 7; return x * 2; // After this return, and f completes, `x` will no longer be available. }   In JavaScript, functions have access not only to their own local variables, but also to any variables in their parents' scope. That is, if a variable is used (referenced) but not declared in a function, JavaScript will visit the parent scope to find the variable. This can happen for any number of child/parent levels up to the global level.  The following is an example of this, and probably one you've seen before:  var x = 7; function f() { return x * 2; // `x` not declared here, JS will look in the parent scope (global) }   Consider this example:  function parent() { var x = 7; function child() { return x * 2; } return child(); }   Here x is used in child, but declared in parent. The child function has access to all variables in its own scope, plus those in the parent scope. This nesting of scopes relies on JavaScript's function scope rules, and allows us to share data.  Sometimes we need to capture data in a parent scope, and retain it for a longer period of time than would otherwise be granted for a given invocation. Consider this example:  function createAccumulator(value) { return function (n) { value += n; return value; }; } var add = createAccumulator(10); add(1); // returns 11 add(2); // returns 13   Here the createAccumulator function takes an argument value, the initial value to use for an accumulator function. It returns an anonymous function which takes a value n (a Number) and adds it to the value before returning it. The add function is created by invoking createAccumulator with the initial value of 10. The function that is returned by createAccumulator has access to value in its parent's scope. Normally, value would be destroyed as soon as createAccumulator finished executing. However, we have created a closure to capture the variable value in a scope that is now attached to the function we're creating and returning. As long as the returned function exists (i.e., as long as add holds on to it), the variable value will continue to exist in our child function's scope: the variables that existed when this function was created continue to live on like a memory, attached to the lifetime of the returned function.  Closures make it possible to associate some data (i.e., the environment) with a function that can then operate on that data. We see similar strategies in pure object-oriented languages, where data (properties) can be associated with an object, and functions (methods) can then operate on that data. Closures play a somewhat similar role, however, they are more lightweight and allow for dynamic (i.e., runtime) associations.  By connecting data and functionality, closures help to reduce global variables, provide ways to &quot;hide&quot; data, allow a mechanism for creating private &quot;methods&quot;, avoid overwriting other variables in unexpected ways.  As we go further with JavaScript and web programming, we will encounter many instances where closures can be used to manage variable lifetimes, and associated functions with specific objects. For now, be aware of their existence, and know that it is an advanced concept that will take some time to fully master. This is only our first exposure to it.  Another way we'll see closures used, is in conjunction with Immediately-Invoked Function Expressions (IIFE). Consider the following rewrite of the code above:  let add = (function (value) { return function (n) { value += n; return value; }; })(10); add(1); // returns 11 add(2); // returns 13   Here we've declared add to be the value of invoking the anonymous function expression written between the first (...) parentheses. In essence, we have created a function that gets executed immediately, and which returns another function that we will use going forward in our program.  This is an advanced technique to be aware of at this point, but not one you need to master right away. We'll see it used, and use it ourselves, in later weeks to to avoid global variables, simulate block scope in JavaScript, and to choose or generate function implementations at runtime (e.g., polyfill). ","version":"Next","tagName":"h2"},{"title":"Internet Architecture","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#overview","content":" How does the Internet work? How the Internet works in 5 minutes (video) How the Web works  ","version":"Next","tagName":"h2"},{"title":"Application Protocols​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#application-protocols","content":" The web runs on-top of TCP/IP networks using a number of communication protocols, including:  IP these 32-bit numbers (IPv4) are assigned to every device on the Internet (IPv6 uses 128-bit numbers).Domain Names human-readable addresses for servers on the InternetDomain Name System (DNS), the &quot;Phone Book&quot; of the Internet. There are many popular DNS servers you can use: OpenDNS: 208.67.222.222, 208.67.220.220Cloudeflare: 1.1.1.1, 1.0.0.1Google: 8.8.8.8, 8.8.4.4There are lots more, but each has trade offs (privacy, speed) Hypertext Transfer Protocol (HTTP) How to get things on the webHTTP Responses Hypertext Transfer Protocol Secure (HTTPS)  There are many more as well (SMTP, FTP, POP, IMAP, SSH, etc).  We often use the terms &quot;Web&quot; and &quot;Internet&quot; interchangeably, however, they aren't the same. Pictured below, Tim Berners-Lee (left), who invented the World Wide Web, and Vint Cert (right), who was one of the main inventors of the Internet:    The World Wide Web (WWW) runs on top of the Internet using HTTP, and allows us to access web services, request resources (i.e., pages, images), and transmit data between clients and servers. The web is a subset of the Internet.  The web isn't owned or controlled by any single company, organization, or government.Instead, it is defined as a set of open standards, which everyone building and using the web relies upon. Some examples of these standards include HTML, HTTP, SVG, and many more.  ","version":"Next","tagName":"h2"},{"title":"HTTP Requests and Responses​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#http-requests-and-responses","content":" The Hypertext Transfer Protocol is a stateless, client-server model for formatting requests and responses between computers on the Internet. This means one computer makes a request (the client) to another (the server), and after the response is returned, the connection is closed.  The server listens for requests, and fulfills (or rejects) those requests by returning (or generating) the requested resources, such as images, web pages, videos, or other data.  ","version":"Next","tagName":"h2"},{"title":"URLs​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#urls","content":" Web resources are reachable via unique identifiers called a Uniform Resource Locator orURL. Consider the URL for this course's outline:  https://www.senecacollege.ca/cgi-bin/subject?s1=WEB222  A URL contains all the information necessary for a web client (e.g., a browser) to request the resource. In the URL given above we have:  protocol: https: - the resource is available using the HTTPS (i.e., secure HTTP) protocoldomain: www.senecacollege.ca - the domain (domain name) of the server. We could also have substituted the IP address (23.208.15.99), but it's easier to remember domain names.port: Not Given - if not specified, the port is the default for HTTP 80 or 443 for HTTPS. It could have been specified by appending :443 like so: https://www.senecacollege.ca:443origin: combining the protocol, domain, and port gives us a unique origin, https://www.senecacollege.ca. Origins play a central role in the web's security model.path: /cgi-bin/subject - a filesystem-like path to the resource on the server. It may or may not end with a file extension (e.g., you might also have seen another server use /cgi-bin/subject.html)query string: ?s1=WEB222 - additional parameters sent to the server as part of the URL, of the form name=value  URLs can only contain a limited set of characters, and anything outside that set has to be encoded. This includes things like spaces, non-ASCII characters, Unicode, etc.  ","version":"Next","tagName":"h3"},{"title":"Requests​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#requests","content":" A URL describes the location (i.e., server, pathname) and how to interpret (i.e., which protocol) a resource on the Internet. To get the resource, we need to request it by sending a properly formatted HTTP Request to the appropriate server (host):  GET /cgi-bin/subject HTTP/1.1 Host: www.senecacollege.ca   Here we do a GET request using HTTP version 1.1 for the resource at the path /cgi-bin/subjecton the server named www.senecacollege.ca.  There are various HTTP Verbs we can use other than GET, which allow us to request that resources be returned, created, deleted, updated, etc. The most common include:  GET - retrieve the data at the given URLPOST - create a new resource at the given URL based on the data sent along with the request in its bodyPUT - update an existing resource at the given URL with the data sent along with the request in its bodyDELETE - delete the resource at the given URL  We can use a URL in many ways, for example, via the command line using a tool like curl (NOTE: on Windows, use curl.exe):  $ curl https://www.senecacollege.ca/cgi-bin/subject?s1=WEB222 &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML+RDFa 1.0//EN&quot; &quot;http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd&quot;&gt; &lt;html lang=&quot;en&quot; dir=&quot;ltr&quot; xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot; xmlns:dc=&quot;http://purl.org/dc/terms/&quot; xmlns:foaf=&quot;http://xmlns.com/foaf/0.1/&quot; xmlns:og=&quot;http://ogp.me/ns#&quot; xmlns:rdfs=&quot;http://www.w3.org/2000/01/rdf-schema#&quot; xmlns:sioc=&quot;http://rdfs.org/sioc/ns#&quot; xmlns:sioct=&quot;http://rdfs.org/sioc/types#&quot; ... &lt;/section&gt; &lt;!-- /.block --&gt; &lt;/div&gt; &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h3"},{"title":"Responses​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#responses","content":" Upon receiving a request for a URL, the server will respond with an HTTP Response, which includes information about the response, and possibly the resource being requested. Let's use curl again, but this time ask that it --include the response headers:  $ curl --include https://www.senecacollege.ca/cgi-bin/subject\\?s1\\=WEB222 HTTP/1.1 200 OK Content-Type: text/html;charset=ISO-8859-1 Strict-Transport-Security: max-age=16070400; includeSubDomains Date: Wed, 06 Sep 2023 14:31:11 GMT Content-Length: 17241 Connection: keep-alive &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;!-- InstanceBegin template=&quot;/Templates/mainTemplate.dwt&quot; codeOutsideHTMLIsLocked=&quot;false&quot; --&gt; ...   In this case, we see a two-part structure: first a set of Response Headers; then the actual HTML Response Body. The two are separated by a blank line. The headers provide extra metadata about the response, the resource being returned, the server, etc.  HTTP Headers are well defined, and easy to lookup via Google, MDN, or StackOverflow. They follow the key: value format, and can be upper- or lower-case:  name: value  For example, in the response above, we see a number of interesting things:  200 OK - tells us that the requested resource was successful located and returned.Info about the DateThe Content-Type is text, and more specifically, html (a web page) using ISO-8859-1 text encoding.  After these headers we have a blank line (i.e., \\n\\n), followed by the body of our response: the actual HTML document.  What if we requested a URL that we know doesn't exist?  $ curl --include https://ict.senecacollege.ca/course/web000 HTTP/1.1 302 Found Date: Thu, 30 Aug 2018 20:25:28 GMT Server: Apache/2.4.29 (Unix) OpenSSL/1.0.2l PHP/5.6.30 X-Powered-By: PHP/5.6.30 Expires: Sun, 19 Nov 1978 05:00:00 GMT Cache-Control: no-cache, must-revalidate, post-check=0, pre-check=0 Location: https://ict.senecacollege.ca/Course/CourseNotFound?=web000 Content-Length: 0 Content-Type: text/html; charset=UTF-8   This time, instead of a 200 status code, we get 302. This indicates that the resource has moved, and later in the headers we are given a new Location to try. Notice there is no body (not every response will include one).  Let's try following the suggested redirect URL:  curl -I https://www.senecacollege.ca/cgi-bin/subjec HTTP/1.1 404 Not Found Pragma: no-cache Content-Type: text/html;charset=UTF-8 Strict-Transport-Security: max-age=16070400; includeSubDomains Cache-Control: no-cache, no-store, must-revalidate Date: Wed, 06 Sep 2023 14:35:04 GMT Connection: keep-alive Set-Cookie: JSESSIONID=25B152E3F14082DDB666AEE9BE3B4CA7; Path=/; Secure Set-Cookie: TS0148d87b=01576d3f8972e643bf2b887be1dd52aa5ea6da872a01d2283959af6601471be59f46727200dd63159112ada83202dee0854fecd43d332679805a76b9d6d9e9bacdf505fd97; Path=/ ...   Now a third response code has been returned, 404 Not Found as well as another HTML page telling us our course couldn't be located.  There are dozens of response codes, but they fall into a few categories you should learn:  1xx - information responses2xx – successful responses3xx - redirection messages4xx – client error responses5xx – server error responses  ","version":"Next","tagName":"h3"},{"title":"Web Browsers​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#web-browsers","content":" So far we've been communicating with web servers using curl, but a more common tool is a Web Browser.  A good way to think about a browser is as an operating system vs. an application. A web browser provides implementations of the web's open standards. This means it knows how to communicate HTTP, DNS and other protocols over the network in order to request resources via URLs. It also contains parsers for the web's programming languages, and knows how to render, execute, and lay-out web content for use by a user. Browsers also contain lots of security features, and allow users to download and run untrusted code (i.e., code from a random server on the Internet), without fear of infecting their computers.  Some of the the largest software companies and vendors in the world all have their own browsers:  Google Chrome for desktop and AndroidMicrosoft Edge and Internet Explorer (IE)Apple Safari and Safari for iOSMozilla FirefoxSamsung Internet for AndroidOpera  There are hundreds more, and thousands of different OS and version combinations. There are good stats on usage info for desktopand mobile, but no one company or browser controls the entire web.  As a web developer, you can't ever know for sure which browser your users will have. This means you have to test your web applications in different browsers and on different platforms in order to make sure the experience is good for as many people as possible.  The web is also constantly evolving, as new standards are written, APIs and features added to the web platform, and older technologies retired. A good way to stay on top of what does and doesn't work in a particular browser is to use https://caniuse.com/. This is a service that keeps track of web platform features, and which browsers do and don't implement it.  For example, you can look at the URL() API, used to work with URLs in JavaScript: https://caniuse.com/#feat=url. Notice that it's widely supported (green) in most browsers (89.69% at the time of writing), but not supported (red) in some older browsers like Internet Explorer.  Because the web is so big, so complicated, so old, and used by so many people for so many different and competing things, it's common for things to break, for there to be bugs, and for you to have to adapt your code to work in interesting ways. The good news is, it means there are lots of jobs for web developers to make sure it all keeps working.  ","version":"Next","tagName":"h2"},{"title":"Uniqueness of the Web as a Platform​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#uniqueness-of-the-web-as-a-platform","content":" We've been discussing HTTP as a way to request URLs be transferred between clients and servers. The web is globally distributed set of  services - requesting data (Text, JSON, XML, binary, etc) to be used in code (vs. looked at by a user)resources, pages, documents, images, media - both static and dynamic user viewable resources (web pages), which link to other similar resources.applications - a combination of the above, providing rich user interfaces for working with real-time data or other complex information, alone or in networked (i.e., collaborative) ways.  The web can be read-only. The web can also be interactive (video games), editable (wikis), personal (blog), and productive (e-commerce).  The web is linkable, which makes it something that can be indexed, searched, navigated, and connected. The web gets more valuable as its connections grow: just look at all the other pages and resources this page links to itself!  The web allows users to access and run remote applications without needing to install new software. The deployment model of the web is HTTP. Compare that to traditional software that has to be manually installed on every computer that needs to run it. The same is true with mobile phones and apps in the various app stores. On the web, updates get installed every time you open a URL.  Question: how many mobile or desktop apps did you install today vs. how many websites did you visit?  The web works on every computing platform. You can access and use the web on desktop and mobile computers, on TVs and smartwatches, on Windows and Mac, in e-Readers and video game consoles. The web works everywhere, and learning how to develop software for the web extends your reach into all those platforms.  ","version":"Next","tagName":"h2"},{"title":"Front-End Web Development: HTML5, CSS, JavaScript, and friends​","type":1,"pageTitle":"Internet Architecture","url":"/WebProgrammingPrinciples/Introduction/Internet-Architecture#front-end-web-development-html5-css-javascript-and-friends","content":" When we talk about programming for the web in a browser, we often refer to this asFront-End Web Development. This is in contrast to server-side, or Back-End Development. In this course we will be focused on the front-end, leaving back-end for subsequent courses.  The modern web, and modern web browsers, are incredibly powerful. What was once possible only on native operating systems can now be done within browsers using only web technologies (cf. running Windows 2000 or Doom 3 in a browser window!)  The set of front-end technologies that make this possible, and are commonly referred to as the Web Platform, include:  HTML5 - the Hypertext Markup Language, and its associated APIs, provide a way to define and structure contentCSS - Cascading Style Sheets allow developers and designers to create beautiful and functional UIs for the webJS - JavaScript allows complex user interaction with web content, and dynamic behaviours in documents and applications.DOM - the Document Object Model and its APIs allows scripts and web content to interact at runtime.Web APIs - hundreds of APIs provide access to hardware devices, networking, files, 2D and 3D graphics, databases, and so much more.WebAssembly or WASM - a low-level assembly language that can be run in web browsers, allowing code written in C/C++ and other non-web languages to target the web. For example, Google Earth uses WebAssembly.  In addition to these primary technologies, an increasingly important set of secondary, or third-party technologies are also in play:  Libraries, Modules - Bootstrap, Leaflet, Three.js, Lodash, ...Frameworks - React, Angular, Vue.js, ...Tooling - Babel, webpack, ESLint, PrettierLanguages that &quot;compile&quot; to JavaScript - because JavaScript runs everywhere, many languages target the web by &quot;compiling&quot; (also know as transpiling) to JavaScript. A good example is TypeScript.  The front-end web stack is also increasingly being used to build software outside the browser, both on desktop and mobile using things like Electron and Progressive Web Apps (PWA).Visual Studio Code, for example, is written using web technologies and runs on Electron, which is one of the reasons it works across so many platforms. You can also run it entirely in the browser: vscode.dev. ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Functions-Scope/Functions","content":"","keywords":"","version":"Next"},{"title":"User-defined Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#user-defined-functions","content":" JavaScript has many built-in functions, which we'll get to below; however, it also allows you to write your own and/or use functions written by other developers (libraries, frameworks).  These user-defined functions can take a number of forms.  ","version":"Next","tagName":"h2"},{"title":"Function Declarations​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-declarations","content":" The first is the function declaration, which looks like this:  // The most basic function, a so-called NO OPERATION function function noop() {} // square function accepts one parameter `n`, returns its value squared. function square(n) { return n * n; } // add function accepts two parameters, `a` and `b`, returns their sum. function add(a, b) { return a + b; }   Here the function keyword initiates a function declaration, followed by aname, a parameter list in round parenthesis, and the function's body surrounded by curly braces. There is no semi-colon after the function body.  ","version":"Next","tagName":"h3"},{"title":"Function Expressions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-expressions","content":" The second way to create a function is using a function expression. Recall that expressions evaluate to a value: a function expression evaluates to a function Object. The resulting value is often bound (i.e., assigned) to a variable, or used as a parameter.  let noop = function () {}; let square = function (n) { return n * n; }; let add = function add(a, b) { return a + b; };   A few things to note:  The function's name is often omitted. Instead we return an anonymous function and bind it to a variable. We'll access it again via the variable name. In the case of recursive functions, we sometimes include it to make it easier for functions to call themselves. You'll see it done both ways.We did use a semi-colon at the end of our function expression. We do this to signify the end of our assignment statement let add = ... ;.In general, function declarations are likely a better choice (when you can choose) due to subtle errors introduced with declaration order and hosting (see below); however, both are used widely and are useful.  ","version":"Next","tagName":"h3"},{"title":"Arrow Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#arrow-functions","content":" Modern JavaScript also introduces a new function syntax called an Arrow Function or &quot;Fat Arrow&quot;. These functions are more terse, using the =&gt; notation (not to be confused with the &lt;= and &gt;= comparison operators):  let noop = () =&gt; {}; let square = (n) =&gt; n * n; let add = (a, b) =&gt; a + b;   When you see let add = (a, b) =&gt; a + b; it is short-hand for let add = function(a, b) { return a + b; }, where =&gt; replaces the function keyword and comes after the parameter list, and the return keyword is optional, when functions return a single value.  Arrow functions also introduce some new semantics for the this keyword, which we'll address later.  You should be aware of Arrow functions, since many web developers use them heavily. However, don't feel pressure to use them yet if you find their syntax confusing.  ","version":"Next","tagName":"h3"},{"title":"Parameters and arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#parameters-and-arguments","content":" Function definitions in both cases take parameter lists, which can be empty, single, or multiple in length. Just as with variable declaration, no type information is given:  function emptyParamList() {} function singleParam(oneParameter) {} function multipleParams(one, two, three, four) {}   A function can accept any number of arguments when it is called, including none. This would break in many other languages, but not JavaScript:  function log(a) { console.log(a); } log('correct'); // logs &quot;correct&quot; log('also', 'correct'); // logs &quot;also&quot; log(); // logs undefined   Because we can invoke a function with any number of arguments, we have to write our functions carefully, and test things before we make assumptions. How can we deal with a caller sending 2 vs. 10 values to our function?  One way we do this is using the built-in arguments Object.  Every function has an implicit arguments variable available to it, which is an array-like object containing all the arguments passed to the function. We can use arguments.length to obtain the actual number of arguments passed to the function at runtime, and use array index notation (e.g., arguments[0]) to access an argument:  function log(a) { console.log(arguments.length, a, arguments[0]); } log('correct'); // 1, &quot;correct&quot;, &quot;correct&quot; log('also', 'correct'); // 2, &quot;also&quot;, &quot;also&quot; log(); // 0, undefined, undefined   We can use a loop to access all arguments, no matter the number passed:  function sum() { const count = arguments.length; let total = 0; for (let i = 0; i &lt; count; i++) { total += arguments[i]; } return total; } sum(1); // 1 sum(1, 2); // 3 sum(1, 2, 3, 4); // 10   You may have wondered previously how console.log() can work with one, two, three, or more arguments. The answer is that all JavaScript functions work this way, and you can use it to &quot;overload&quot; your functions with different argument patterns, making them useful in more than one scenario.  ","version":"Next","tagName":"h3"},{"title":"Parameters and ...​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#parameters-and-","content":" Modern JavaScript also supports naming the &quot;rest&quot; of the parameters passed to a function. These Rest Parameters allow us to specify that all final arguments to a function, no matter how many, should be available to the function as a named Array.  There are some advantages to not using the implicit arguments keyword, which rest parameters provide.  We can convert the example above to this, naming our arbitrary list of &quot;numbers&quot;:  function sum(...numbers) { let total = 0; for (let i = 0; i &lt; numbers.length; i++) { total += numbers[i]; } return total; }   ","version":"Next","tagName":"h3"},{"title":"Dealing with Optional and Missing Arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#dealing-with-optional-and-missing-arguments","content":" Because we can change the number of arguments we pass to a function at runtime, we also have to deal with missing data, or optional parameters. Consider the case of a function to calculate a player's score in a video game. In some cases we may want to double a value, for example, as a bonus for doing some action a third time in a row:  function updateScore(currentScore, value, bonus) { return bonus ? currentScore + value * bonus : currentScore + value; } updateScore(10, 3); updateScore(10, 3); updateScore(10, 3, 2);   Here we call updateScore three different times, sometimes with 2 arguments, and once with 3. Our updateScore function has been written so it will work in both cases. We've used a conditional ternary operator to decide whether or not to add an extra bonus score. When we say bonus ? ... : ... we are checking to see if the bonus argument is truthy or falsy--that is, did the caller provide a value for it? If they did, we do one thing, if not, we do another.  Here's another common way you'll see code like this written, using a default value:  function updateScore(currentScore, value, bonus) { // See if `bonus` is truthy (has a value or is undefined) and use it, or default to 1 bonus = bonus || 1; return currentScore + value * bonus; }   In this case, before we use the value of bonus, we do an extra check to see if it actually has a value or not. If it does, we use that value as is; but if it doesn't, we instead assign it a value of 1. Then, our calculation will always work, since multiplying the value by 1 will be the same as not using a bonus.  The idiom bonus = bonus || 1 is very common in JavaScript. It uses theLogical Or Operator || to test whether bonus evaluates to a value or not, and prefers that value if possible to the fallback default of 1. We could also have written it out using an if statements like these:  function updateScore(currentScore, value, bonus) { if (bonus) { return currentScore + value * bonus; } return currentScore + value; } function updateScore(currentScore, value, bonus) { if (!bonus) { bonus = 1; } return currentScore + value * bonus; }   JavaScript programmers tend to use the bonus = bonus || 1 pattern because it is less repetitive, using less code, and therefore less likely to introduce bugs. We could shorten it even further to this:  function updateScore(currentScore, value, bonus) { return currentScore + value * (bonus || 1); }   Because this pattern is so common, modern JavaScript has added a built-in way to handle Default Parameters. Instead of using || notation in the body of the function, we can specify a default value for any named parameter when it is declared. This frees us from having to check for, and set default values in the function body. Using default parameters, we could convert our code above to this:  function updateScore(currentScore, value, bonus = 1) { return currentScore + value * bonus; }   Now, if bonus has a value (i.e., is passed as a parameter), we use it; otherwise, we use 1 as a default.  ","version":"Next","tagName":"h3"},{"title":"Return Value​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#return-value","content":" Functions always return a value, whether implicitly or explicitly. If the returnkeyword is used, the expression following it is returned from the function. If it is omitted, the function will return undefined:  function implicitReturnUndefined() { // no return keyword, the function will return `undefined` anyway } function explicitReturnUndefined() { return; // return keyword, but no expression given, which is also `undefined` } function explicitReturn() { return 1; // return keyword, followed by `Number` expression evalutes to `Number` } function explicitReturn2() { return 'Hello' + ' World!'; // return keyword, followed by expression evaluating to a `String` }   ","version":"Next","tagName":"h3"},{"title":"Function Naming​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#function-naming","content":" Functions are typically named using the same rules we learned for naming any variable: camelCase and using the set of valid letters, numbers, etc. and avoiding language keywords.  Function declarations always give a name to the function, while function expressions often omit it, using a variable name instead:  // Name goes after the `function` keyword in a declaration function validateUser() { ... } // Name is used only at the level of the bound variable, function is anonymous let validateUser = function() { ... }; // Name is repeated, which is correct but not common. Used with recursive functions let validateUser = function validateUser() { ... }; // Names are different, which is also correct, but not common as it can lead to confusion let validateUser = function validate() { // the validate name is only accessible here, within the function body ... };   Because JavaScript allows us to bind function objects (i.e., result of function expressions) to variables, it is common to create functions without names, but immediately pass them to functions as arguments. The only way to use this function is via the argument name:  // The parameter `fn` will be a function, and `n` a number function execute(fn, n) { // Call the function referred to by the argument (i.e, variable) `fn`, passing `n` as its argument return fn(n); } // 1. Call the `execute` function, passing an anonymous function, which squares its argument, and the value 3 execute(function (n) { return n * n; }, 3); // 2. Same thing as above, but with different formatting execute(function (n) { return n * n; }, 3); // 3. Same thing as above, using an Arrow Function execute((n) =&gt; n * n, 3); let doubleIt = function (num) { return num * 2; }; // 4. Again call `execute`, but this time pass `doubleIt` as the function argument execute(doubleIt, 3);   We can also use functions declared via function declarations used this way, and bind them to variables:  function greeting(greeting, name) { return greeting + ' ' + name; } var sayHi = greeting; // also bind a reference to greeting to sayHi // We can now call `greeting` either with `greeting()` or `sayHi()` console.log(greeting('Hello', 'Steven')); console.log(sayHi('Hi', 'Kim'));   JavaScript treats functions like other languages treat numbers or booleans, and lets you use them as values. This is a very powerful feature, but can cause some confusion as you get started with JavaScript.  You might ask why we would ever choose to define functions using variables. One common reason is to swap function implementations at runtime, depending on the state of the program. Consider the following code for displaying the user interface depending on whether the user is logged in or not:  // Display partial UI for guests and non-authenticated users, hiding some features function showUnauthenticatedUI() { ... } // Display full UI for authenticated users function showAuthenticatedUI() { ... } // We will never call showUnauthenticatedUI or showAuthenticatedUI directly. // Instead, we will use showUI to hold a reference to one or the other, // and default to the unauthenticated version at first (i.e., until the user logs in). let showUI = showUnauthenticatedUI; ... // Later in the program, when a user logs in, we can swap the implementation // without touching any of our UI code. function authenticate(user) { ... showUI = showAuthenticatedUI; } ... // Whenever we need to refresh/display the UI, we can always safely call // whichever function is currently bound to `showUI`. showUI();   ","version":"Next","tagName":"h3"},{"title":"Invoking Functions, the Execution Operator​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#invoking-functions-the-execution-operator","content":" In many of the examples above, we've been invoking (i.e., calling, running, executing) functions but haven't said much about it. We invoke a function by using the () operator:  let f = function () { console.log('f was invoked'); }; f();   In the code above, f is a variable that is assigned the value returned by a function expression. This means f is a regular variable, and we can use it like any other variable. For example, we could create another variable and share its value:  let f = function () { console.log('f was invoked'); }; let f2 = f; f(); // invokes the function f2(); // also invokes the function   Both f and f2 refer to the the same function object. What is the difference between saying f vs. f() in the line let f2 = f;? When we write f()we are really saying, &quot;Get the value of f (the function referred to) and invoke it.&quot; However, when we write f (without ()), we are saying, &quot;Get the value of f (the function referred to)&quot; so that we can do something with it (assign it to another variable, pass it to a function, etc).  The same thing is true of function declarations, which also produce function Objects:  function f() { console.log('f was invoked'); } let f2 = f; f2(); // also invokes the function   The distinction between referring to a function object via its bound variable name (f) vs invoking that same function (f()) is important, because JavaScript programs treat functions as data, just as you would a Number. Consider the following:  function checkUserName(userName, customValidationFn) { // If `customValidationFn` exists, and is a function, use that to validate `userName` if (customValidationFn &amp;&amp; typeof customValidationFn === 'function') { return customValidationFn(userName); } // Otherwise, use a default validation function return defaultValidationFn(userName); }   Here the checkUserName function takes two arguments: the first a String for a username; the second an optional (i.e., may not exist) function to use when validating this username. Depending on whether or not we are passed a function for customValidationFn, we will either use it, or use a default validation function (defined somewhere else).  Notice the line if(customValidationFn &amp;&amp; typeof customValidationFn === 'function') { wherecustomValidationFn is used like any other variable (accessing the value it refers to vs. doing an invocation), to check if it has a value, and if its value is actually a function. Only then is it save to invoke it.  It's important to remember that JavaScript functions aren't executed until they are called via the invocation operator, and may also be used as values without being called.  ","version":"Next","tagName":"h3"},{"title":"Built-in/Global Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#built-inglobal-functions","content":" JavaScript provides a small number of built-in global functions for working with its data types, for example:  parseInt()parseFloat()isNaN()isFinite()decodeURI()decodeURIComponent()encodeURI()encodeURIComponent()  There are also global functions that exist for historical reasons, but should be avoided for performance, usability, and/or security reasons:  eval() dangerous to parse and run user-defined stringsprompt() and alert() synchronous calls that block the UI thread.  Most of JavaScripts &quot;standard library&quot; comes in the form of methods on global objects vs. global functions. A method is a function that is bound to a variable belonging to an object, also known as a property. We'll be covering these in more depth later, but here are some examples  console.*. There are quite a few worth learning, but here are some to get you started: _ console.log(), console.warn(), and console.error()_ console.assert()_ console.count()_ console.dir()Math.* Math.abs()Math.max()Math.min()Math.random()Math.round() Date.* Date.now()Date.getTime()Date.getMonth()Date.getDay() JSON.* JSON.parse()JSON.stringify()  Much of web programming is done using Objects and calling their methods. JavaScript is a small language, but the ecosystem of Objects, APIs, libraries, and frameworks allows it to do anything.  ","version":"Next","tagName":"h2"},{"title":"Suggested Readings​","type":1,"pageTitle":"Functions","url":"/WebProgrammingPrinciples/Functions-Scope/Functions#suggested-readings","content":" ExploringJS, Chapter 15. Functions and Chapter 16. Variables: Scopes, Environments, and ClosuresEloquent JavaScript, Chapter 3. FunctionsFunctions Guide and Reference on MDN. ","version":"Next","tagName":"h2"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Practice-Exercises","content":"Practice Exercises Try to solve each of the following using JavaScript. If you need to print something, use console.log(), which will print the argument(s) you give it. Create a variable label and assign it the value &quot;senecacollege&quot;. Create another variable tld and assign it &quot;ca&quot;. Create a third variable domainName that combines label and tld to produce the value &quot;senecacollege.ca&quot;. Create a variable isSeneca and assign it a boolean value (true or false) depending on whether or not domainName is equal to &quot;senecacollege.ca&quot;. HINT: use === and don't write true or false directly. Create a variable isNotSeneca and assign it the inverse boolean value of isSeneca. HINT: if isSeneca is true, isNotSeneca should be false. Create four variables byte1, byte2, byte3, byte4, and assign each of these a value in the range 0-255. Convert byte1 to a String using .toString(), and console.log() the result. What happens if you use toString(2) or toString(16) instead? Create a variable ipAddress and assign it the value of combining your four byteN variables together, separated by &quot;.&quot;. For example: &quot;192.168.2.1&quot;. Create a variable ipInt and assign it the integer value of bit-shifting (&lt;&lt;) and adding your byteN variables. HINT: your ipInt will contain 32 bits, the first byte needs to be shifted 24 bit positions (&lt;&lt; 24) so it occupies 32-25, the second shifted 16, the third 8. Create a variable ipBinary that contains the binary representation of the ipInt value. HINT: use .toString(2) to display the number with 1 and 0 only. Create a variable statusCode, and assign it the value for the &quot;I'm a teapot&quot; HTTP status code. HINT: see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status Write an If statement that checks to see if your statusCode is a 4xx client error. HINT: use the &lt;, &gt;, &gt;=, and/or &lt;= operators to test the value Write a switch statement that checks your statusCode for all possible 1xx information responses. In each case, you should console.log() the response text associated with the status code, or &quot;unknown information response&quot; if the status code is not known. Write a function is2xx(status) which takes a status code status (e.g., 200) and returns true if the status code is a valid 2xx code. Create a variable studentName and assign your name. Create another variable studentAge and assign it your age. Use console.log() to print out a sentence that includes both variables, like &quot;Alice is 20 years old.&quot;. Create a variable isEven and assign it a boolean value (true or false) depending on whether a given number num is even or not. HINT: use the modulus operator %. Create a variable isOdd and assign it the inverse boolean value of isEven. HINT: if isEven is true, isOdd should be false. Create a variable radius and assign it a value of 10. Calculate the area of a circle with this radius and assign the result to a variable area. HINT: use Math.PI and the formula area = πr^2. Create a variable temperatureInCelsius and assign it a value. Convert this temperature to Fahrenheit and assign the result to a variable temperatureInFahrenheit. HINT: use the formula F = C * 9/5 + 32. Create a variable heightInFeet and assign it a value. Convert this height to meters and assign the result to a variable heightInMeters. HINT: use the conversion factor 1 foot = 0.3048 meters. Create a variable seconds and assign it a value. Convert this time to minutes and seconds (e.g., 90 seconds becomes 1 minute and 30 seconds) and assign the result to two variables minutes and remainingSeconds. Create a variable score and assign it a value. Write an if statement that checks if the score is an A (90-100), B (80-89), C (70-79), D (60-69), or F (below 60) and assigns the result to a variable grade. Write a switch statement that checks the value of a variable day and console.log()s whether it is a weekday or weekend. HINT: day can be a value from 1 (Monday) to 7 (Sunday). Write a function isPositive(num) which takes a number num and returns true if the number is positive and false otherwise. Write a function isLeapYear(year) which takes a year year and returns true if the year is a leap year and false otherwise. HINT: a leap year is divisible by 4, but not by 100, unless it is also divisible by 400. Write a function getDayOfWeek(day) which takes a number day (from 1 to 7) and returns the day of the week as a string (e.g., &quot;Monday&quot;). Write a function getFullName(firstName, lastName) which takes two strings firstName and lastName and returns the full name as a single string. Write a function getCircleArea(radius) which takes a number radius and returns the area of a circle with that radius. Write a function getHypotenuse(a, b) which takes two numbers a and b (the lengths of the two sides of a right triangle) and returns the length of the hypotenuse. HINT: use the Pythagorean theorem and Math.sqrt() to calculate the square root. After you try writing these yourself, take a look at a possible solution.","keywords":"","version":"Next"},{"title":"Welcome to Web Programming Principles","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/welcome","content":"Welcome to Web Programming Principles The web is the most ubiquitous computing platform in the world. As a developer, learning the web takes time. There are hundreds of languages, libraries, frameworks, and tools to be learned, some old, some built yesterday, and all being mixed together at once. The fundamental unit of the web is the hyperlink--the web is interconnected. These weekly notes provide numerous links to external resources, books, blogs, and sample code. To get good at the web, you need to be curious and you need to go exploring, you need to try things. Make sure you follow the links below as you read, and begin to create your own web of knowledge and experience. No one resource can begin to cover the breadth and depth of web development. Question: do I need to read the weekly notes? How about all the many links to external resources? Yes, you do need to read the weekly notes. You will be tested on this material. We will discuss it in class, but not cover everything. The external links will help you understand and master the material. You are advised to read some external material, but you don't need to read all of it. However, make sure you do read Recommended Readings.","keywords":"","version":"Next"},{"title":"TODO","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/JSON-Dynamic-Data/TODO","content":"TODO","keywords":"","version":"Next"},{"title":"Practice Exercises","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises","content":"","keywords":"","version":"Next"},{"title":"A Larger Problem Combining Everything:​","type":1,"pageTitle":"Practice Exercises","url":"/WebProgrammingPrinciples/Objects-Built-ins/Practice-Exercises#a-larger-problem-combining-everything","content":" You are asked to write JavaScript code to process a String which is in the form of a Comma-Separated Values (CSV) formatted data dump of user information. The data might look something like this:  0134134,John Smith,555-567-2341,62 inches 0134135 , June Lee , 5554126347 , 149 cm 0134136, Kim Thomas , 5324126347, 138cm`   Write a series of functions to accomplish the following, building a larger program as you go. You can begin with exercise.js:  Split the string into an Array of separate rows (i.e., an Array with rows separated by \\n). Bonus: how could we deal with data that includes both Unix (\\n) and Windows (\\r\\n) line endings? Each row contains information user info: ID, Name, Phone Number, and Height info all separated by commas. Split each row into an Array with all of its different fields. You need to deal with extra and/or no whitespace between the commas. Get rid of any extra spaces around the Name field Using a RegExp, extract the Area Code from the Phone Number field. All Phone Numbers are in one of two formats: &quot;555-555-5555&quot; or &quot;5555555555&quot;. Check if the Height field has &quot;cm&quot; at the end. If it does, strip that out, convert the number to inches, and turn it into a String in the form &quot;xx inches&quot;. For example: &quot;152 cm&quot; should become &quot;59 inches&quot;. After doing all of the above steps, create a new record with ID, Name, Area Code, Height In Inches and separate them with commas Combine all these processed records into a new CSV formatted string, with rows separated by \\n.  A sample solution is provided in solution.js. ","version":"Next","tagName":"h2"},{"title":"Introduction to JavaScript","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript","content":"","keywords":"","version":"Next"},{"title":"JavaScript Resources​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-resources","content":" Throughout the coming weeks, we'll make use of a number of important online resources. They are listed here so you can make yourself aware of them, and begin to explore on your own. All programmers, no matter how experienced, have to return to these documents on a routine basis, so it's good to know about them.  JavaScript on MDN JavaScript GuideJavaScript Reference Eloquent JavaScriptJavaScript for impatient programmers (ES2022 edition)  ","version":"Next","tagName":"h2"},{"title":"JavaScript Environments​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-environments","content":" Unlike C, which is compiled to machine code, JavaScript is meant to be run within a host environment. There are many possible environments, but we will focus on the following:  Web Browsers, and their associated developer tools, primarily: Chrome DevToolsFirefox Developer Tools node.js, and its command line REPL (Read-Eval-Print-Loop)  If you haven't done so already, you should install all of the above.  ","version":"Next","tagName":"h2"},{"title":"JavaScript Engines​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-engines","content":" JavaScript is parsed, executed, and managed (i.e., memory, garbage collection, etc) by an engine written in C/C++. There are a number of JavaScript engines available, the most common of which are:  V8, maintained an used by Google in Chrome and in node.jsSpiderMonkey, maintained and used by Mozilla in FirefoxChakraCore, maintained and used by Microsoft in EdgeJavaScriptCore, maintained and used by Apple in Safari  These engines, much like car engines, are meant to be used within a larger context. We will encounter them indirectly via web browsers and in node.js.  It's not important to understand a lot about each of these engines at this point, other than to be aware that each has its own implementation of the ECMAScript standards, its own performance characteristics (i.e., some are faster at certain things), as well as its own set of bugs.  ","version":"Next","tagName":"h3"},{"title":"Running JavaScript Programs​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#running-javascript-programs","content":" JavaScript statements can be stored in an external file with a .js file extension, or embedded within HTML code via the HTML &lt;script&gt; element. As a developer, you also have a number of options for writing and executing JavaScript statements or files:  From the command line via node.js. You'll learn more about node.js in subsequent courses, but we'll also use it sometimes in this course to quickly try test JavaScript expressions, and to run JavaScript programs outside the browser. Using Firefox's Developer Tools, and in particular the Web Console, JavaScript Debugger, and Scratchpad. Using Chrome's DevTools, and in particular the Console and Sources Debugger Finally, we'll eventually write JavaScript that connects with HTML and CSS to create dynamic web pages and applications.  Take some time to install and familiarize yourself with all of the methods listed above.  ","version":"Next","tagName":"h3"},{"title":"JavaScript Syntax​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#javascript-syntax","content":" ","version":"Next","tagName":"h2"},{"title":"Recommend Readings​","type":1,"pageTitle":"Introduction to JavaScript","url":"/WebProgrammingPrinciples/Introduction/Introduction-JavaScript#recommend-readings","content":" We will spend a month learning JavaScript, and there is no one best way to do it. The more you read and experiment the better. The following chapters/pages give a good overview:  Chapter 1. Basic JavaScript of Exploring JS (ES5).MDN JavaScript Introduction TutorialChapter 1. Values, Types and Operators and Chapter 2. Program Structure of Eloquent JavaScript (2nd Ed.).  Important Ideas​  Like C, JavaScript is Case-Sensitive: customerCount is not the same thing as CustomerCount or customercount Name things using camelCase (first letter lowercase, subsequent words start with uppercase) vs. snake_case. Semicolons are optional in JavaScript, but highly recommended. We'll expect you to use them in this course, and using them will make working in C++, Java, CSS, etc. much easier, since you have to use them there. Comments work like C/C++, and can be single or multi-line  // This is a single line comment. NOTE: the space between the // and first letter. /* This is a multi-line comment, and can be as long as you need. */   Whitespace: JavaScript will mostly ignore whitespace (spaces, tabs, newlines). In this course we will expect you to use good indentation practices, and for your code to be clean and readable. Many web programmers use Prettier to automatically format their code, and we will too:  // This is poorly indented, and needs more whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } } // This is much more readable due to the use of whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } }   JavaScript statements: a JavaScript program typically consists of a series of statements. A statement is a single-line of instruction made up of objects, expressions, variables, and events/event handlers. Block statement: a block statement, or compound statement, is a group of statements that are treated as a single entity and are grouped within curly brackets {...}. Opening and closing braces need to work in pairs. For example, if you use the left brace { to indicate the start of a block, then you must use the right brace } to end it. The same matching pairs applies to single '......' and double &quot;.......&quot; quotes to designate text strings. Functions are one of the primary building blocks of JavaScript. A function defines a subprogram that can be called by other parts of your code. JavaScript treats functions like other built-in types, and they can be stored in variables passed to functions, returned from functions or generated at run-time. Learning how to write code in terms of functions will be one of your primary goals as you get used to JavaScript. Variables are declared using the let keyword. You must use the let keyword to precede a variable name, but you do not need to provide a type, since the initial value will set the type.  JavaScript version note: JavaScript also supports the var and const keywords for variable declaration. We will primarily use let in this course, but be aware of var and const as well, which other developers will use.  let year; let seasonName = 'Fall'; // Referring to and using syntax: year = 2023; console.log(seasonName, year);   JavaScript Variables: variables must start with a letter (a-zA-z), underscore (_), or dollar sign ($). They cannot be a reserved (key) word. Subsequent characters can be letters, numbers, underscores.  NOTE: If you forget to use the let keyword, JavaScript will still allow you to use a variable, and simply create a global variable. We often refer to this as &quot;leaking a global,&quot; and it should always be avoided:  let a = 6; // GOOD: a is declared with let b = 7; // BAD: b is used without declaration, and is now a global   Data Types: JavaScript is a typeless language--you don't need to specify a type for your data (it will be inferred at runtime). However, internally, the following data types are used: Number - a double-precision 64-bit floating point number. Using Number you can work with both Integers and Floats. There are also some special Number types, Infinity and NaN.BigInt - a value that can be too large to be represented by a Number (larger than Number. MAX_SAFE_INTEGER,) can be represented by a BigInt. This can easily be done by appending n to the end of an integer value.String - a sequence of Unicode characters. JavaScript supports both single ('...') and double (&quot;...&quot;) quotes when defining a String.Boolean - a value of true or false. We'll also see how JavaScript supports so-called truthy and falsy values that are not pure Booleans.Object, which includes Function, Array, Date, and many more. - JavaScript supports object-oriented programming, and uses objects and functions as first-class members of the language.Symbol - a primitive type in JavaScript that represents a unique and anonymous value/identifier. They can normally be used as an object's unique properties.null - a value that means &quot;this is intentionally nothing&quot; vs. undefinedundefined - a special value that indicates a value has never been defined.  Declaration\tType\tValuelet s1 = &quot;some text&quot;;\tString\t&quot;some text&quot; let s2 = 'some text';\tString\t&quot;some text&quot; let s3 = '172';\tString\t&quot;172&quot; let s4 = '172' + 4;\tString\t&quot;1724&quot; (concatenation vs. addition) let n1 = 172;\tNumber\t172 (integer) let n2 = 172.45;\tNumber\t172.45 (double-precision float) let n3 = 9007199254740993n;\tBigInt\t9007199254740993n (integer) let b1 = true;\tBoolean\ttrue let b2 = false;\tBoolean\tfalse let b3 = !b2;\tBoolean\ttrue let s = Symbol(&quot;Sym&quot;);\tsymbol\tSymbol(Sym) let c;\tundefined\tundefined let d = null;\tobject\tnull  Consider a simple program from your C course, and how it would look in JavaScript   // Area of a Circle, based on https://scs.senecac.on.ca/~btp100/pages/content/input.html // area.c #include &lt;stdio.h&gt; // for printf int main(void) { const float pi = 3.14159f; // pi is a constant float float radius = 4.2; // radius is a float float area; // area is a float area = pi * radius * radius; // calculate area from radius printf(&quot;Area = %f\\n&quot;, area); // copy area to standard output return 0; }   Now the same program in JavaScript:  const pi = 3.14159; // pi is a Number let radius = 4.2; // radius is a Number let area; // area is (currently) undefined area = pi * radius * radius; // calculate area from radius console.log('Area = ' + area); // print area to the console   We could also have written it like this, using Math.PI, which we'll learn about later:  let radius = 4.2; // radius is a Number let area = Math.PI * radius * radius; // calculate area from radius console.log('Area', area); // print area to the console   Common JavaScript Operators (there are more, but these are a good start):  Operator\tOperation\tExample+\tAddition of Numbers\t3 + 4 +\tConcatenation of Strings\t&quot;Hello &quot; + &quot;World&quot; -\tSubtraction of Numbers\tx - y *\tMultiplication of Numbers\t3 * n /\tDivision of Numbers\t2 / 4 %\tModulo\t7 % 3 (gives 1 remainder) ++\tPost/Pre Increment\tx++, ++x --\tPost/Pre Decrement\tx--, --x =\tAssignment\ta = 6 +=\tAssignment with addition\ta += 7 same as a = a + 7. Can be used to join Strings too -=\tAssignment with subtraction\ta -= 7 same as a = a - 7 *=\tAssignment with multiplication\ta *= 7 same as a = a * 7 /=\tAssignment with division\ta /= 7 same as a = a / 7 &amp;&amp;\tLogical AND\tif(x &gt; 3 &amp;&amp; x &lt; 10) both must be true ()\tCall/Create\t() invokes a function, f() means invoke/call function stored in variable f ||\tLogical OR\tif(x === 3 || x === 10) only one must be true |\tBitwise OR\t3.1345|0 gives 3 as an integer !\tLogical NOT\tif(!(x === 2)) negates an expression ==\tEqual\t1 == 1 but also 1 == &quot;1&quot; due to type coercion ===\tStrict Equal\t1 === 1 but 1 === &quot;1&quot; is not true due to types. Prefer === !=\tNot Equal\t1 != 2, with type coercion !==\tStrict Not Equal\t1 !== &quot;1&quot;. Prefer !== &gt;\tGreater Than\t7 &gt; 3 &gt;=\tGreater Than Or Equal\t7 &gt;=7 and 7 &gt;= 3 &lt;\tLess Than\t3 &lt; 10 &lt;=\tLess Than Or Equal\t3 &lt; 10 and 3 &lt;=3 typeof\tType Of\ttypeof &quot;Hello&quot; gives 'string', typeof 6 gives 'number' cond ? a : b\tTernary\tstatus = (age &gt;= 18) ? 'adult' : 'minor';  JavaScript version note: you may encounter =&gt; in JavaScript code, which looks very similar to &lt;= or &gt;=. If you see =&gt; it is an arrow function, which is new ES6 syntax for declaring a function expression. We will slowly introduce this syntax, especially in later courses.  JavaScript is dynamic, and variables can change value and type at runtime:  let a; // undefined a = 6; // 6, Number a++; // 7, Number a--; // 6, Number a += 3; // 9, Number a = 'Value=' + a; // &quot;Value=9&quot;, String a = !!a; // true, Boolean a = null; // null   JavaScript is a garbage collected language. Unlike C, memory automatically gets freed at runtime when variables are not longer in scope or reachable. We still need to be careful not to leak memory (i.e., hold onto data longer than necessary, or forever) and block the garbage collector from doing its job. Strings: JavaScript doesn't distinguish between a single char and a multi-character String--everything is a String. You define a String using either single ('...'), double (&quot;...&quot;) quotes. Try to pick one style and stick with it within a given file/program vs. mixing them. JavaScript version note: newer versions of ECMAScript also allow for the use of template literals. Instead of ' or &quot;, a template literal uses ` (backticks), and you can also interpolate expressions. A JavaScript expression is any code (e.g., literals, variables, operators, and expressions) that evaluates to a single value. The value may be a Number, String, an Object, or a logical value.  let a = 10 / 2; // arithmetic expression let b = !(10 / 2); // logical expression evaluates to false let c = '10 ' + '/' + ' 2'; // string, evaluates to &quot;10 / 2&quot; let f = function () { return 10 / 2; }; // function expression, f can now be called via the () operator let d = f(); // f() evaluates to 10/2, or the Number 5   JavaScript execution flow is determined using the following four (4) basic control structures: Sequential: an instruction is executed when the previous one is finished.Conditional: a logical condition is used to determine which instruction will be executed next - similar to the if and switch statements in C (which JavaScript also has).Looping: a series of instructions are repeatedly executed until some condition is satisfied - similar to the for and while statements in C (which JavaScript also has). There are many different types of loops in JavaScript: for example for loops and while loops, as well as ways to break out of loops or skip iterations with continue. We'll cover other types as we learn about Object and Array.Transfer: jump to, or invoke a different part of the code - similar to calling a function in C.  /** * 1. Sequence example: each statement is executed one after the other **/ let a = 3; let b = 6; let c = a + b; /** * 2. Conditional examples: a decision is made based on the evaluation of an expression, * and a code path (or branch) taken. **/ let grade; let mark = 86; if (mark &gt;= 90) { grade = 'A+'; } else if (mark &gt;= 80) { grade = 'A'; } else if (mark &gt;= 70) { grade = 'B'; } else if (mark &gt;= 60) { grade = 'C'; } else if (mark &gt;= 50) { grade = 'D'; } else { grade = 'F'; } switch (grade) { case 'A+': // do these steps if grade is A+ break; case 'A': // do these steps if grade is A break; case 'B': // do these steps if grade is B break; case 'C': // do these steps if grade is C break; case 'D': // do these steps if grade is D break; default: // do these steps in any other case break; } /** * 3. Looping example: a set of statements are repeated **/ let total = 0; for (let i = 1; i &lt; 11; i++) { total += i; console.log('i', i, 'total', total); } /** * 4. Transfer example: a set of statements are repeated **/ function add(a, b) { // declaring the add function if (!b) { // check if the b argument exists/has a value return a; // if not, simply return the value of argument a } return a + b; // otherwise, return the two arguments added together } let total; total = add(56); // invoking the add function with a single argument total = add(total, 92); // invoking the add function with two arguments  ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Introduction","content":"Introduction In languages like C, we are used to thinking about data types separately from the functions that operate upon them. We declare variables to hold data in memory, and call functions passing them variables as arguments to operate on their values. In object-oriented languages like JavaScript, we are able to combine data and functionality into higher order types, which both contain data and allow us to work with that data. In other words, we can pass data around in a program, and all the functionality that works on that data travels with it. Let's consider this idea by looking at strings in C vs. JavaScript. In C a string is a null terminated (\\0) array of char elements, for example: const char name1[31] = &quot;My name is Arnold&quot;; const char name2[31] = {'M','y',' ','n','a','m','e',' ','i','s',' ','A','r','n','o','l','d','\\0'}; With C-style strings, we perform operations using standard library functions, for example string.h: #include &lt;string.h&gt; int main(void) { char str[31]; // declare a string ... strlen(str); // find the length of a string str strcpy(str2, str); // copy a string strcmp(str2, str); // compare two strings strcat(str, &quot;...&quot;); // concatenate a string with another string } JavaScript also allows us to work with strings, but because JavaScript is an object-oriented language, a JavaScript String is an Object with various properties and methods we can use for working with text. One way to think about Objects like String is to imagine combining a C-string's data type with the functions that operate on that data. Instead of needing to specify which string we want to work with, all functions would operate a particular instance of a string. Another way to look at this would be to imagine that the data and the functions for working with that data are combined into one more powerful type. If we could do this in C, we would be able to write code that looked more like this: String str = &quot;Hello&quot;; // declare a string int len = str.len; // get the length of str str.cmp(str2); // compare str and str2 str = str.cat(&quot;...&quot;); // concatenate &quot;...&quot; onto str In the made-up code above, the data (str) is attached to functionality that we can call via the .* notation. Using str.*, we no longer need to indicate to the functions which string to work with: all string functions work on the string data to which they are attached. This is very much how String and other Object types work in JavaScript. By combining the string character data and functionality into one type (i.e., a String), we can easily create and work with text in our programs. Also, because we work with strings at a higher level of abstraction (i.e., not as arrays of char), JavaScript deals with memory management for us, allowing our strings to grow or shrink at runtime.","keywords":"","version":"Next"},{"title":"Arrays","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays","content":"","keywords":"","version":"Next"},{"title":"Declaring JavaScript Arrays​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#declaring-javascript-arrays","content":" Like creating a String, we can create an Array in JavaScript using either a literal or the Array constructor function:  let arr = new Array(1, 2, 3); // array constructor let arr2 = [1, 2, 3]; // array literal   Like arrays in C, a JavaScript Array has a length, and items contained within it can be accessed via an index:  let arr = [1, 2, 3]; let len = arr.length; // len is 3 let item0 = arr[0]; // item0 is 1   Unlike languages such as C, a JavaScript Array can contain any type of data, including mixed types:  let list = [0, '1', 'two', true];   JavaScript Arrays can also contain holes (i.e., be missing certain elements), change size dynamically at runtime, and we don't need to specify an initial size:  let arr = []; // empty array arr[5] = 56; // element 5 now contains 56, and arr's length is now 6   NOTE: a JavaScript Array is really a map, which is a data structure that associates values with unique keys (often called a key-value pair). JavaScript arrays are a special kind of map that uses numbers for the keys, which makes them look and behave very much like arrays in other languages. We will encounter this map structure again when we look at how to create Objects.  ","version":"Next","tagName":"h2"},{"title":"Learning resources","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Resources/learning-resources","content":"Learning resources Here you will find information about and links to learning resources that you will use in this course. TODO: Finish this section","keywords":"","version":"Next"},{"title":"Accessing Elements in an Array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#accessing-elements-in-an-array","content":" Like arrays in C, we can use index notation to obtain an element at a given index:  let numbers = [50, 12, 135]; let firstNumber = numbers[0]; let lastNumber = numbers[numbers.length - 1];   JavaScript also allows us to use a technique called Destructuring Assignment to unpack values in an Array (or Object, see below) into distinct variables. Consider each of the following methods, both of which accomplish the same goal:  // Co-ordinates for Seneca's Newnham Campus let position = [43.796, -79.3486]; // Separate the two values into their own unique variables. // Version 1 - index notation let lat = position[0]; let lng = position[1]; // Version 2 - destructure let [lat, lng] = position;   This technique is useful when working with structured data, where you know exactly how many elements are in an array, and need to access them:  let dateString = `17/02/2001`; let [day, month, year] = dateString.split('/'); console.log(`The day is ${day}, month is ${month}, and year is ${year}`);   Here we .split() the string '17/02/2001' at the '/' character, which will produce the Array ['17', '02', '2001']. Next, we destructure this Array's values into the variables day, month, year.  You can also ignore values (i.e., only unpack the one or ones you want):  let dateString = `17/02/2001`; // Ignore the first index in the array, unpack only position 1 and 2 let [, month, year] = dateString.split('/'); console.log(`The month is ${month}, and year is ${year}`); let emailAddress = `jsmith@myseneca.ca`; // Only unpack the first position, ignoring the second let [username] = emailAddress.split('@'); console.log(`The username for ${emailAddress} is ${username}`);   ","version":"Next","tagName":"h2"},{"title":"Array Properties and Methods​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#array-properties-and-methods","content":" arr.length - a property that tells us the number of elements in the array.  ","version":"Next","tagName":"h2"},{"title":"Methods that modify the original array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-that-modify-the-original-array","content":" arr.push(element) - a method to add one (or more) element(s) to the end of the array. Using push() modifies the array (increasing its size). You can also use arr.unshift(element) to add one (or more) element to the start of the array.arr.pop() - a method to remove the last element in the array and return it. Using pop() modifies the array (reducing its size). You can also use arr.shift() to remove the first element in the array and return it.  ","version":"Next","tagName":"h3"},{"title":"Methods that do not modify the original array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-that-do-not-modify-the-original-array","content":" arr.concat([4, 5], 6) - returns a new array with the original array joined together with other arrays or values provided.arr.includes(element) - returns true if the array includes the given element, otherwise false.arr.indexOf(element) - returns the index of the given element in the array, if it exists, otherwise -1 (meaning not found).arr.join(&quot;\\n&quot;) - returns a string created by joining (concatenating) all elements in the array with the given delimiter (String).  ","version":"Next","tagName":"h3"},{"title":"Methods for iterating across the elements in an Array​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#methods-for-iterating-across-the-elements-in-an-array","content":" JavaScript's Array type also provides a long list of useful methods for working with list data. All of these methods work in roughly the same way:  // Define an Array let list = [1, 2, 3, 4]; // Define a function that you want to call on each element of the array function operation(element) { // do something with element... } // Call the Array method that you want, passing your function operation list.arrayOperation(operation);   JavaScript will call the given function on every element in the array, one after the other. Using these methods, we are able to work with the elements in an Array instead of only being able to do things with the Array itself.  As a simple example, let's copy our list Array and add 3 to every element. We'll do it once with a for-loop, and the second time with the forEach() method:  // Create a new Array that adds 3 to every item in list, using a for-loop let listCopy = []; for (let i = 0; i &lt; list.length; i++) { let element = list[i]; element += 3; listCopy.push(element); }   Now the same code using the Array's forEach() method:  let listCopy = []; list.forEach(function (element) { listCopy.push(element + 3); });   We've been able to get rid of all the indexing code, and with it, the chance for off-by-one errors. We also don't have to write code to get the element out of the list: we just use the variable passed to our function.  These Array methods are so powerful that there are often functions that do exactly what we need. For example, we could shorten our code above even further but using the map() method. The map() method takes one Array, and calls a function on every element, creating and returning a new Array with those elements:  let listCopy = list.map(function (element) { return element + 3; });   Here are some of the Array methods you should work on learning:  arr.forEach() - calls the provided function on each element in the array.arr.map() - creates and returns a new array constructed by calling the provided function on each element of the original array.arr.find() - finds and returns an element from the array which matches a condition you define. See also arr.findLast(), arr.findIndex(), and arr.findLastIndex(), which all work in similar ways.arr.filter() - creates and returns a new array containing only those elements that match a condition you define in your function.arr.every() - returns true if all of the elements in the array meet a condition you define in your function.  There are more Array methods you can learn as you progress with JavaScript, but these will get you started.  ","version":"Next","tagName":"h3"},{"title":"Iterating over String, Array, and other collections​","type":1,"pageTitle":"Arrays","url":"/WebProgrammingPrinciples/Objects-Built-ins/Arrays#iterating-over-string-array-and-other-collections","content":" The most familiar way to iterate over a String or Array works as you'd expect:  let s = 'Hello World!'; for (let i = 0; i &lt; s.length; i++) { let char = s.charAt(i); console.log(i, char); // Prints: // 0, H // 1, e // 2, l // ... } let arr = [10, 20, 30, 40]; for (let i = 0; i &lt; arr.length; i++) { let elem = arr[i]; console.log(i, elem); // Prints: // 0, 10 // 1, 20 // 2, 30 // ... }   The standard for loop works, but is not the best we can do. Using a for loop is prone to various types of errors: off-by-one errors, for example. It also requires extra code to convert an index counter into an element.  An alternative approach is available in ES6, for...of:  let s = 'Hello World!'; for (let char of s) { console.log(char); // Prints: // H // e // l // ... } let arr = [10, 20, 30, 40]; for (let elem of arr) { console.log(elem); // Prints: // 10 // 20 // 30 // ... }   Using for...of we eliminate the need for a loop counter altogether, which has the added benefit that we'll never under- or over- shoot our collection's element list; we'll always loop across exactly the right number of elements within the given collection.  The for...of loop works with all collection types, from String to Array toarguments to NodeList (as well as newer collection types likeMap,Set, etc.). ","version":"Next","tagName":"h2"},{"title":"RegExp","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp","content":"","keywords":"","version":"Next"},{"title":"Declaring JavaScript RegExp​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#declaring-javascript-regexp","content":" Like String or Array, we can declare a RegExp using either a literal or the RegExp constructor:  let regex = /colou?r/; // regex literal uses /.../ let regex2 = new RegExp('colou?r');   Regular expressions can also have advanced search flags, which indicate how the search is supposed to be performed. These flags include g (globally match all occurrences vs. only matching once),i (ignore case when matching), and m (match across line breaks, multi-line matching) among others.  let regex = /pattern/gi; // find all matches (global) and ignore case let regex2 = new RegExp('pattern', 'gi'); // same thing using the constructor instead   ","version":"Next","tagName":"h2"},{"title":"Understanding Regular Expression Patterns​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#understanding-regular-expression-patterns","content":" Regular expressions are dense, and often easier to write than to read. It's helpful to use various tools to help you as you experiment with patterns, and try to understand and debug your own regular expressions:  regexr.comRegulexregexpal.com  ","version":"Next","tagName":"h2"},{"title":"Matching Specific Characters​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#matching-specific-characters","content":" \\ ^ $ . * + ? ( ) [ ] { } | all have special meaning, and if you need to match them, you have to escape them with a leading \\. For example: \\$ to match a $. Any other character will match itself. abc is a valid regular expression and means match the letters abc. The . means any character. For example a. would match ab, a3, or a&quot;. If you need to match the . itself, make sure you escape it: .\\. means a period followed by any character We specify a set of possible characters using []. For example, if we wanted to match any vowel, we might do [aeiou]. This says match any of the letters a, e, i, o, or u and would match a but not t. We can also do the opposite, and define a negated set: [^aeiou] would match anything that is not a vowel. With regular expressions, it can often be easier to define your patterns in terms of what they are not instead of what they are, since so many things are valid vs. a limited set of things that are not. We can also specify a range, [a-d] would match any of a, b, c, d but not f, g or h. Some sets are so common that we have shorthand notation. Consider the set of single digit numbers, [0123456789]. We can instead use \\d which means the same thing. The inverse is \\D (capital D), and means [^0123456789] (i.e., not one of the digits). If we wanted to match a number with three digits, we could use \\d\\d\\d, which would match 123 or 678 or 000. Another commonly needed pattern is any letter or number and is available with \\w, meaning [A-Za-z0-9_] (all upper- and lower-case letters, digits 0 to 9, and the underscore). The inverse is available as \\W and means [^A-Za-z0-9_] (everything not in the set of letters, numbers and underscore). Often we need to match blank whitespace (spaces, tabs, newlines, etc.). We can do that with \\s, and the inverse \\S (anything not a whitespace). For example, suppose we wanted to allow users to enter an id number with or without a space: \\d\\d\\d\\s?\\d\\d\\d would match both 123456 and 123 456. There are lots of other examples of pre-defined common patterns, such as \\n (newline), \\r (carriage return), \\t (tab). Consult the MDN documentation for character classes to lookup others.  ","version":"Next","tagName":"h3"},{"title":"Define Character Matching Repetition​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#define-character-matching-repetition","content":" In addition to matching a single character or character class, we can also match sequences of them, and define how many times a pattern or match can/must occur. We do this by adding extra informationafter our match pattern.  ? is used to indicate that we want to match something once or none. For example, if we want to match the word dog without an s, but also to allow dogs (with an s), we can do dogs?. The ? follows the pattern (i.e., s) that it modifies, and indicates that it is optional. * is used when we want to match zero or more of something. number \\d* would match &quot;number &quot; (no digits), &quot;number 1&quot; (one digit), and &quot;number 1234534123451334466600&quot;. + is similar to * but means one or more. vroo+m would match &quot;vroom&quot; but also &quot;vroooooooom&quot; and &quot;vroooooooooooooooooooooooooooooooom&quot; We can limit the number of matches to an exact number using {n}, which means match exactly n times. vroo{3}m would only match &quot;vroooom&quot;. We can further specify that we want a match to happen match n or more times using {n,}, or use {n,m} to indicate we want to match *at least n times and no more than m times: \\w{8,16} would match 8 to 16 word characters, &quot;ABCD1234&quot; or &quot;zA5YncUI24T_3GHO&quot;  ","version":"Next","tagName":"h3"},{"title":"Define Positional Match Parameters or Alternatives​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#define-positional-match-parameters-or-alternatives","content":" Normally the patterns we define are used to look anywhere within a string. However, sometimes it's important to specify where in the string a match is located. For example, we might care that an id number begins with some sequence of letters, or that a name doesn't end with some set of characters.  ^ means start looking for the match at the beginning of the input string. We could test to see that a string begins with a capital letter like so: ^[A-Z]. Similarly $ means make sure that the match ends the string. If we wanted to test that string was a filename that ended with a period and a three letter extension, we could use: \\.\\w{3}$ (an escaped period, followed by exactly 3 word characters, followed by the end of the string). This would match &quot;filename.txt&quot; but not &quot;filename.txt is a path&quot;. Sometimes we need to specify one of a number of possible alternatives. We do this with |, as in red|green|blue which would match any of the strings &quot;red&quot;, &quot;green&quot;, or &quot;blue&quot;.  ","version":"Next","tagName":"h3"},{"title":"Using RegExp with Strings​","type":1,"pageTitle":"RegExp","url":"/WebProgrammingPrinciples/Objects-Built-ins/RegExp#using-regexp-with-strings","content":" So far we've discussed how to declare a RegExp, and also some of the basics of defining search patterns. Now we need to look at the different ways to use our regular expression objects to perform matches.  RegExp.test(string) - used to test whether or not the given string matches the pattern described by the regular expression. If a match is made, returns true, otherwise false. /id-\\d\\d\\d/.test('id-123') returns true, /id-\\d\\d\\d/.test('id-13b') returns false. String.match(regexp) - used to find all matches of the given RegExp in the source String. These matches are returned as an Array of Strings. For example, 'This sentence has 2 numbers in it, including the number 567'.match(/\\d+/g) will return the Array ['2', '567'] (notice the use of the g flag to find all matches globally). String.replace(regexp, replacement) - used to find all matches for the given RegExp, and returns a new String with those matches replaced by the replacement String provided. For example, '50 , 60,75.'.replace(/\\s*,\\s*/g, ', ') would return '50, 60, 75.' with all whitespace normalized around the commas. String.split(RegExp) - used to break the given String into an Array of sub-strings, dividing them on the RegExp pattern. For example, 'one-two--three---four----five-----six'.split(/-+/) would return ['one', 'two', 'three', 'four', 'five', 'six'], with elements split on any number of dashes.  There are other methods you can call, and more advanced ways to extract data using RegExp, and you are encouraged to dig deeper into these concepts over time. Thinking about matching in terms of regular expressions takes practice, and often involves inverting your logic to narrow a set of possibilities into something you can define in code. ","version":"Next","tagName":"h2"},{"title":"Strings","type":0,"sectionRef":"#","url":"/WebProgrammingPrinciples/Objects-Built-ins/Strings","content":"","keywords":"","version":"Next"},{"title":"String Properties and Methods​","type":1,"pageTitle":"Strings","url":"/WebProgrammingPrinciples/Objects-Built-ins/Strings#string-properties-and-methods","content":" s.length - will tell us the length of the string (UTF-16 code units)s.charAt(1) - returns the character at the given position (UTF-16 code unit). We can also use s[1] and use an index notation to get a particular character from the string.s.concat() - returns a new string created by concatenating the original with the given arguments.s.padStart(2, '0) - returns a new string padded with the given substring until the length meets the minimum length given. See also s.padEnd().s.includes(&quot;tex&quot;) - returns true if the search string is found within the string, otherwise false if not found.s.startsWith(&quot;some&quot;) - returns true if the string starts with the given substring, otherwise false.s.endsWith(&quot;text&quot;) - returns true if the string ends with the given substring, otherwise false.s.indexOf(&quot;t&quot;) - returns the first index position of the given substring within s, or -1 if the substring is not found within s. See also s.lastIndexOf()s.match(regex) - tries to match a regular expression against the string, returning the matches. See discussion of RegExp below.s.replace(regex, &quot;replacement&quot;) - returns a new string with the first occurrence of a matched RegExp replaced by the replacement text. See also s.replaceAll(), which replaces all occurrences.s.slice(2, 3) - returns a new string extracted (sliced) from within the original string. A beginning index and (optional) end index mark the position of the slice.s.split() - returns an Array (see discussion below) of substrings by splitting the original string based on the given separator (String or RegExp).s.toLowerCase() - returns a new string with all characters converted to lower case.s.toUpperCase() - returns a new string with all characters converted to upper case.s.trim() - returns a new string with leading and trailing whitespace removed.  JavaScript Version Note: modern JavaScript also supports template literals, also sometimes called template strings. Template literals use back-ticks instead of single- or double-quotes, and allow you to interpolate JavaScript expressions. For example:  let a = 1; let s = 'The value is ' + 1 * 6; // Use ${...} to interpolate the value of an expression into a string let templateVersion = `The value is ${1 * 6}`;  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}